{"meta":{"title":"伏诗","subtitle":"","description":"","author":"伏诗","url":"http://wxnsoul.github.io","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"03-31","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-31","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"03-31","excerpt":""}],"posts":[{"title":"使用七牛云来上传图片","text":"mpic使用学习:https://www.jianshu.com/p/7c537ccf18f9 一开始使用在github上建仓库然后使用git上传在获取链接,这样子上传图片真的是麻烦的不得了,在了解了mpic之后,,,,啊啊啊啊,真的方便,使用图片跟word里面差不错了,甚至还可以直接上传QQ截图和复制的图片自动上传…真是6666 只不过你需要打开这些功能 可惜七牛云上面的开辟的空间只有30天可用时间,得自己去注册一个才可以无限用下去.我自己去阿里云注册了个域名 选一个自己喜欢后缀,合适得价位买一个就好. 但是买完之后不去备案得花是不能够使用得,,还得先去备案.备案推荐这篇文章,写的很详细:https://blog.51cto.com/13373096/2339036中间自己碰到了几个坑总结一下:备案前提 网站备案前提准备：1、备案域名，准备需要备案的域名（域名可以不在阿里云），域名需要实名认证（个人域名就个人认证，企业域名就企业认证），域名备案主体要与实名认证信息相符合。 2、备案服务号，在阿里云备案需要备案服务号，购买阿里云大陆地域的ECS云服务器、虚拟主机、轻量应用服务器等就可以申请备案号，如何申请备案号参考：阿里云备案服务号申请方法及说明 3、备案材料，个人备案需要×××图片、《网站备案真实性核验单》（核验单在备案过程中即可下载，按照流程操作即可），由于当地管局备案规则不同，有可能还需要域名证书，域名证书需要去域名注册商网站上获取。企业备案需要营业执照、备案负责人和网站负责人×××件照片、《网站备案真实性核验单》，另外，由于当地管局备案规则不同，有可能需要其他证明材料，例如域名证书、法定代表人委托授权书等，按照要求准备材料即可。 备案域名就有坑,你实名注册之后,其实是还需要等待三天才是真正得注册完成工信部那边还没跟新你的消息,所以后面我备案死活进行不下去 备案服务号也是,需要你有服务器才可以去申请,但是我只买了个域名(其实如果是学生得花可以去买个学生机,不贵,9.5一个月)但是当时自己没想买,就百度到了一个公众号花9.9买了一个备案服务号然后选择使用备案服务号可以","path":"2020/04/02/使用七牛云来上传图片/","date":"04-02","excerpt":"","tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"}]},{"title":"zkaq--序列化与反序列化","text":"定义:序列化是将对象的状态信息转换为可以存储或传输的形式的过程 代码为： serialize ( mixed $value )反序列化则相反，代码为：unserialize ( string $str )如果只是这样，那么应该没有什么可以利用的漏洞。然而，serialize ( mixed $value )与unserialize ( string $str )这两个函数在使用时，会自动使用一些魔法函数，以及，如果在定义的类内存在魔法函数，也会自动调用 也就是说,序列化与反序列化必须要配合一些魔法函数才能发挥作用 反序列化即逆过程，由字节流还原成对象。Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectInputStream类的readObject()方法用于反序列化。下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复问题在于，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。所以这个问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；假若反序列化可以设置Java类型的白名单，那么问题的影响就小了很多。反序列化问题由来已久，且并非Java语言特有，在其他语言例如PHP和Python中也有相似的问题。 函数介绍 变量 FILE这是用于返回当前访问得文件得目录的 show_source()函数###用于显示页面源代码的,括号中填路径,配合FILE使用就是显示当前页面的源代码 魔法函数__toString###__toString() 是魔术方法的一种，具体用途是当一个对象被当作字符串对待的时候，会触发这个魔术方法以下说明摘自PHP官方手册public string __toString ( void )__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。Warning不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 *输出字符串时是不会触发的,把类当字符串输出才会触发* ###其余常用的魔法函数### writeup题解 这是题目的源码,很明显是代码审计第一行可以得知flag在./flag.php中访问一下什么也没有,检查源代码也没有.这说明服务器端的php代码并没有输出值.需要用到show_resource才能看到flag 思路Highlight_file(,true)就是确认开启代码高亮引用了一个魔术方法toString,检测到把类当初字符串输出后就会会把readme.txt和$this-&gt;source拼接在一起输出.源码中赋值的是FILE__所以这个页面会输出源码,如果我们把source的赋值变成flag.php把岂不是也能输出flag了?而全文就只有一个输出类的地方似乎就是检测get传参的那边.他会把当前文件的路径名传给resource变量然后输出.但其实还有一个输出的点,那就是就相当于echo $tode 这里很明显是把数组todos遍历输出在cookie传参的时候会有用到todos,会把m反序列化之后传给todos,但是这时候的todos并不是数组,所以只要强行给m值加上一个中括号,这样todos就变成了一个数组变量S是已经无法修改了只能是赋值FILE,所以得在另外一个输出点下手.Cookie判断里,substr($a,32)和substr($a,0,32)前者是从$a第32位之后开始取值,后者是取值前32. &nbsp如果h=md5(m)就会给todos赋值,c是我们可以控制的,这说明c应该是由md5(m).m构成,这样就变成了md5(m)==md5(m),而m会被反序列化,说明c的后32位应该先序列化.只要把我们想要的flag.php序列化,然后给m,todos输出就会得到源码.但是todos必须是数组才会输出,所以得给readme对象再加一个[],然后再去序列化 这里的a指数组,i指第几个元素,0就是第零个这里的序列化是非常的关键的!!!必须使用readme类,source变量!!!这样反序列化之后就相当于给这个类的source复制成自己想要的了! 的时候就能输出源码了因为只有readme类里面才有这个__toString函数!这个函数也只输出source变量的源码!我们把序列化之后的字符串md5加密,得到e2d4f7dcc43ee1db7f69e76303d0105c把他们拼接在一起得到e2d4f7dcc43ee1db7f69e76303d0105ca:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}},todos就能执行foreach,在cookie中被反序列化后就是一个有着信息的数组类,在foreach中输出.就会触发toString.这边有个小提示,cookie传参和get传参一样,是会先进行url编码的,所以得先编码再传参cookie,用burp抓包修改. e2d4f7dcc43ee1db7f69e76303d0105ca%3a1%3a%7bi%3a0%3bO%3a6%3a%22readme%22%3a1%3a%7bs%3a6%3a%22source%22%3bs%3a8%3a%22flag.php%22%3b%7d%7d 紧接着抓包修改页面,把cookie值改成上面一串,成功得到flag 总结cookie传过去之后的流程: if(isset($COOKIE[‘todos’]))接收到cookie里的todos传参,为真进入if判断 然后把todos值赋给了$c,$h接收了$c的前32位,$m接收了$c的从第33位到结束所有的 把$m md5加密后与$h比较发现是一样的,就将$m反序列化,此时得到的就是[$readme],它是一个数组,数组中是一个readme对象,source的值是flag.php 因为没有get,post传参所以直接往下执行,直接遍历输出todos,输出readme类之后就会触发__toString魔术方法,自动输出该方法里的source页面的代码,和readme.txt拼接在一起后输出 得到了flag","path":"2020/04/01/zkaq-序列化与反序列化/","date":"04-01","excerpt":"","tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2020/03/31/hello-world/","date":"03-31","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"博客学习","slug":"博客学习","permalink":"http://wxnsoul.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"},{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://wxnsoul.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}